/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.1.4, Date: 06-Jul-2012.
 */
#include "HNBAP-IEs.h"
#include "HNBAP-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD_Access_stratum_release_indicator (OSCTXT* pctxt, Access_stratum_release_indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = r99; break;
         case 1: *pvalue = rel_4; break;
         case 2: *pvalue = rel_5; break;
         case 3: *pvalue = rel_6; break;
         case 4: *pvalue = rel_7; break;
         case 5: *pvalue = rel_8; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_BackoffTimer (OSCTXT* pctxt, BackoffTimer* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(3600));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_CauseRadioNetwork (OSCTXT* pctxt, CauseRadioNetwork* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(13));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = overload; break;
         case 1: *pvalue = unauthorised_Location; break;
         case 2: *pvalue = unauthorised_HNB; break;
         case 3: *pvalue = hNB_parameter_mismatch; break;
         case 4: *pvalue = invalid_UE_identity; break;
         case 5: *pvalue = uE_not_allowed_on_this_HNB; break;
         case 6: *pvalue = uE_unauthorised; break;
         case 7: *pvalue = connection_with_UE_lost; break;
         case 8: *pvalue = ue_RRC_telease; break;
         case 9: *pvalue = hNB_not_registered; break;
         case 10: *pvalue = unspecified; break;
         case 11: *pvalue = normal; break;
         case 12: *pvalue = uE_relocated; break;
         case 13: *pvalue = ue_registered_in_another_HNB; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_CauseTransport (OSCTXT* pctxt, CauseTransport* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transport_resource_unavailable; break;
         case 1: *pvalue = unspecified_1; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_CauseProtocol (OSCTXT* pctxt, CauseProtocol* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = transfer_syntax_error; break;
         case 1: *pvalue = abstract_syntax_error_reject; break;
         case 2: *pvalue = abstract_syntax_error_ignore_and_notify; break;
         case 3: *pvalue = message_not_compatible_with_receiver_state; break;
         case 4: *pvalue = semantic_error; break;
         case 5: *pvalue = unspecified_2; break;
         case 6: *pvalue = abstract_syntax_error_falsely_constructed_message; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_CauseMisc (OSCTXT* pctxt, CauseMisc* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = processing_overload; break;
         case 1: *pvalue = hardware_failure; break;
         case 2: *pvalue = o_and_m_intervention; break;
         case 3: *pvalue = unspecified_3; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_CellIdentity (OSCTXT* pctxt, CellIdentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(28), OSUINTCONST(28), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_Context_ID (OSCTXT* pctxt, Context_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_CSG_ID (OSCTXT* pctxt, CSG_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(27), OSUINTCONST(27), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_CSG_Indicator (OSCTXT* pctxt, CSG_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = csg_capable; break;
         case 1: *pvalue = not_csg_capable; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_CI (OSCTXT* pctxt, CI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_CN_DomainIndicator (OSCTXT* pctxt, CN_DomainIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = cs_domain; break;
      case 1: *pvalue = ps_domain; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_ESN (OSCTXT* pctxt, ESN* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_HNB_Identity_Info (OSCTXT* pctxt, HNB_Identity_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(255), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_IMEI (OSCTXT* pctxt, IMEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(60), OSUINTCONST(60), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_IMSI (OSCTXT* pctxt, IMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_IMSIDS41 (OSCTXT* pctxt, IMSIDS41* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(5), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_Ipv4Address (OSCTXT* pctxt, Ipv4Address* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_Ipv6Address (OSCTXT* pctxt, Ipv6Address* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_LAC (OSCTXT* pctxt, LAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_PLMNidentity (OSCTXT* pctxt, PLMNidentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_PTMSI (OSCTXT* pctxt, PTMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RAC (OSCTXT* pctxt, RAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_Registration_Cause (OSCTXT* pctxt, Registration_Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = emergency_call; break;
         case 1: *pvalue = normal_1; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_RNC_ID (OSCTXT* pctxt, RNC_ID* pvalue)
{
   int stat = 0;

   stat = pd_ConsUInt16 (pctxt, pvalue, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_SAC (OSCTXT* pctxt, SAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_TMSIDS41 (OSCTXT* pctxt, TMSIDS41* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(17), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_OctetString (pctxt,
                          &pvalue->numocts,
                          pvalue->data,
                          sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_TypeOfError (OSCTXT* pctxt, TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = not_understood; break;
         case 1: *pvalue = missing; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_AltitudeAndDirection_directionOfAltitude (OSCTXT* pctxt, AltitudeAndDirection_directionOfAltitude* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = height; break;
      case 1: *pvalue = depth; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_GeographicalCoordinates_latitudeSign (OSCTXT* pctxt, GeographicalCoordinates_latitudeSign* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = north; break;
      case 1: *pvalue = south; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_TMSILAI_tMSI (OSCTXT* pctxt, TMSILAI_tMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_AltitudeAndDirection (OSCTXT* pctxt, AltitudeAndDirection* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode directionOfAltitude */

   stat = asn1PD_AltitudeAndDirection_directionOfAltitude (pctxt, &pvalue->directionOfAltitude);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode altitude */

   stat = pd_ConsUInt16 (pctxt, &pvalue->altitude, OSUINTCONST(0), OSUINTCONST(32767));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_Cause (OSCTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* radioNetwork */
         case 0:
            stat = asn1PD_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* transport */
         case 1:
            stat = asn1PD_CauseTransport (pctxt, &pvalue->u.transport);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* protocol */
         case 2:
            stat = asn1PD_CauseProtocol (pctxt, &pvalue->u.protocol);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* misc */
         case 3:
            stat = asn1PD_CauseMisc (pctxt, &pvalue->u.misc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);
      pvalue->t = 5;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_IE_List_element (OSCTXT* pctxt, CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iECriticality */

   stat = asn1PD_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_ID */

   stat = asn1PD_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode typeOfError */

   stat = asn1PD_TypeOfError (pctxt, &pvalue->typeOfError);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   CriticalityDiagnostics_IE_List_element* pdata;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtxDListAllocNodeAndData (pctxt, CriticalityDiagnostics_IE_List_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CriticalityDiagnostics_IE_List_element (pdata);

      stat = asn1PD_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_CriticalityDiagnostics (OSCTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.procedureCodePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.triggeringMessagePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.procedureCriticalityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iEsCriticalityDiagnosticsPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      stat = asn1PD_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      stat = asn1PD_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      stat = asn1PD_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      asn1Init_CriticalityDiagnostics_IE_List (&pvalue->iEsCriticalityDiagnostics);

      stat = asn1PD_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_CGI (OSCTXT* pctxt, CGI* pvalue)
{
   int stat = 0;
   OSBOOL optbit = FALSE;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode pLMNidentity */

   asn1Init_PLMNidentity (&pvalue->pLMNidentity);

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode lAC */

   asn1Init_LAC (&pvalue->lAC);

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode cI */

   asn1Init_CI (&pvalue->cI);

   stat = asn1PD_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PD_GeographicalCoordinates (OSCTXT* pctxt, GeographicalCoordinates* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode latitudeSign */

   stat = asn1PD_GeographicalCoordinates_latitudeSign (pctxt, &pvalue->latitudeSign);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode latitude */

   stat = pd_ConsUnsigned (pctxt, &pvalue->latitude, OSUINTCONST(0), OSUINTCONST(8388607));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode longitude */

   stat = pd_ConsInteger (pctxt, &pvalue->longitude, OSINTCONST(-8388608), OSINTCONST(8388607));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_GeographicalLocation (OSCTXT* pctxt, GeographicalLocation* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode geographicalCoordinates */

   asn1Init_GeographicalCoordinates (&pvalue->geographicalCoordinates);

   stat = asn1PD_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode altitudeAndDirection */

   asn1Init_AltitudeAndDirection (&pvalue->altitudeAndDirection);

   stat = asn1PD_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_UTRANCellID (OSCTXT* pctxt, UTRANCellID* pvalue)
{
   int stat = 0;
   OSBOOL optbit = FALSE;

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode lAC */

   asn1Init_LAC (&pvalue->lAC);

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode rAC */

   asn1Init_RAC (&pvalue->rAC);

   stat = asn1PD_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode pLMNidentity */

   asn1Init_PLMNidentity (&pvalue->pLMNidentity);

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode uTRANcellID */

   asn1Init_CellIdentity (&pvalue->uTRANcellID);

   stat = asn1PD_CellIdentity (pctxt, &pvalue->uTRANcellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PD_MacroCellID (OSCTXT* pctxt, MacroCellID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* uTRANCellID */
         case 0:
            pvalue->u.uTRANCellID = rtxMemAllocType (pctxt, UTRANCellID);

            if (pvalue->u.uTRANCellID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UTRANCellID (pvalue->u.uTRANCellID);

            asn1Init_UTRANCellID (pvalue->u.uTRANCellID);

            stat = asn1PD_UTRANCellID (pctxt, pvalue->u.uTRANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* gERANCellID */
         case 1:
            pvalue->u.gERANCellID = rtxMemAllocType (pctxt, CGI);

            if (pvalue->u.gERANCellID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CGI (pvalue->u.gERANCellID);

            asn1Init_CGI (pvalue->u.gERANCellID);

            stat = asn1PD_CGI (pctxt, pvalue->u.gERANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);
      pvalue->t = 3;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

EXTERN int asn1PD_MacroCoverageInformation (OSCTXT* pctxt, MacroCoverageInformation* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode cellIdentity */

   asn1Init_MacroCellID (&pvalue->cellIdentity);

   stat = asn1PD_MacroCellID (pctxt, &pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HNB_Location_Information (OSCTXT* pctxt, HNB_Location_Information* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.macroCoverageInfoPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.geographicalCoordinatesPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode macroCoverageInfo */

   if (pvalue->m.macroCoverageInfoPresent) {
      asn1Init_MacroCoverageInformation (&pvalue->macroCoverageInfo);

      stat = asn1PD_MacroCoverageInformation (pctxt, &pvalue->macroCoverageInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode geographicalCoordinates */

   if (pvalue->m.geographicalCoordinatesPresent) {
      asn1Init_GeographicalLocation (&pvalue->geographicalCoordinates);

      stat = asn1PD_GeographicalLocation (pctxt, &pvalue->geographicalCoordinates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HNB_Identity (OSCTXT* pctxt, HNB_Identity* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode hNB_Identity_Info */

   asn1Init_HNB_Identity_Info (&pvalue->hNB_Identity_Info);

   stat = asn1PD_HNB_Identity_Info (pctxt, &pvalue->hNB_Identity_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_IMSIESN (OSCTXT* pctxt, IMSIESN* pvalue)
{
   int stat = 0;

   /* decode iMSIDS41 */

   asn1Init_IMSIDS41 (&pvalue->iMSIDS41);

   stat = asn1PD_IMSIDS41 (pctxt, &pvalue->iMSIDS41);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode eSN */

   asn1Init_ESN (&pvalue->eSN);

   stat = asn1PD_ESN (pctxt, &pvalue->eSN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_IP_Address_ipaddress (OSCTXT* pctxt, IP_Address_ipaddress* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* ipv4info */
         case 0:
            pvalue->u.ipv4info = rtxMemAllocType (pctxt, Ipv4Address);

            if (pvalue->u.ipv4info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ipv4Address (pvalue->u.ipv4info);

            asn1Init_Ipv4Address (pvalue->u.ipv4info);

            stat = asn1PD_Ipv4Address (pctxt, pvalue->u.ipv4info);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* ipv6info */
         case 1:
            pvalue->u.ipv6info = rtxMemAllocType (pctxt, Ipv6Address);

            if (pvalue->u.ipv6info == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ipv6Address (pvalue->u.ipv6info);

            asn1Init_Ipv6Address (pvalue->u.ipv6info);

            stat = asn1PD_Ipv6Address (pctxt, pvalue->u.ipv6info);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);
      pvalue->t = 3;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

EXTERN int asn1PD_IP_Address (OSCTXT* pctxt, IP_Address* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode ipaddress */

   asn1Init_IP_Address_ipaddress (&pvalue->ipaddress);

   stat = asn1PD_IP_Address_ipaddress (pctxt, &pvalue->ipaddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_LAI (OSCTXT* pctxt, LAI* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode pLMNID */

   asn1Init_PLMNidentity (&pvalue->pLMNID);

   stat = asn1PD_PLMNidentity (pctxt, &pvalue->pLMNID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode lAC */

   asn1Init_LAC (&pvalue->lAC);

   stat = asn1PD_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_RAI (OSCTXT* pctxt, RAI* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode lAI */

   asn1Init_LAI (&pvalue->lAI);

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode rAC */

   asn1Init_RAC (&pvalue->rAC);

   stat = asn1PD_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_PTMSIRAI (OSCTXT* pctxt, PTMSIRAI* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode pTMSI */

   asn1Init_PTMSI (&pvalue->pTMSI);

   stat = asn1PD_PTMSI (pctxt, &pvalue->pTMSI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode rAI */

   asn1Init_RAI (&pvalue->rAI);

   stat = asn1PD_RAI (pctxt, &pvalue->rAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_TMSILAI (OSCTXT* pctxt, TMSILAI* pvalue)
{
   int stat = 0;

   /* decode tMSI */

   asn1Init_TMSILAI_tMSI (&pvalue->tMSI);

   stat = asn1PD_TMSILAI_tMSI (pctxt, &pvalue->tMSI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode lAI */

   asn1Init_LAI (&pvalue->lAI);

   stat = asn1PD_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_UE_Capabilities (OSCTXT* pctxt, UE_Capabilities* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode access_stratum_release_indicator */

   stat = asn1PD_Access_stratum_release_indicator (pctxt, &pvalue->access_stratum_release_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode csg_indicator */

   stat = asn1PD_CSG_Indicator (pctxt, &pvalue->csg_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_UE_Identity (OSCTXT* pctxt, UE_Identity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iMSI */
         case 0:
            pvalue->u.iMSI = rtxMemAllocType (pctxt, IMSI);

            if (pvalue->u.iMSI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_IMSI (pvalue->u.iMSI);

            asn1Init_IMSI (pvalue->u.iMSI);

            stat = asn1PD_IMSI (pctxt, pvalue->u.iMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* tMSILAI */
         case 1:
            pvalue->u.tMSILAI = rtxMemAllocType (pctxt, TMSILAI);

            if (pvalue->u.tMSILAI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TMSILAI (pvalue->u.tMSILAI);

            asn1Init_TMSILAI (pvalue->u.tMSILAI);

            stat = asn1PD_TMSILAI (pctxt, pvalue->u.tMSILAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* pTMSIRAI */
         case 2:
            pvalue->u.pTMSIRAI = rtxMemAllocType (pctxt, PTMSIRAI);

            if (pvalue->u.pTMSIRAI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PTMSIRAI (pvalue->u.pTMSIRAI);

            asn1Init_PTMSIRAI (pvalue->u.pTMSIRAI);

            stat = asn1PD_PTMSIRAI (pctxt, pvalue->u.pTMSIRAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* iMEI */
         case 3:
            pvalue->u.iMEI = rtxMemAllocType (pctxt, IMEI);

            if (pvalue->u.iMEI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_IMEI (pvalue->u.iMEI);

            asn1Init_IMEI (pvalue->u.iMEI);

            stat = asn1PD_IMEI (pctxt, pvalue->u.iMEI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* eSN */
         case 4:
            pvalue->u.eSN = rtxMemAllocType (pctxt, ESN);

            if (pvalue->u.eSN == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ESN (pvalue->u.eSN);

            asn1Init_ESN (pvalue->u.eSN);

            stat = asn1PD_ESN (pctxt, pvalue->u.eSN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* iMSIDS41 */
         case 5:
            pvalue->u.iMSIDS41 = rtxMemAllocType (pctxt, IMSIDS41);

            if (pvalue->u.iMSIDS41 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_IMSIDS41 (pvalue->u.iMSIDS41);

            asn1Init_IMSIDS41 (pvalue->u.iMSIDS41);

            stat = asn1PD_IMSIDS41 (pctxt, pvalue->u.iMSIDS41);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* iMSIESN */
         case 6:
            pvalue->u.iMSIESN = rtxMemAllocType (pctxt, IMSIESN);

            if (pvalue->u.iMSIESN == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_IMSIESN (pvalue->u.iMSIESN);

            asn1Init_IMSIESN (pvalue->u.iMSIESN);

            stat = asn1PD_IMSIESN (pctxt, pvalue->u.iMSIESN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* tMSIDS41 */
         case 7:
            pvalue->u.tMSIDS41 = rtxMemAllocType (pctxt, TMSIDS41);

            if (pvalue->u.tMSIDS41 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TMSIDS41 (pvalue->u.tMSIDS41);

            asn1Init_TMSIDS41 (pvalue->u.tMSIDS41);

            stat = asn1PD_TMSIDS41 (pctxt, pvalue->u.tMSIDS41);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 9;

      if (pvalue->t < 9) return LOG_RTERR (pctxt, RTERR_INVOPT);
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);
      pvalue->t = 9;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

