/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.1.4, Date: 06-Jul-2012.
 */
#include "HNBAP-IEs.h"
#include "HNBAP-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PE_Access_stratum_release_indicator (OSCTXT* pctxt, Access_stratum_release_indicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case r99: ui = 0; break;
      case rel_4: ui = 1; break;
      case rel_5: ui = 2; break;
      case rel_6: ui = 3; break;
      case rel_7: ui = 4; break;
      case rel_8: ui = 5; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_BackoffTimer (OSCTXT* pctxt, BackoffTimer value)
{
   int stat = 0;

   if ( (value <= OSUINTCONST(3600)) ) {
      stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(3600));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddStrParm (pctxt, "'value'");
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1PE_CauseRadioNetwork (OSCTXT* pctxt, CauseRadioNetwork value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case overload: ui = 0; break;
      case unauthorised_Location: ui = 1; break;
      case unauthorised_HNB: ui = 2; break;
      case hNB_parameter_mismatch: ui = 3; break;
      case invalid_UE_identity: ui = 4; break;
      case uE_not_allowed_on_this_HNB: ui = 5; break;
      case uE_unauthorised: ui = 6; break;
      case connection_with_UE_lost: ui = 7; break;
      case ue_RRC_telease: ui = 8; break;
      case hNB_not_registered: ui = 9; break;
      case unspecified: ui = 10; break;
      case normal: ui = 11; break;
      case uE_relocated: ui = 12; break;
      case ue_registered_in_another_HNB: ui = 13; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(13));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_CauseTransport (OSCTXT* pctxt, CauseTransport value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case transport_resource_unavailable: ui = 0; break;
      case unspecified_1: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_CauseProtocol (OSCTXT* pctxt, CauseProtocol value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case transfer_syntax_error: ui = 0; break;
      case abstract_syntax_error_reject: ui = 1; break;
      case abstract_syntax_error_ignore_and_notify: ui = 2; break;
      case message_not_compatible_with_receiver_state: ui = 3; break;
      case semantic_error: ui = 4; break;
      case unspecified_2: ui = 5; break;
      case abstract_syntax_error_falsely_constructed_message: ui = 6; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_CauseMisc (OSCTXT* pctxt, CauseMisc value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case processing_overload: ui = 0; break;
      case hardware_failure: ui = 1; break;
      case o_and_m_intervention: ui = 2; break;
      case unspecified_3: ui = 3; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_CellIdentity (OSCTXT* pctxt, CellIdentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(28), OSUINTCONST(28), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_Context_ID (OSCTXT* pctxt, Context_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_CSG_ID (OSCTXT* pctxt, CSG_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(27), OSUINTCONST(27), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_CSG_Indicator (OSCTXT* pctxt, CSG_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case csg_capable: ui = 0; break;
      case not_csg_capable: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_CI (OSCTXT* pctxt, CI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_CN_DomainIndicator (OSCTXT* pctxt, CN_DomainIndicator value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case cs_domain: ui = 0; break;
      case ps_domain: ui = 1; break;
      default: rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_ESN (OSCTXT* pctxt, ESN* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_HNB_Identity_Info (OSCTXT* pctxt, HNB_Identity_Info* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(255), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_IMEI (OSCTXT* pctxt, IMEI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(60), OSUINTCONST(60), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_IMSI (OSCTXT* pctxt, IMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(8), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_IMSIDS41 (OSCTXT* pctxt, IMSIDS41* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(5), OSUINTCONST(7), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_Ipv4Address (OSCTXT* pctxt, Ipv4Address* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(4), OSUINTCONST(4), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_Ipv6Address (OSCTXT* pctxt, Ipv6Address* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(16), OSUINTCONST(16), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_LAC (OSCTXT* pctxt, LAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_PLMNidentity (OSCTXT* pctxt, PLMNidentity* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(3), OSUINTCONST(3), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_PTMSI (OSCTXT* pctxt, PTMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_RAC (OSCTXT* pctxt, RAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(1), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_Registration_Cause (OSCTXT* pctxt, Registration_Cause value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case emergency_call: ui = 0; break;
      case normal_1: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_RNC_ID (OSCTXT* pctxt, RNC_ID value)
{
   int stat = 0;

   stat = pe_ConsUnsigned (pctxt, value, OSUINTCONST(0), OSUINTCONST(65535));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_SAC (OSCTXT* pctxt, SAC* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(2), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_TMSIDS41 (OSCTXT* pctxt, TMSIDS41* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(2), OSUINTCONST(17), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_TypeOfError (OSCTXT* pctxt, TypeOfError value)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   extbit = 0;

   switch (value) {
      case not_understood: ui = 0; break;
      case missing: ui = 1; break;
      default: ui = value; extbit = 1;
   }

   /* extension bit */

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, ui);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_AltitudeAndDirection_directionOfAltitude (OSCTXT* pctxt, AltitudeAndDirection_directionOfAltitude value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case height: ui = 0; break;
      case depth: ui = 1; break;
      default: rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_GeographicalCoordinates_latitudeSign (OSCTXT* pctxt, GeographicalCoordinates_latitudeSign value)
{
   int stat = 0;
   OSUINT32 ui;

   switch (value) {
      case north: ui = 0; break;
      case south: ui = 1; break;
      default: rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_TMSILAI_tMSI (OSCTXT* pctxt, TMSILAI_tMSI* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(32), OSUINTCONST(32), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_AltitudeAndDirection (OSCTXT* pctxt, AltitudeAndDirection* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode directionOfAltitude */

   stat = asn1PE_AltitudeAndDirection_directionOfAltitude (pctxt, pvalue->directionOfAltitude);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altitude */

   if ( (pvalue->altitude <= OSUINTCONST(32767)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->altitude, OSUINTCONST(0), OSUINTCONST(32767));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddStrParm (pctxt, "'pvalue->altitude'");
      rtxErrAddUIntParm (pctxt, pvalue->altitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_Cause (OSCTXT* pctxt, Cause* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* radioNetwork */
         case 1:
            stat = asn1PE_CauseRadioNetwork (pctxt, pvalue->u.radioNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* transport */
         case 2:
            stat = asn1PE_CauseTransport (pctxt, pvalue->u.transport);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* protocol */
         case 3:
            stat = asn1PE_CauseProtocol (pctxt, pvalue->u.protocol);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* misc */
         case 4:
            stat = asn1PE_CauseMisc (pctxt, pvalue->u.misc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_CriticalityDiagnostics_IE_List_element (OSCTXT* pctxt, CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iECriticality */

   stat = asn1PE_Criticality (pctxt, pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_ID */

   stat = asn1PE_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode typeOfError */

   stat = asn1PE_TypeOfError (pctxt, pvalue->typeOfError);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   /* encode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */
   pnode = pvalue->head;

   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      stat = asn1PE_CriticalityDiagnostics_IE_List_element (pctxt, ((CriticalityDiagnostics_IE_List_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode = pnode->next;
   }

   return (stat);
}

EXTERN int asn1PE_CriticalityDiagnostics (OSCTXT* pctxt, CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.procedureCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.triggeringMessagePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.procedureCriticalityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iEsCriticalityDiagnosticsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      stat = asn1PE_ProcedureCode (pctxt, pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      stat = asn1PE_TriggeringMessage (pctxt, pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      stat = asn1PE_Criticality (pctxt, pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      stat = asn1PE_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_CGI (OSCTXT* pctxt, CGI* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAC */

   stat = asn1PE_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cI */

   stat = asn1PE_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_GeographicalCoordinates (OSCTXT* pctxt, GeographicalCoordinates* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latitudeSign */

   stat = asn1PE_GeographicalCoordinates_latitudeSign (pctxt, pvalue->latitudeSign);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latitude */

   if ( (pvalue->latitude <= OSUINTCONST(8388607)) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->latitude, OSUINTCONST(0), OSUINTCONST(8388607));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddStrParm (pctxt, "'pvalue->latitude'");
      rtxErrAddUIntParm (pctxt, pvalue->latitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* encode longitude */

   if ( (pvalue->longitude >= OSINTCONST(-8388608) && pvalue->longitude
       <= OSINTCONST(8388607)) ) {
      stat = pe_ConsInteger (pctxt, pvalue->longitude, OSINTCONST(-8388608), OSINTCONST(8388607));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddStrParm (pctxt, "'pvalue->longitude'");
      rtxErrAddIntParm (pctxt, pvalue->longitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_GeographicalLocation (OSCTXT* pctxt, GeographicalLocation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   stat = asn1PE_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altitudeAndDirection */

   stat = asn1PE_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_UTRANCellID (OSCTXT* pctxt, UTRANCellID* pvalue)
{
   int stat = 0;

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAC */

   stat = asn1PE_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAC */

   stat = asn1PE_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   stat = asn1PE_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode uTRANcellID */

   stat = asn1PE_CellIdentity (pctxt, &pvalue->uTRANcellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_MacroCellID (OSCTXT* pctxt, MacroCellID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* uTRANCellID */
         case 1:
            stat = asn1PE_UTRANCellID (pctxt, pvalue->u.uTRANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* gERANCellID */
         case 2:
            stat = asn1PE_CGI (pctxt, pvalue->u.gERANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_MacroCoverageInformation (OSCTXT* pctxt, MacroCoverageInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellIdentity */

   stat = asn1PE_MacroCellID (pctxt, &pvalue->cellIdentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HNB_Location_Information (OSCTXT* pctxt, HNB_Location_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.macroCoverageInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.geographicalCoordinatesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode macroCoverageInfo */

   if (pvalue->m.macroCoverageInfoPresent) {
      stat = asn1PE_MacroCoverageInformation (pctxt, &pvalue->macroCoverageInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode geographicalCoordinates */

   if (pvalue->m.geographicalCoordinatesPresent) {
      stat = asn1PE_GeographicalLocation (pctxt, &pvalue->geographicalCoordinates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HNB_Identity (OSCTXT* pctxt, HNB_Identity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode hNB_Identity_Info */

   stat = asn1PE_HNB_Identity_Info (pctxt, &pvalue->hNB_Identity_Info);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_IMSIESN (OSCTXT* pctxt, IMSIESN* pvalue)
{
   int stat = 0;

   /* encode iMSIDS41 */

   stat = asn1PE_IMSIDS41 (pctxt, &pvalue->iMSIDS41);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode eSN */

   stat = asn1PE_ESN (pctxt, &pvalue->eSN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_IP_Address_ipaddress (OSCTXT* pctxt, IP_Address_ipaddress* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* ipv4info */
         case 1:
            stat = asn1PE_Ipv4Address (pctxt, pvalue->u.ipv4info);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* ipv6info */
         case 2:
            stat = asn1PE_Ipv6Address (pctxt, pvalue->u.ipv6info);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

EXTERN int asn1PE_IP_Address (OSCTXT* pctxt, IP_Address* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode ipaddress */

   stat = asn1PE_IP_Address_ipaddress (pctxt, &pvalue->ipaddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_LAI (OSCTXT* pctxt, LAI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNID */

   stat = asn1PE_PLMNidentity (pctxt, &pvalue->pLMNID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAC */

   stat = asn1PE_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_RAI (OSCTXT* pctxt, RAI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAI */

   stat = asn1PE_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAC */

   stat = asn1PE_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_PTMSIRAI (OSCTXT* pctxt, PTMSIRAI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pTMSI */

   stat = asn1PE_PTMSI (pctxt, &pvalue->pTMSI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAI */

   stat = asn1PE_RAI (pctxt, &pvalue->rAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_TMSILAI (OSCTXT* pctxt, TMSILAI* pvalue)
{
   int stat = 0;

   /* encode tMSI */

   stat = asn1PE_TMSILAI_tMSI (pctxt, &pvalue->tMSI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAI */

   stat = asn1PE_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_UE_Capabilities (OSCTXT* pctxt, UE_Capabilities* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode access_stratum_release_indicator */

   stat = asn1PE_Access_stratum_release_indicator (pctxt, pvalue->access_stratum_release_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode csg_indicator */

   stat = asn1PE_CSG_Indicator (pctxt, pvalue->csg_indicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_UE_Identity (OSCTXT* pctxt, UE_Identity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 8);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 7);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* iMSI */
         case 1:
            stat = asn1PE_IMSI (pctxt, pvalue->u.iMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* tMSILAI */
         case 2:
            stat = asn1PE_TMSILAI (pctxt, pvalue->u.tMSILAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* pTMSIRAI */
         case 3:
            stat = asn1PE_PTMSIRAI (pctxt, pvalue->u.pTMSIRAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* iMEI */
         case 4:
            stat = asn1PE_IMEI (pctxt, pvalue->u.iMEI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* eSN */
         case 5:
            stat = asn1PE_ESN (pctxt, pvalue->u.eSN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* iMSIDS41 */
         case 6:
            stat = asn1PE_IMSIDS41 (pctxt, pvalue->u.iMSIDS41);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* iMSIESN */
         case 7:
            stat = asn1PE_IMSIESN (pctxt, pvalue->u.iMSIESN);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* tMSIDS41 */
         case 8:
            stat = asn1PE_TMSIDS41 (pctxt, pvalue->u.tMSIDS41);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

