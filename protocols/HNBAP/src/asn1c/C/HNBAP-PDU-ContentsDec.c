/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.1.4, Date: 06-Jul-2012.
 */
#include "HNBAP-PDU-Contents.h"
#include "HNBAP-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD_HnbHNBRegisterRequest (OSCTXT* pctxt, HnbHNBRegisterRequest* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbHNBRegisterAccept (OSCTXT* pctxt, HnbHNBRegisterAccept* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbHNBRegisterReject (OSCTXT* pctxt, HnbHNBRegisterReject* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbHNBDe_Register (OSCTXT* pctxt, HnbHNBDe_Register* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbUERegisterRequest (OSCTXT* pctxt, HnbUERegisterRequest* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbUERegisterAccept (OSCTXT* pctxt, HnbUERegisterAccept* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbUERegisterReject (OSCTXT* pctxt, HnbUERegisterReject* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbUEDe_Register (OSCTXT* pctxt, HnbUEDe_Register* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbErrorIndication (OSCTXT* pctxt, HnbErrorIndication* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_HnbPrivateMessage (OSCTXT* pctxt, HnbPrivateMessage* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode privateIEs */

   asn1Init_PrivateIE_Container (&pvalue->privateIEs);

   stat = asn1PD_PrivateIE_Container (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

