/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.1.4, Date: 06-Jul-2012.
 */
#include "HNBAP-PDU-Contents.h"
#include "HNBAP-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PE_HnbHNBRegisterRequest (OSCTXT* pctxt, HnbHNBRegisterRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbHNBRegisterAccept (OSCTXT* pctxt, HnbHNBRegisterAccept* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbHNBRegisterReject (OSCTXT* pctxt, HnbHNBRegisterReject* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbHNBDe_Register (OSCTXT* pctxt, HnbHNBDe_Register* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbUERegisterRequest (OSCTXT* pctxt, HnbUERegisterRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbUERegisterAccept (OSCTXT* pctxt, HnbUERegisterAccept* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbUERegisterReject (OSCTXT* pctxt, HnbUERegisterReject* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbUEDe_Register (OSCTXT* pctxt, HnbUEDe_Register* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbErrorIndication (OSCTXT* pctxt, HnbErrorIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_bit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   stat = asn1PE_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      stat = asn1PE_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PE_HnbPrivateMessage (OSCTXT* pctxt, HnbPrivateMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = pe_bit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode privateIEs */

   stat = asn1PE_PrivateIE_Container (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->extElem1.count - 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

