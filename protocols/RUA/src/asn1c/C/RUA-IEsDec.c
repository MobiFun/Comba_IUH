/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.1.4, Date: 09-Jul-2012.
 */
#include "RUA-IEs.h"
#include "RUA-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD_RUA_CN_DomainIndicator (OSCTXT* pctxt, RUA_CN_DomainIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = RUA_cs_domain; break;
      case 1: *pvalue = RUA_ps_domain; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   return (stat);
}

EXTERN int asn1PD_RUA_Establishment_Cause (OSCTXT* pctxt, RUA_Establishment_Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = RUA_emergency_call; break;
         case 1: *pvalue = RUA_normal_call; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_Context_ID (OSCTXT* pctxt, RUA_Context_ID* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(24), OSUINTCONST(24), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Ansi_41_IDNNS (OSCTXT* pctxt, RUA_Ansi_41_IDNNS* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(14), OSUINTCONST(14), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_RANAP_Message (OSCTXT* pctxt, RUA_RANAP_Message* pvalue)
{
   int stat = 0;

   stat = pd_DynOctetString (pctxt, (OSDynOctStr*)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_RoutingParameter (OSCTXT* pctxt, RUA_RoutingParameter* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(10), OSUINTCONST(10), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_CauseRadioNetwork (OSCTXT* pctxt, RUA_CauseRadioNetwork* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = RUA_normal; break;
         case 1: *pvalue = RUA_connect_failed; break;
         case 2: *pvalue = RUA_network_release; break;
         case 3: *pvalue = RUA_unspecified; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_CauseTransport (OSCTXT* pctxt, RUA_CauseTransport* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = RUA_transport_resource_unavailable; break;
         case 1: *pvalue = RUA_unspecified_1; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_CauseProtocol (OSCTXT* pctxt, RUA_CauseProtocol* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(6));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = RUA_transfer_syntax_error; break;
         case 1: *pvalue = RUA_abstract_syntax_error_reject; break;
         case 2: *pvalue = RUA_abstract_syntax_error_ignore_and_notify; break;
         case 3: *pvalue = RUA_message_not_compatible_with_receiver_state; break;
         case 4: *pvalue = RUA_semantic_error; break;
         case 5: *pvalue = RUA_unspecified_2; break;
         case 6: *pvalue = RUA_abstract_syntax_error_falsely_constructed_message; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_CauseMisc (OSCTXT* pctxt, RUA_CauseMisc* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = RUA_processing_overload; break;
         case 1: *pvalue = RUA_hardware_failure; break;
         case 2: *pvalue = RUA_o_and_m_intervention; break;
         case 3: *pvalue = RUA_unspecified_3; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_TypeOfError (OSCTXT* pctxt, RUA_TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = RUA_not_understood; break;
         case 1: *pvalue = RUA_missing; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_IntraDomainNasNodeSelector_version_later_futurecoding (OSCTXT* pctxt, RUA_IntraDomainNasNodeSelector_version_later_futurecoding* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(15), OSUINTCONST(15), 0 };
   int stat = 0;

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_BitString (pctxt,
                        &pvalue->numbits,
                        pvalue->data,
                        sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_localPTMSI (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_localPTMSI* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_iMEI (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_iMEI* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_spare2 (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_spare2* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis_spare1 (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis_spare1* pvalue)
{
   int stat = 0;

   /* decode routingparameter */

   asn1Init_RUA_RoutingParameter (&pvalue->routingparameter);

   stat = asn1PD_RUA_RoutingParameter (pctxt, &pvalue->routingparameter);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS_routingbasis (OSCTXT* pctxt, RUA_Gsm_map_IDNNS_routingbasis* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* localPTMSI */
      case 0:
         pvalue->u.localPTMSI = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_localPTMSI);

         if (pvalue->u.localPTMSI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_localPTMSI (pvalue->u.localPTMSI);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_localPTMSI (pvalue->u.localPTMSI);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_localPTMSI (pctxt, pvalue->u.localPTMSI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* tMSIofsamePLMN */
      case 1:
         pvalue->u.tMSIofsamePLMN = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN);

         if (pvalue->u.tMSIofsamePLMN == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN (pvalue->u.tMSIofsamePLMN);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN (pvalue->u.tMSIofsamePLMN);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN (pctxt, pvalue->u.tMSIofsamePLMN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* tMSIofdifferentPLMN */
      case 2:
         pvalue->u.tMSIofdifferentPLMN = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN);

         if (pvalue->u.tMSIofdifferentPLMN == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN (pvalue->u.tMSIofdifferentPLMN);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN (pvalue->u.tMSIofdifferentPLMN);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN (pctxt, pvalue->u.tMSIofdifferentPLMN);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* iMSIresponsetopaging */
      case 3:
         pvalue->u.iMSIresponsetopaging = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging);

         if (pvalue->u.iMSIresponsetopaging == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging (pvalue->u.iMSIresponsetopaging);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging (pvalue->u.iMSIresponsetopaging);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging (pctxt, pvalue->u.iMSIresponsetopaging);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* iMSIcauseUEinitiatedEvent */
      case 4:
         pvalue->u.iMSIcauseUEinitiatedEvent = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent);

         if (pvalue->u.iMSIcauseUEinitiatedEvent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent (pvalue->u.iMSIcauseUEinitiatedEvent);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent (pvalue->u.iMSIcauseUEinitiatedEvent);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent (pctxt, pvalue->u.iMSIcauseUEinitiatedEvent);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* iMEI */
      case 5:
         pvalue->u.iMEI = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_iMEI);

         if (pvalue->u.iMEI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_iMEI (pvalue->u.iMEI);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_iMEI (pvalue->u.iMEI);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_iMEI (pctxt, pvalue->u.iMEI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* spare2 */
      case 6:
         pvalue->u.spare2 = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_spare2);

         if (pvalue->u.spare2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_spare2 (pvalue->u.spare2);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_spare2 (pvalue->u.spare2);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_spare2 (pctxt, pvalue->u.spare2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* spare1 */
      case 7:
         pvalue->u.spare1 = rtxMemAllocType (pctxt, 
            RUA_Gsm_map_IDNNS_routingbasis_spare1);

         if (pvalue->u.spare1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_spare1 (pvalue->u.spare1);

         asn1Init_RUA_Gsm_map_IDNNS_routingbasis_spare1 (pvalue->u.spare1);

         stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis_spare1 (pctxt, pvalue->u.spare1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_RUA_Gsm_map_IDNNS (OSCTXT* pctxt, RUA_Gsm_map_IDNNS* pvalue)
{
   int stat = 0;

   /* decode routingbasis */

   asn1Init_RUA_Gsm_map_IDNNS_routingbasis (&pvalue->routingbasis);

   stat = asn1PD_RUA_Gsm_map_IDNNS_routingbasis (pctxt, &pvalue->routingbasis);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode dummy */

   stat = PD_BIT (pctxt, &pvalue->dummy);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_IntraDomainNasNodeSelector_version_release99_cn_Type (OSCTXT* pctxt, RUA_IntraDomainNasNodeSelector_version_release99_cn_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* gsm_Map_IDNNS */
      case 0:
         pvalue->u.gsm_Map_IDNNS = rtxMemAllocType (pctxt, RUA_Gsm_map_IDNNS);

         if (pvalue->u.gsm_Map_IDNNS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Gsm_map_IDNNS (pvalue->u.gsm_Map_IDNNS);

         asn1Init_RUA_Gsm_map_IDNNS (pvalue->u.gsm_Map_IDNNS);

         stat = asn1PD_RUA_Gsm_map_IDNNS (pctxt, pvalue->u.gsm_Map_IDNNS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* ansi_41_IDNNS */
      case 1:
         pvalue->u.ansi_41_IDNNS = rtxMemAllocType (pctxt, RUA_Ansi_41_IDNNS);

         if (pvalue->u.ansi_41_IDNNS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_Ansi_41_IDNNS (pvalue->u.ansi_41_IDNNS);

         asn1Init_RUA_Ansi_41_IDNNS (pvalue->u.ansi_41_IDNNS);

         stat = asn1PD_RUA_Ansi_41_IDNNS (pctxt, pvalue->u.ansi_41_IDNNS);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_RUA_IntraDomainNasNodeSelector_version_release99 (OSCTXT* pctxt, RUA_IntraDomainNasNodeSelector_version_release99* pvalue)
{
   int stat = 0;

   /* decode cn_Type */

   asn1Init_RUA_IntraDomainNasNodeSelector_version_release99_cn_Type (&pvalue->cn_Type);

   stat = asn1PD_RUA_IntraDomainNasNodeSelector_version_release99_cn_Type (pctxt, &pvalue->cn_Type);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_IntraDomainNasNodeSelector_version_later (OSCTXT* pctxt, RUA_IntraDomainNasNodeSelector_version_later* pvalue)
{
   int stat = 0;

   /* decode futurecoding */

   asn1Init_RUA_IntraDomainNasNodeSelector_version_later_futurecoding (&pvalue->futurecoding);

   stat = asn1PD_RUA_IntraDomainNasNodeSelector_version_later_futurecoding (pctxt, &pvalue->futurecoding);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_IntraDomainNasNodeSelector_version (OSCTXT* pctxt, RUA_IntraDomainNasNodeSelector_version* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* release99 */
      case 0:
         pvalue->u.release99 = rtxMemAllocType (pctxt, 
            RUA_IntraDomainNasNodeSelector_version_release99);

         if (pvalue->u.release99 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_IntraDomainNasNodeSelector_version_release99 (pvalue->u.release99);

         asn1Init_RUA_IntraDomainNasNodeSelector_version_release99 (pvalue->u.release99);

         stat = asn1PD_RUA_IntraDomainNasNodeSelector_version_release99 (pctxt, pvalue->u.release99);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      /* later */
      case 1:
         pvalue->u.later = rtxMemAllocType (pctxt, 
            RUA_IntraDomainNasNodeSelector_version_later);

         if (pvalue->u.later == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RUA_IntraDomainNasNodeSelector_version_later (pvalue->u.later);

         asn1Init_RUA_IntraDomainNasNodeSelector_version_later (pvalue->u.later);

         stat = asn1PD_RUA_IntraDomainNasNodeSelector_version_later (pctxt, pvalue->u.later);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1PD_RUA_IntraDomainNasNodeSelector (OSCTXT* pctxt, RUA_IntraDomainNasNodeSelector* pvalue)
{
   int stat = 0;

   /* decode version */

   asn1Init_RUA_IntraDomainNasNodeSelector_version (&pvalue->version);

   stat = asn1PD_RUA_IntraDomainNasNodeSelector_version (pctxt, &pvalue->version);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_RUA_Cause (OSCTXT* pctxt, RUA_Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   ASN1OpenType openType;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* radioNetwork */
         case 0:
            stat = asn1PD_RUA_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* transport */
         case 1:
            stat = asn1PD_RUA_CauseTransport (pctxt, &pvalue->u.transport);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* protocol */
         case 2:
            stat = asn1PD_RUA_CauseProtocol (pctxt, &pvalue->u.protocol);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         /* misc */
         case 3:
            stat = asn1PD_RUA_CauseMisc (pctxt, &pvalue->u.misc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);
      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);
      pvalue->t = 5;

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

   }

   return (stat);
}

EXTERN int asn1PD_RUA_CriticalityDiagnostics_IE_List_element (OSCTXT* pctxt, RUA_CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode iECriticality */

   stat = asn1PD_RUA_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_ID */

   stat = asn1PD_RUA_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode typeOfError */

   stat = asn1PD_RUA_TypeOfError (pctxt, &pvalue->typeOfError);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_RUA_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_RUA_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, RUA_CriticalityDiagnostics_IE_List* pvalue)
{
   static Asn1SizeCnst lsize1 = { 0, OSUINTCONST(1), OSUINTCONST(256), 0 };
   int stat = 0;
   RUA_CriticalityDiagnostics_IE_List_element* pdata;
   OSRTDListNode* pnode;
   OSUINT32 count = 0;
   OSUINT32 xx1 = 0;

   /* decode length determinant */

   stat = pu_addSizeConstraint (pctxt, &lsize1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pd_Length (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      rtxDListAllocNodeAndData (pctxt, RUA_CriticalityDiagnostics_IE_List_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RUA_CriticalityDiagnostics_IE_List_element (pdata);

      stat = asn1PD_RUA_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1PD_RUA_CriticalityDiagnostics (OSCTXT* pctxt, RUA_CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.procedureCodePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.triggeringMessagePresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.procedureCriticalityPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iEsCriticalityDiagnosticsPresent = optbit;

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.iE_ExtensionsPresent = optbit;

   /* decode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      stat = asn1PD_RUA_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      stat = asn1PD_RUA_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      stat = asn1PD_RUA_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      asn1Init_RUA_CriticalityDiagnostics_IE_List (&pvalue->iEsCriticalityDiagnostics);

      stat = asn1PD_RUA_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Init_RUA_ProtocolExtensionContainer (&pvalue->iE_Extensions);

      stat = asn1PD_RUA_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

