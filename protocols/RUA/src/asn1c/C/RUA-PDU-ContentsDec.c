/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.1.4, Date: 09-Jul-2012.
 */
#include "RUA-PDU-Contents.h"
#include "RUA-Constants.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PD_RUA_Connect (OSCTXT* pctxt, RUA_Connect* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_RUA_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_RUA_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_RUA_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_RUA_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_DirectTransfer (OSCTXT* pctxt, RUA_DirectTransfer* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_RUA_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_RUA_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_RUA_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_RUA_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_Disconnect (OSCTXT* pctxt, RUA_Disconnect* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_RUA_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_RUA_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_RUA_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_RUA_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_ConnectionlessTransfer (OSCTXT* pctxt, RUA_ConnectionlessTransfer* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_RUA_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_RUA_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_RUA_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_RUA_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_ErrorIndication (OSCTXT* pctxt, RUA_ErrorIndication* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* optional bits */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   stat = PD_BIT (pctxt, &optbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->m.protocolExtensionsPresent = optbit;

   /* decode protocolIEs */

   asn1Init_RUA_ProtocolIE_Container (&pvalue->protocolIEs);

   stat = asn1PD_RUA_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Init_RUA_ProtocolExtensionContainer (&pvalue->protocolExtensions);

      stat = asn1PD_RUA_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

EXTERN int asn1PD_RUA_PrivateMessage (OSCTXT* pctxt, RUA_PrivateMessage* pvalue)
{
   int stat = 0;
   OSCTXT lctxt;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i;
   OSBOOL optbit = FALSE;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = PD_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode privateIEs */

   asn1Init_RUA_PrivateIE_Container (&pvalue->privateIEs);

   stat = asn1PD_RUA_PrivateIE_Container (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {

      /* decode extension optional bits length */

      stat = pd_SmallNonNegWholeNumber (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      bitcnt += 1;

      rtxPreInitContext (&lctxt);
      rtxCopyContext (&lctxt, pctxt);

      stat = pd_moveBitCursor (pctxt, bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      for (i = 0; i < bitcnt; i++) {
         PD_BIT (&lctxt, &optbit);

         if (optbit) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
            pOpenType->numocts = openType.numocts;
            pOpenType->data = openType.data;
            rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }
   }

   return (stat);
}

