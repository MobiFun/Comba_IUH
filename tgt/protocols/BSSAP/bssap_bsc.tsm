##############################################################
# $URL: http://memo.prisma/svn/tm/scriptProt/BSSAP_COMBA/tags/BSSAP_COMBA-1.2.0/scripts/bssap_bsc.tsm $
#
# $Author: roger $
#
# Description: BSSAP layer on BSS side
#
# $Rev: 53313 $
#
# $Date: 2012-07-19 15:19:13 +0200 (Thu, 19 Jul 2012) $
##############################################################

#Global var for RR
set glRrGcReqMsId 0
set glRrGcReqGrCallRef 0

##############################################################
# INIT
##############################################################

proc Init { args } {

	# Global Variables
	global _HandleRxSignalProc _self protName 
	global glBscDb glMsDb glBssapDb
	global glVGCSBSSAPPid __tm_top glMSVgcsDb
	global __bssap_plmn
	
	# BSSAP script directory 
	include "common/utils/generalUtils.tsm"
	include "common/utils/Ss7SaalUtils.tsm"
	include "common/utils/L3Utils.tsm"
	include "protocols/BSSAP/bssap_common.tsm"
	include "protocols/BSSAP/bssap_utils.tsm"
	include "protocols/BSSAP/bssap_multi_inst.tsm"
	include "ctl/userplane.tsm"

	# SVN Revision Checking #
	set url "\$URL: http://memo.prisma/svn/tm/scriptProt/BSSAP_COMBA/tags/BSSAP_COMBA-1.2.0/scripts/bssap_bsc.tsm $"
	set rev "\$Rev: 53313 $"
	logv0 "[GetName $url]: version [Version "script" $url $rev]"

	# evaluate configuration
	set cfgFile [lindex $args 0]
	uplevel #0 include $cfgFile

	SetNetside

	# protocol name 
	set protName BSSAP

	register $protName

	# Create Ms Db
	set glMsDb [lindex $args 1]

	# Bssap Adapation Layer
	set Al [lindex $args 2]
	include "$Al"

	# Calculate the PLMN string
	#RetrievePLMN

	if 0 {
		# replace this check with a check on IMSI and SysInfoLAI
		if { [info exists __bssap_plmn] } {
			set purePlmn [PurePlmn 2]
		} else {
			set purePlmn [PurePlmn]
		}

		# Compare IMSI of the mobiles with 'old' HPLMN (value of the cfg file)
		if { [ComparePlmnImsi $purePlmn $glMsDb] != -1 } {
			log "Init: WARNING: the mobiles [lsort -integer [ComparePlmnImsi $purePlmn $glMsDb]] have the IMSI that doesn't belove to the HPLMN=$purePlmn"
		}

	}

	# Create Internal Ms Database
	set glBssapDb BssapDb
	CreateBssapDb $glBssapDb

	# Create Internal Bsc Database
	set glBscDb BssapBscDb
	CreateBscDb $glBscDb

	if { [GsInterfaceActive] } {
		if { ![IsAnySgsnLink $glBscDb] } {
			# Resource TDM Management
			CreateTrafficRes
		}
	} else {
		# Resource TDM Management
		CreateTrafficRes
	}

	# handle multi-instance
	set _HandleRxSignalProc RxSignalProc


	if { $__tm_top > 5 } {
		global _self
		DeclareInternalVGCSSignals
		# Create the VGCS Side and store his pid
		set glVGCSBSSAPPid [spawn "protocols/BSSAP/vgcs_bsc.tsm $_self $glMsDb"]
		set glMSVgcsDb MSVGCSdb
		CreateMSVgcsDb $glMSVgcsDb
	} else {
		set glVGCSBSSAPPid ?
	}

	# Number of times for sending of the RST signal to MSC (O&M parameter)
	global glNumOfAvailReset glNumOfTotReset glUnlimitedResetAttempts

	global __unlimited_bssap_reset_attempts
	if {[info exists __unlimited_bssap_reset_attempts] && $__unlimited_bssap_reset_attempts} {
		set glUnlimitedResetAttempts 1
	} else {
		set glUnlimitedResetAttempts 0
	}
	set glNumOfTotReset 5
	set glNumOfAvailReset $glNumOfTotReset

	# Create Instance Null
	global glInstNull
	set glInstNull 0

	if { $::glAoip } {
		set ::glFirst 1
	}	

    nextstate BssapWaitConfig
}

proc IsAnySgsnLink { bscDb } {
	global __bsc_db
	set bscDb [DbGetName $__bsc_db]
	set indexList [DbGetIndexList $bscDb]
	set result 0
	foreach idx $indexList {
		set sgsnLink [DbGet $bscDb $idx GsLink]
		if { $sgsnLink } {
			return 1
		}
	}
	
	return $result
}

proc DeclareInternalVGCSSignals { } {
	typedef { STRUCT {UINT MsId} {STRING SpcStkIdCid} VGCS_CALL_BEGIN }
	typedef { STRUCT {UINT MsId} VGCS_TALKER_REQUEST }
	typedef { STRUCT {UINT MsId} {HEXSTR GroupCallRef} {STRING SpcStkIdCid} VGCS_JOIN_REQ }
	typedef { STRUCT {UINT MsId} {HEXSTR GroupCallRef} {STRING SpcStkIdCid} VGCS_SUBTALKER }
	typedef { STRUCT {STRING Signal} VGCS_FORWARD_TO_MM }
}

proc CreateMSVgcsDb { dbname } {
	lappend idxList [list	Idx				Index]
	lappend idxList [list	PduGrCallRef	Normal	Read/Write]
	lappend idxList [list	Status			Normal	Read/Write]

	#CreateDataBase $dbname
}

#------------------------------------------------------------#
# Configuration procedure 					
#------------------------------------------------------------#
proc BssapConfig { } {

	# Declare and Initialize Global Variables
	global glBssapDb glMsDb glInstNull glBssapPlmn 

	set nstate BssapIdle

	DbCreateDefEntry $glBssapDb $glInstNull
	DbSet $glBssapDb $glInstNull State $nstate 
	DbSet $glBssapDb $glInstNull SaveQue [sdlNewSaveQue]

	# Configure Parameters for every DB Index
	set idxlist [DbGetIndexList $glMsDb]
	foreach idx $idxlist {

		log "BssapConfig: idx=$idx"

		DbCreateDefEntry $glBssapDb $idx

		# Set State
		DbSet $glBssapDb $idx State $nstate 

		set lai [DbGet $glMsDb $idx SysInfoLAI]
		# Set HPLMN
		set plmn [ComposePlmn $lai]
		log "BssapConfig: plmn=$plmn"
		DbSet $glBssapDb $idx PLMN $plmn 

		# Set LAC 
		set lac [hocts $lai 3 4]
		DbSet $glBssapDb $idx LAC $lac

		# Set CellId
		set cellid [DbGet $glMsDb $idx CellId]
		DbSet $glBssapDb $idx CellId $cellid

		DbSet $glBssapDb $idx SaveQue [sdlNewSaveQue]
	}

	log "BssapConfig: old_HPLMN=$plmn; LAC=$lac; CellId=$cellid"; #cDEBUG

	SendNotifyOk

	logscr ""
	logscr "BSSAP BRING-UP COMPLETE"
	logscr ""

	# This reset circuit is necessary to initialize the Nokia BSC tested in Vodafone
   	if { 0 } {
        global numTs _gstate glMsId

		set _gstate $nstate
        set numTs 30

		set glMsId 1
		DbSet $glBssapDb 1 Spc 2000 	
		DbSet $glBssapDb 1 StkId 2964

		set cicList { 0001 0002 0003 0004 0005 0006 0007 0008 0009 000a 000b 000c 000d 000e 000f \
					  0011 0012 0013 0014 0015 0016 0017 0018 0019 001a 001b 001c 001d 001e 001f }

		foreach cic $cicList {

	        new RST_CIRC s
			wr s circ_idty_code $cic
			wr s cause 07

			SendSccpNUnitdataReq $s
		}
		nextstate WaitingForAllRstCircAck
    }

	nextstate $nstate
}

proc SendNotifyOk { } {

	# Global Variables

	new 	BSSAP_OM_CFG_ACK s
	send  s
	LogOutputMsg $s
}

##############################################################
# BSSMAP procedures (see TS 3GPP 08.08 v.8.15.0)
##############################################################

#------------------------------------------------------------#
# 3.1.1 "Assignment" procedure functions 
#------------------------------------------------------------#
proc RcvAssignmentReq { } {

	# Global Variables
	global _sig protName glBscDb glBtsDb glBssapDb glMsId

	LogInputMsg $_sig

	# Get Bsc Id
	set lac [DbGet $glBssapDb $glMsId LAC]
	set ci [DbGet $glBssapDb $glMsId CellId]
	set bscid [GetBscIdByCellIdfr $lac $ci glBtsDb]
	if { [string match "-1" $bscid] } {
		exit "RcvAssignmentReq: BSC identity unknown (LAC=$lac, CellId=$ci)"
	}

	# Mixed UserPlane IP/TDM management
	if { ![IsVoid [rd _sig codec_list]] } {
		log "RcvAssignmentReq: field 'MSC Preferred Codec List' exists in received 'ASG_REQ' -> IP or MIXED IP/TDM transport is preferred by the MSC for the Ms:$glMsId"
		# check if UP interface-type MSC Preferred is equal to the UP interface-type BSS supported
		log "RcvAssignmentReq ---------"
		set aoipMscPcl [rd _sig codec_list]
		log "codec desiderato dal MSC a partire dalla codec_list=$aoipMscPcl"
		DbSet $glBssapDb $glMsId AoipMscPcl $aoipMscPcl
		set upCnSide [GetUpFromCodec $glMsId 0 $aoipMscPcl]
		log "---------------------------"
		log "codec desiderato dal BSS"

		set upBssSide [CheckCodecList]
		
		if { $upBssSide == 0 } {
	  		set upBssSide "TDM"
		} elseif { $upBssSide == 1 } {
	  		set upBssSide "MIXED"
		} elseif  { $upBssSide == 2 } {
	  		set upBssSide "IP"
		}
	
		set nameProc "RcvAssignmentReq"
		
		if { $::glAoip } {
			Trace "log" $::__trace_AUoIP $nameProc "upCnSide=$upCnSide; upBssSide=$upBssSide"
		}
		log "RcvAssignmentReq ---------"

		if { $upCnSide == $upBssSide || $upCnSide == "MIXED" && $upBssSide == "IP" || $upCnSide == "IP" && $upBssSide == "MIXED" || $upCnSide == "MIXED" && $upBssSide == "TDM" } {
			log "RcvAssignmentReq: user plane that BSS supports is the same that MSC supports (IP or MIXED IP/TDM transport)"
			if { $::glAoip } {
				Trace "log" $::__trace_AUoIP $nameProc "upBssSide = $upBssSide"
			}	
			if {$upBssSide == "MIXED" } {
				log "bss side supports MIXED transport"
			} elseif { $upBssSide == "IP" } {
				log "bss side supports IP transport"
			} else {
				log "bss side supports TDM transport"
				log "RcvAssignmentReq: upCnSide=$upCnSide; upBssSide=$upBssSide"
			}
		} else {
			log "RcvAssignmentReq: WARNING: BSS supports different userplane that one supported by the MSC !"
			#set cause 44; # "Requested Codec Type or Codec Configuration not supported" (01000100): to see Alcatel document '0163_SFD_AUPoIP_02p1'
			set cause 36; # "Requested A-Interface Type unavailable" (00110110): to see Alcatel document '0163_SFD_AUPoIP_02p1'
			SendAssignmentFail $bscid $cause
			return
		}
	} else {
		log "RcvAssignmentReq: 'MSC Preferred Codec List' field doesn't exist --> TDM transport is preferred by the MSC"
	}

	# Channel Type
	set ch_type [rd _sig ch_type]
	set cell_info [GetChannelTypeInfo $ch_type]
	DbSet $glBssapDb $glMsId Spi [set spi [lindex $cell_info 0]]
	DbSet $glBssapDb $glMsId ChannelRate [set ch_rate [lindex $cell_info 1]]
	DbSet $glBssapDb $glMsId PermSpeech [set perm_speech [lindex $cell_info 2]]
	DbSet $glBssapDb $glMsId DataRate [set datarate [lindex $cell_info 3]]
	GetPoolListByChannel ch_pool_list cause 0
	if { [info exist cause] } {
		SendAssignmentFail $bscid $cause
		return
	}

	# Circuit Identity Code
	set circ_idty_code [rd _sig circ_idty_code]

	if { ![IsVoid $circ_idty_code] 
	  && [string match "0" [DbGet $glBscDb $bscid AllocCics]] } {

		set cic [htous $circ_idty_code B]

		log "RcvAssignmentReq: cic=$cic"

		switch -glob -- [cicUse $bscid $cic] {
			"0" {
				# Get Key of current cic
				set cickey [cicUid $bscid $cic]
				log "RcvAssignmentReq: cickey=$cickey"
				if { [string match "-1" $cickey] } {
					# Invalid Cic Key (-1)
					set cause 22; # "Requested terrestrial resource unavailable"
					log "Cause: Invalid Cic Key --> Requested terrestrial resource unavailable"
					SendAssignmentFail $bscid $cause
					return
				}

				# Get Pool of current cic
				set cic_pool [hocts [uitoh $cickey B] 1]
				if { [string match "-1" [lsearch $ch_pool_list [htouc $cic_pool]]] } {
					set cause 31; # "Circuit pool mismatch"
					log "Cause: Circuit pool mismatch"
					SendAssignmentFail $bscid $cause
					return
				}

				# Set Cic in local db
				set ::gBscId $bscid
				log "RcvAssignmentReq: gBscId=$::gBscId bscid=$bscid"
				#DbSet $glBssapDb $glMsId Cic $cic
				
				set cic_ext [GetExtCic $bscid $cic]
				DbSet $glBssapDb $glMsId CicExt $cic_ext

				SendAssignmentCmplt $bscid $spi $ch_rate "?" $cic_pool
			}
			"-[34]" {
				# Invalid Cic (-3) / Resource not created (-4)
				set cause 22; # "Requested terrestrial resource unavailable"
				log "cause: Invalid Cic / Resource not created --> Requested terrestrial resource unavailable"
				SendAssignmentFail $bscid $cause
			}
			"-5" {
				# Resource is busy (-5)
				set cause 50; # "Terrestrial circuit already allocated"
				log "Cause: Resource is busy"
				SendAssignmentFail $bscid $cause
			}
			"-6" {
				# Resource is blocked (-6)
				set cause 22; # "Requested terrestrial resource unavailable"
				log "cause: Resource is blocked --> Requested terrestrial resource unavailable"
				SendAssignmentFail $bscid $cause
				SendBlk $cic $cause 0
			}
			default { exit "Resource Assignment procedure failed" }
		}

	} else {

		if { ![string match 0 [DbGet $glBscDb $bscid AllocCics]] } {
			GetTrfCic $bscid $ch_type cic fail cicExt
			if { [info exists fail] } {
				logscr "Resource Assignment procedure failed ([GetCause $protName $fail])"
				return
			} else {
				#DbSet $glBssapDb $glMsId Cic $cic
				set cic_ext [GetExtCic $bscid $cic]	
				DbSet $glBssapDb $glMsId CicExt $cic_ext
				set circ_idty_code [ustoh $cic B]
			}
		}

		SendAssignmentCmplt $bscid $spi $ch_rate $circ_idty_code "?"
	} 
}

proc SendAssignmentCmplt { bscid spi ch_rate circ_idty_code cic_pool } {

	global _sig glBssapDb glMsId

	set rr_cause 00; # "Normal event"

	new ASG_CMPLT s
	wr s rr_cause $rr_cause
	wr s chsn_ch [GetChosenChannel $spi $ch_rate]
	wr s circ_idty_code $circ_idty_code

	# Cell Identifier
	set lac [DbGet $glBssapDb $glMsId LAC]
	set ci [DbGet $glBssapDb $glMsId CellId]
	set	cell_ident [GetCellIdentifier $lac $ci $glMsId]
	wr s cell_idfr		$cell_ident

	wr s chsn_encr_algo [DbGet $glBssapDb $glMsId Encryption]
	
	wr s spch_ver		01; #GSM speech full rate version 1

	if { [GetPools $bscid] > 1 } {
		wr s circ_pool $cic_pool
	}

	global glAoip __aoip_address
	if { $glAoip } {
		set checkCodecList [CheckCodecList]
		log "SendAssignmentCmplt: checkCodecList=$checkCodecList"
		if { $checkCodecList } {
			log "SendAssignmentCmplt: codec_list=[rd _sig codec_list]"
			#Carlo new dinamic management of the AUoIP -start-
			if { ![IsEmpty [rd _sig codec_list]] && ![IsVoid [rd _sig codec_list]] } {
				#caso in cui MscPcl è di tipo IP or MIXED
				#-----------------
				set vers [lindex [split $::__aoip_rtp_conn(0) " "] 5]	
				log "SendAssignmentCmplt: vers=$vers"; #cDEBUG
				switch -exact -- $vers {
					"GSM_FR"		{set spch_ver f0}
					"GSM_HR"		{set spch_ver f1}
					"GSM_EFR"		{set spch_ver f2}
					"AMR_FR_122"	{set spch_ver f3}
					"AMR_HR_590"	{set spch_ver f4}
					"AMR_WB"		{set spch_ver f9}
					default 		{logscr "Unexpected codec = $vers"; exit}	
				}
				append spch_ver 66
				log "SendAssignmentCmplt: spch_ver=$spch_ver"; #cDEBUG
				#-----------------
				DbSet $glBssapDb $glMsId SpeechVer $spch_ver
			
				set aoipBssScl [DbGet $::glMsDb $glMsId AoipBssScl]
				set aoipMscPcl [DbGet $glBssapDb $glMsId AoipMscPcl]
				
				set upBss [FirstCodecBssSclIncludedInMscPcl $aoipBssScl $aoipMscPcl firstCodec codecType]

				####tobe delete
				####set firstCodec [GetFirstSpeechCodecFromCodecList $aoipBssScl]
				
				# store the codec (the codec type is the second nibble of the 'speech codec element' IE)
				DbSet $glBssapDb $glMsId SpeechCodec $firstCodec
				DbSet $glBssapDb $glMsId UpType $upBss
				log "SendAssignmentCmplt: aoipBssScl=$aoipBssScl --> firstCodec=$firstCodec; upBss=$upBss; codecType=$codecType"
				
				# speech_codec contains the first codec of the BssScl (so from this IE it is possible to obtain the codec type)
				wr 	s 	speech_codec $firstCodec
				
				if { [CodecSelectionByBsc] } {
						#BSC choose the codec and the type of UP
						wr 	s	codec_list $aoipBssScl
						Trace "log" $::__trace_AUoIP SendAssignmentCmplt "feature requests by Alcatel Shanghai: \
									BSC choose the codec and the type of UP \
									bss_codec_list = $aoipBssScl"
				}

				set aupoip_container [rd _sig aoip_tla]
				set ip_add [GetIpAddressFromContainer $aupoip_container]
				set port [GetUdpPortFromContainer $aupoip_container]
				set loc_port [GetAUPoIPPort]
				DbSet $glBssapDb $glMsId DestIp $ip_add
				DbSet $glBssapDb $glMsId DestPort $port
				DbSet $glBssapDb $glMsId LocalIp $__aoip_address
				DbSet $glBssapDb $glMsId LocalPort $loc_port
				#DbSet $glBssapDb $glMsId IpAddPort $__aoip_address-$loc_port 
				if { ![DbKeyExists $glBssapDb IpAddPort $__aoip_address-$loc_port] } {
					DbSet $glBssapDb $glMsId IpAddPort $__aoip_address-$loc_port
				} else {
					log "SendAssignmentCmplt: ERROR: IpAddPort=$__aoip_address-$loc_port already exists in the $glBssapDb for the MsId=[DbGetIdx $glBssapDb IpAddPort $__aoip_address-$loc_port]"
					#LogDbRecordsFromFieldValue $glBssapDb IpAddPort $__aoip_address-$loc_port
				}

				log "SendAssignmentCmplt:ipAdd_local=$__aoip_address; port_local=$loc_port; IpAddPort=[DbGet $glBssapDb $glMsId IpAddPort]"
				log "ipAdd_Peer=$ip_add; port_Peer=$port"

				wr	s 	aoip_tla [GetAUPoIPContainer \
									$__aoip_address $loc_port]

				if { [IpUpSupported] } {
					ActivateAoipResources \
						[DbGet $glBssapDb $glMsId LocalIp] \
						[DbGet $glBssapDb $glMsId LocalPort] \
						 $ip_add $port
					nextstate WaitRtpOpenAck
				} else {
					log "SendAssignmentCmplt: Pure Signalling Mode Over IP"

					#Carlo 09/05/2011 workaround senza UP con MSC che sceglie  -start-
					LogOutputMsg $s
					set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
					SendSccpNDataReq $spcstkidcid $s

					# sending RR_SYNC_IND (res: 1 = Resource Assignment)
					set res 1
					SendRrSyncInd $res "?"
					nextstate BssapConnectActive
					return
					# -end-
				}

				LogOutputMsg $s
				set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
				SendSccpNDataReq $spcstkidcid $s
				return
			} else {
				log "SendAssignmentCmplt: WARNING: MSC prefers TDM while BSC would IP for the mobile $glMsId"
			}
		}
	}
	LogOutputMsg $s
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s

	# sending RR_SYNC_IND (res: 1 = Resource Assignment)
	set res 1
	SendRrSyncInd $res "?"
}

proc RcvStartAck { } {

	# sending RR_SYNC_IND (res: 1 = Resource Assignment)
	set res 1
	SendRrSyncInd $res "?"

	nextstate BssapConnectActive
}

proc RecvRtpOpenAck { } {

	if { [info exists ::__aoip_rtp_ssrc] && $::__aoip_rtp_ssrc != 0 } {
		SyncronizationSourceSetting
	}

	if { [ConfigureAoipResources] == 0 } {
		log "RecvRtpOpenAck: case of ConfigureAoipResources = 0"; #cDEBUG
		RcvStartAck
	}
}

#Carlo gestione caso di mobile terminating dove qs ultimo effettua una reverse redirect
proc RcvRabOpenAck { } {

	if { [info exists ::__aoip_redir_voice] && $::__aoip_redir_voice == 1 \
			&& [IsVoid [DbGet $::glMsDb $::glMsId CalledMsNum]] } {

		# sending RR_SYNC_IND (res: 1 = Resource Assignment)
		set res 1
		SendRrSyncInd $res "?"
		nextstate BssapConnectActive
	} else {
		LogInputSig
	}
}

proc RecvRtpOpenNak { } {

	LogInputSig
	
	if { [rd ::_sig Res] == -16 } {
		log "RecvRtpOpenNak: ERROR in the Bind: (Address already in use)"
		log "RecvRtpOpenNak: Inst=[rd ::_sig Inst]; RtpId=[rd ::_sig RtpId]; LocalAdd=[rd ::_sig LocalAdd]; LocalPort=[rd ::_sig LocalPort]"
	} elseif { [rd ::_sig Res] == -15 } {
		log "RecvRtpOpenNak: ERROR in the Socket Open"
		log "RecvRtpOpenNak: Inst=[rd ::_sig Inst]; RtpId=[rd ::_sig RtpId]; LocalAdd=[rd ::_sig LocalAdd]; LocalPort=[rd ::_sig LocalPort]"
	} else {
		exit
	}
}


proc SendAssignmentFail { bscid cause } {

	# Global Variables
	global _sig glBssapDb glMsId

	new ASG_FAIL s
	wr s cause $cause
	if { [GetPools $bscid] > 1 } {
		# TODO set pool ???
		set pool "?"
		wr s circ_pool $pool
	}

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

# In "Assignment Complete" and "Assignment Failure" msg 
# the IE "Circuit pool" shall be included when several circuit pools
# are present on the BSC-MSC interface
proc GetPools { bscid } {

	# Global Variables
	global glTrfDb

	foreach trlinkid [DbGetIndexList $glTrfDb($bscid)] {
		lappend pool_list [DbGet $glTrfDb($bscid) $trlinkid PoolType]
	}

	return [llength [lsort -unique $pool_list]]
}

#------------------------------------------------------------#
# 3.1.2 "Blocking and Unblocking" procedure functions
#------------------------------------------------------------#
proc SendBlk { cic cause tmrneeded } {

	# Global Variables
	global _sig glBscDb

	new BLK s
	wr 	s circ_idty_code $cic
	wr 	s cause $cause

	LogOutputMsg $s
	SendSccpNUnitdataReq $s

	if { $tmrneeded } {
		# Start timer (time to receipt of BLKG_ACK)
		set tid [DbGet $glBscDb $bscid T_1id]
		if { [tmrtout $tid] != 0 } {
			tmrstart $tid
		}
	}
}

proc RcvBlkAck { } {

	# Global Variables
	global _sig glBscDb glBssapDb glInstNull

	LogInputMsg $_sig

	# Stop T_1 timer
	set spc [DbGet $glBssapDb $glInstNull Spc]
	set bscid [DbGetIdx $glBscDb Opc $spc]
	tmrstop [DbGet $glBscDb $bscid T_1id]
}

proc RcvCircGroupBlkAck { } {

	# Global Variables
	global _sig 

	LogInputMsg $_sig
}

proc T_1Expired { } {

	# Global Variables
	global _sig _src glBscDb

	LogInputMsg $_sig

	# TODO Repeat "Block" procedure
}

#------------------------------------------------------------#
# 3.1.3 "Resource Indication" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.4 "Reset" procedure functions
#------------------------------------------------------------#
proc T_13Expired { } {

	# Global Variables
	global _sig _src glBscDb

	LogInputMsg $_sig

	set bscid [DbGetIdx $glBscDb T_13id $_src]

	# Reset All Bsc instances
	BssapAllInstReset

	SendReset $bscid
}

proc SendReset { bscid } {

	global _sig glBscDb glBssapDb glMsId

	set spc [DbGet $glBscDb $bscid Opc]
	set stkid [DbGet $glBscDb $bscid StkId]
	DbSet $glBssapDb $glMsId Spc $spc
	DbSet $glBssapDb $glMsId StkId $stkid
	DbSet $glBssapDb $glMsId Dpc [DbGet $glBscDb $bscid Dpc]

	# Cause
	set cause 07; # "OM intervention"

	SendGlobalReset $cause

	# Start (time to receipt RST_ACK)
	set tid [DbGet $glBscDb $bscid T_4id]
	if { [tmrtout $tid] != 0 } {
		tmrstart $tid
	}

# TODO
# 	Add "Blocking procedure

	nextstate BssapWaitForResetAck
}

proc RcvReset { } {

	global _sig 

	LogInputMsg $_sig

	# Reset All Bsc instances
	BssapAllInstReset

	SendResetAck

	nextstate BssapIdle
}

proc BssapWaitForResetAck_RcvReset { } {

	global _sig 

	LogInputMsg $_sig

	# Reset All Bsc instances
	BssapAllInstReset

	SendResetAck
}

proc T_4Expired { } {

	global _sig _src glBscDb glNumOfAvailReset glNumOfTotReset glUnlimitedResetAttempts

	LogInputMsg $_sig

	set bscid [DbGetIdx $glBscDb T_4id $_src]

	incr glNumOfAvailReset -1
	if { !$glUnlimitedResetAttempts && ($glNumOfAvailReset == 0) } {	
		exit "BSSAP Reset for BSC $bscid : exhausted all $glNumOfTotReset reset attempts"
	} else {
		# Send again a RST
		set cause 07; # "OM intervention"

		SendGlobalReset $cause

		set tid [DbGet $glBscDb $bscid T_4id]
		tmrstart $tid
	}
}

proc RcvResetAck { } {

	global _sig glInstNull glBscDb glBssapDb
	
	LogInputMsg $_sig

	# Stop T_4 timer
	set spc [DbGet $glBssapDb $glInstNull Spc]
	set bscid [DbGetIdx $glBscDb Opc $spc]
	
	if { ![IsVoid $bscid] && ![IsEmpty $bscid] } {
		tmrstop [DbGet $glBscDb $bscid T_4id]
	} else {
		logscr "RcvResetAck: ATTENTION: bscid is void or empty for the spc=$spc"
	}

	SendBssapCtlResetAck

	nextstate BssapIdle
}

proc RcvResetResource { } {

	global _sig
	
	LogInputMsg $_sig

	set resList [GetCallIdListFromSig [rd _sig res_list]]
	set resCause [rd _sig cause]
	log "RcvResetResource: res_list=[rd _sig res_list] --> resList = $resList; resCause=$resCause"

	# Carlo TODO fare rilascio risorse identificate dalla lista del Call Identifiers

	# 3gpp-48008.9.4.0 §3.1.4.3.2 (BSS always return the ACK)
	SendResetResourceAck [rd _sig res_list]
}

proc SendResetResource { cause } {

	SendResetIpResource [rd ::_sig res_list] $cause
}

proc RcvResetResourceAck { } {

	# only for debug

	LogInputMsg $::_sig

	#Carlo TODO
}

proc RecvRstCircIdle { } {
	
	global _sig glBssapDb

	LogInputMsg $_sig

	set cicId [rd _sig circ_idty_code]
	set cause [rd _sig cause]

	#Carlo 29.09.2011 fix bug
	#set cic [ expr {$cicId & 0x000F} ]
	set cic [htous $cicId B]
	log "RecvRstCircIdle: cicId=$cicId --> cic=$cic; cause=$cause"
	
	LogDbField $glBssapDb CicExt; #cDEBUG

	set cicExt [GetExtCic $::gBscId $cic]
	set bscId [GetBscIdByExtCic $cicExt]
	log "RecvRstCircIdle: cicExt=$cicExt; bscId=$bscId"

	# it checks if Call Identifiers are known or not
	set msid [IsCicUsed $cicExt CicExt]
	if { $msid == -1 } {
		# case of circuit unknown (to see 3gpp-48.008.9.4.0 §3.1.4.2.2
		SendUnequippedCirc $cicId
	} else {
		# 13/03/2012 Carlo: rilascio delle risorse associate a questo cic
		cicRelease $bscId $cic
		DbSet $glBssapDb $msid Cic ?
        DbSet $glBssapDb $msid CicExt ?

		SendResetCircAck $cicId
	}
}

proc SendUnequippedCirc { cic } {

	# Carlo: to see 3gpp 48.008-94.0 §3.2.2.31 (Range=$cic, Status=1 : unequipped).
	set status 01

	#Carlo 25/10/2011: fix bug
	#set cic_hex [ustoh $cic B]

	set cic_hex $cic

	set cic_string [htous $cic_hex B]

	log "SendUnequippedCirc: cic=$cic --> cic_string=$cic_string"

	set range [GetNibble $cic_string 0]

    log "SendUnequippedCirc: range=$range; status=$status"
	append range $status
	log "SendUnequippedCirc: circ_idty_code_list=$range"

	#######
	#set circIdCodeList 0201 ; #hardcoded
	#######

	new 	UQPPD_CIRC s
	wr 	s 	circ_idty_code $cic
	wr 	s	circ_idty_code_list $range
	
	LogOutputMsg $s

	SendSccpNUnitdataReq $s
}

#------------------------------------------------------------#
# 3.1.5 "External Handover" procedure functions
#------------------------------------------------------------#
proc RcvBssapHov { } {

	global _sig glBtsDb glBssapDb glMsId
	
	LogInputMsg $_sig
	
	# Cause
	set cause [rd _sig Cause]

	# Target LAC/CellId
	set lac_tgt [rd _sig LAC]
	set ci_tgt [rd _sig CellId]
	# Target Bsc
	set bsc_tgt [GetBscIdByCellIdfr $lac_tgt $ci_tgt glBtsDb]
	if { [string match "-1" $bsc_tgt] } {
		exit "RcvBssapHov: target BSC identity unknown (LAC=$lac_tgt, CellId=$ci_tgt)"
	}
	
	# Current LAC/CellId
	set lac [DbGet $glBssapDb $glMsId LAC]
	set ci [DbGet $glBssapDb $glMsId CellId]
	# Current Bsc
	set bsc [GetBscIdByCellIdfr $lac $ci glBtsDb]
	if { [string match "-1" $bsc] } {
		exit "RcvBssapHov: current BSC identity unknown (LAC=$lac, CellId=$ci)"
	}

	if { $lac_tgt == $lac && $ci_tgt == $ci } {
		logscr "Handover Required on the current cell (lac=$lac; cell_id=$ci)"
	} elseif { $bsc_tgt == $bsc } {
		# Handover Required is internal to the current Bsc
		SendHovPerformed $cause $lac_tgt $ci_tgt
	} else {
		# Handover Required is external to the current Bsc
		SendHovRequired $cause $lac_tgt $ci_tgt
	}
}

# Sent by Serving Bsc
proc SendHovRequired { cause lac ci } {

	# Global Variables
	global _sig glBssapDb glMsId
	
	# Cell Identifier List 
	set cellidfr 01; # Warning: hardcoded disc (01 = LAC + single Cell)
	append cellidfr $lac
	append cellidfr $ci

	# Current Channel Type 1
	set spi [DbGet $glBssapDb $glMsId Spi]
	set ch_rate [DbGet $glBssapDb $glMsId ChannelRate]

	# Speech Version (Used)
	set perm_speech [DbGet $glBssapDb $glMsId PermSpeech]
	if { $perm_speech != "?" } {
		# Warning: we consider used the first "permitted speech"
		set spch_ver [hocts $perm_speech 1]
	}

	new HOV_RQRD s

	wr 	s cause $cause
	wr	s cell_idfr_list $cellidfr
	wr 	s curr_ch_type_1 [GetCurrChType1 $spi $ch_rate]
	wr 	s spch_ver $spch_ver
	global glAoip
	if { $glAoip && [CheckCodecList] } {
		set speech_codec f066
		wr	s speech_codec	$speech_codec
	}

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

# Received by Target Bsc
proc RcvHovRequest { } {

	# Global Variables
	global _sig
	
	LogInputMsg $_sig

	# Cell Identifier Target
	set cell_info [GetCellInfo [rd _sig cell_idfr_tgt]]
	log "RcvHovRequest: cell_info=$cell_info"
	set lac_tgt [lindex $cell_info 0]
	set ci_tgt [lindex $cell_info 1]

	SendHovRequestAck $lac_tgt $ci_tgt
	# (to test Handover Failure)
	#set cause_value c0
	#SendHovFail $cause_value
}

# Sent by Target Bsc
proc SendHovFail { cause_value } {

	# Global Variables
	global _sig glBssapDb glMsId
	
	# Send RR Handover Failure
	new HOV_FAIL s 
	wr s cause $cause_value

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	# Acknowledge from new BSC
	SendSccpNConnectRes $spcstkidcid $s
}

# Sent by Target Bsc
proc SendHovRequestAck { lac_tgt ci_tgt } {

	log "SendHovRequestAck lac_tgt=$lac_tgt ci_tgt=$ci_tgt"

	# Global Variables
	global _sig glBssapDb glHovInfo glSpcStkIdCid glMsId 
	
	# Store Handover Information
	set hov_num [llength [array names glHovInfo]]
	set hov_ref [expr $hov_num % 256]
	set glHovInfo($hov_ref) "$glSpcStkIdCid $lac_tgt $ci_tgt"

	# Send RR Handover Command
	new RR_HO_CMD t 
	wr t cell_desc ffff
	wr t desc_frst_ch_aft_time ffffff
	wr t ho_ref [uctoh $hov_ref]
	wr t pwr_cmd_and_acc_type ff
	#set l3pdu [bssapSigToPdu t]
	set l3pdu [rrSigToPdu t]

	new HOV_REQ_ACK s
	wr 	s l3_info $l3pdu
	global glAoip __aoip_address
	if { $glAoip && [CheckCodecList] } {
		set spch_ver f066
		DbSet $glBssapDb $glMsId SpeechVer $spch_ver

		wr 		s speech_codec $spch_ver

		set aupoip_container [rd _sig aoip_tla]
		set ip_add [GetIpAddressFromContainer $aupoip_container]
		set port [GetUdpPortFromContainer $aupoip_container]
		set loc_port [GetAUPoIPPort]
		DbSet $glBssapDb $glMsId DestIp $ip_add
		DbSet $glBssapDb $glMsId DestPort $port
		DbSet $glBssapDb $glMsId LocalIp $__aoip_address
		DbSet $glBssapDb $glMsId LocalPort $loc_port
		log "SendHovRequestAck: spch_ver = $spch_ver; ip_add = $ip_add; port = $port"

		wr		s aoip_tla [GetAUPoIPContainer \
							$__aoip_address $port]

		if { [IpUpSupported] } {
			ActivateAoipResources \
				[DbGet $glBssapDb $glMsId LocalIp] \
				[DbGet $glBssapDb $glMsId LocalPort] \
				 $ip_add $port
			nextstate WaitRtpOpenAck
		} else {
			log "SendHovRequestAck: UserPlane over IP isn't supported: Pure Signalling Mode"
		}
	}

	LogOutputMsg $s

	# Acknowledge from new BSC
	SendSccpNConnectRes $glSpcStkIdCid $s
}

# Received by Serving Bsc
proc RcvHovCommand { } {

	# Global Variables
	global _sig _sigpdu glBssapDb glMsId
	
	LogInputMsg $_sig

	set l3pdu [rd _sig l3_info]
	if { ![string match "?" $l3pdu] } {
		# decode RR Handover Command
		rrPduToSig l3pdu
		# Set Handover Reference 
		set hov_ref [htouc [rd _sigpdu ho_ref]]
		DbSet $glBssapDb $glMsId HovRef $hov_ref

	} else {
		exit "External Handover procedure failed"
	}

	#SendHovDetect $hov_ref
}

# Sent by Target Bsc
proc SendHovDetect { } {

	# Global Variables
	global _sig glHovInfo glBssapDb glMsId

	new HOV_DET s

	LogOutputMsg $s

	set hov_ref [DbGet $glBssapDb $glMsId HovRef]
	set spcstkidcid [lindex $glHovInfo($hov_ref) 0]
	SendSccpNDataReq $spcstkidcid $s

	SendHovCmplt $hov_ref
}

# Sent by Target Bsc
proc SendHovCmplt { hov_ref } {

	# Global Variables
	global _sig glHovInfo glBssapDb glMsId
	
	# Store SS7 infos of the Bsc target
	set spcstkidcid [lindex $glHovInfo($hov_ref) 0]
	DbSet $glBssapDb $glMsId SpcStkIdCidTarget $spcstkidcid
	# Store Cell Identification infos of the Bsc target
	set lac_tgt [lindex $glHovInfo($hov_ref) 1]
	set ci_tgt [lindex $glHovInfo($hov_ref) 2]
	DbSet $glBssapDb $glMsId LACTarget $lac_tgt
	DbSet $glBssapDb $glMsId CellIdTarget $ci_tgt

	new HOV_CMPLT s

	# Warning: hardcoded RR Cause (00 = "normal event")
	wr s rr_cause 00

	LogOutputMsg $s

	set spcstkidcid [lindex $glHovInfo($hov_ref) 0]
	SendSccpNDataReq $spcstkidcid $s

	nextstate BssapConnectActive
}

#------------------------------------------------------------#
# 3.1.5a "Handover from GSM to another System" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.6 "Internal Intra-Cell Handover" procedure functions
#------------------------------------------------------------#
proc RcvIntHovEnquiry { } {

	global _sig glMsDb

	LogInputMsg $_sig

	set mscCodecListChosen [rd _sig speech_codec]

	if { ![IsVoid $mscCodecListChosen] && [BssSclIncludeMscPcl AoipBssScl $mscCodecListChosen] } {
		set cause 16; # "response to an INTERNAL HANDOVER ENQUIRY message" (00010110) : to see Alcatel document '0163_SFD_AUPoIP_02p1'
		SendIntHovRqd $cause
	} else {
		set cause 17; # "INTERNAL HANDOVER ENQUIRY reject" (00010111) : to see Alcatel document '0163_SFD_AUPoIP_02p1'
		SendHovFail $cause
	}
}

proc SendIntHovRqd { causeValue } {

	global glMsId glMsDb glBssapDb __aoip_address

	# Cell Identifier
	set lac			[DbGet $glBssapDb $glMsId LAC]
	set ci 			[DbGet $glBssapDb $glMsId CellId]
	set cellIdfr	[GetCellIdentifier $lac $ci]

	set port		[DbGet $glBssapDb $glMsId LocalPort]	
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	log "SendIntHovRqd: glMsId=$glMsId; lac=$lac; ci=$ci; __aoip_address=$__aoip_address; local_port=$port; spcstkidcid=$spcstkidcid"

	if { ![IsVoid $port] } {
		set aoipTransportLayerAddress [GetAUPoIPContainer $__aoip_address $port]
	} else {
		log "SendIntHovRqd: WARNING: port=$port --> Send Hov Failure with cause INTERNAL HANDOVER ENQUIRY reject"
		set cause 17; # "INTERNAL HANDOVER ENQUIRY reject" (00010111) : to see Alcatel document '0163_SFD_AUPoIP_02p1'
		SendHovFail $cause
		return
	}

	set codecBssScl [DbGet $glMsDb $glMsId AoipBssScl]

	new INTERNAL_HO_RQD s
		
	wr 	s	cause 		$causeValue
	wr	s 	cell_idfr 	$cellIdfr
	wr 	s 	aoip_tla 	$aoipTransportLayerAddress
	wr	s	codec_list	$codecBssScl

	LogOutputMsg $s
	SendSccpNDataReq $spcstkidcid $s
}

proc RcvIntHovRqdReject { } {

	LogInputMsg $::_sig

	# Carlo TODO management
	log "TODO"
}

proc RcvIntHovCmd { } {

	LogInputMsg $::_sig

	# Carlo TODO management
	log "TODO"
}

#------------------------------------------------------------#
# 3.1.7 "Internal Inter-Cell Handover" procedure functions
#------------------------------------------------------------#
proc SendHovPerformed { cause lac ci } {

	global _sig glBssapDb glMsId
	
	# Store New LAC/CellId
	DbSet $glBssapDb $glMsId LAC $lac
	DbSet $glBssapDb $glMsId CellId $ci

	new HOV_PERFD s

	wr 	s cause $cause
	wr	s cell_idfr [GetCellIdentifier $lac $ci]

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

#------------------------------------------------------------#
# 3.1.8 "Handover Candidate Enquiry" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.9 "Release of Radio Resource and Terrestrial Resource" 
#        procedure functions
#------------------------------------------------------------#
proc SendClrReq { cause } {

	global glBssapDb glMsId

	new CLR_REQ s
	wr s cause $cause
	
	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

proc RcvClrCmd { } {

	# Sending Clear Complete
	SendClrCmplt
}

proc SendClrCmplt { } {

	global glBssapDb glMsId

	new CLR_CMPLT s

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}


#------------------------------------------------------------#
# 3.1.10 "Paging" procedure functions
#------------------------------------------------------------#
proc RcvPaging { } {

	global _sig glMsDb glMsId glBssapDb

	LogInputMsg $_sig

	set imsi [rd _sig imsi]

	if { ![IsVoid $imsi] } {
		set idx [DbGetIdx $glMsDb IMSI $imsi]
		if {[IsEmpty $idx]} {
			set humanImsi [GetImsiFrom24008Format $imsi]
			logscr "Received paging for unknown IMSI $humanImsi"
			return
		}

		# Check if this MS is registered
		if { [IsVoid [DbGet $glBssapDb $idx TMSI]]} {
			log "Paging received for not registered MS"
		}

	} else {
		exit "WARNING: Paging without IMSI"
	}
	# Set Current Instance
	set glMsId $idx

	# Get Tmsi
	set tmsi [rd _sig tmsi]
	if { $tmsi != "?" } {
		set id "f4"
		append id $tmsi
	} else {
		set id $imsi
	}

	# Carlo -begin SS management-
	# *SS-CFNRC* (simulo il No Paging Response)
	LogDb $glMsDb ; #cDEBUG
	log "RcvPaging: glMsId=$glMsId"; #cDEBUG

	if { [DbFieldExists $glMsDb Call_Forwarding] && [DbGet $glMsDb $glMsId Call_Forwarding] == "CFNRC" } {
		log "RcvPaging: [DbGet $glMsDb $glMsId Call_Forwarding] activated on mobile $glMsId"; #cDEBUG
	# @Carlo -end SS management-
	} else {
    	SendPagingResponse $idx $id
	}
}

# simulation paging procedure in BSS environment
proc SendPagingResponse { idx id } {

	global glMsDb 

	new RR_PGING_RSP s 
	wr s cphr_key_seq_num 07; # no key is available
	wr s spare_octet 00
	wr s mobile_station_clsmrk [DbGet $glMsDb $idx ClassMark2]
	wr s mobile_id $id
	set l3pdu [rrSigToPdu s]

	# sending CMPLT_L3_INFO
	SendInitialMsMsg $l3pdu

	nextstate BssapPagingResponse
}

#------------------------------------------------------------#
# 3.1.11 "Trace Invocation" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.12 "Flow Control" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.13 "Classmark Handling" procedure functions
#------------------------------------------------------------#
proc RcvClsmkReq { } {

	global _sig

	LogInputMsg $_sig

	SendClsmkUpd
}

proc SendClsmkUpd { } {

	global _sig glMsDb glBssapDb glMsId

	new CLSMK_UPD s

	wr s clsmk_info_2 [DbGet $glMsDb $glMsId ClassMark2]
	wr s clsmk_info_3 [DbGet $glMsDb $glMsId ClassMark3]

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}


#------------------------------------------------------------#
# 3.1.14 "Cipher Mode Control" procedure functions
#------------------------------------------------------------#
proc RcvCphrModeCmd { } {
	
	global _sig glBssapDb glMsId

	LogInputSig

	# sending RR_SYNC_IND (res: 0 = Ciphering)
	set res 0
	SendRrSyncInd $res "?"

	set chosen_encr_alg [ChooseEncrAlg [string range [rd _sig encr_info] 0 1]]
	DbSet $glBssapDb $glMsId Encryption $chosen_encr_alg

	SendCphrModeCmplt $chosen_encr_alg
}

# encrAlgList is an HEXSTR of 1 byte (first byte of Encryption Information)
# return value is an HEXSTR of 1 byte
proc ChooseEncrAlg {encrAlgList} {
	log "ChooseEncrAlg: encrAlgList=$encrAlgList"

	set NoEncryptionUsed	01
	set GSM_A5_1			02
	set GSM_A5_2			03
	set GSM_A5_3			04
	set GSM_A5_4			05
	set GSM_A5_5			06
	set GSM_A5_6			07
	set GSM_A5_7			08

	set NoEncryptionBit	0x01
	set GSM_A5_1Bit		0x02
	set GSM_A5_2Bit		0x04
	set GSM_A5_3Bit		0x08
	set GSM_A5_4Bit		0x10
	set GSM_A5_5Bit		0x20
	set GSM_A5_6Bit		0x40
	set GSM_A5_7Bit		0x80

	# choose the lowest encryption algorithm
	if {[expr "0x$encrAlgList & $NoEncryptionBit"]} {
		return $NoEncryptionUsed
	} elseif {[expr "0x$encrAlgList & $GSM_A5_1Bit"]} {
		return $GSM_A5_1
	} elseif {[expr "0x$encrAlgList & $GSM_A5_2Bit"]} {
		return $GSM_A5_2
	} elseif {[expr "0x$encrAlgList & $GSM_A5_3Bit"]} {
		return $GSM_A5_3
	} elseif {[expr "0x$encrAlgList & $GSM_A5_4Bit"]} {
		return $GSM_A5_4
	} elseif {[expr "0x$encrAlgList & $GSM_A5_5Bit"]} {
		return $GSM_A5_5
	} elseif {[expr "0x$encrAlgList & $GSM_A5_6Bit"]} {
		return $GSM_A5_6
	} elseif {[expr "0x$encrAlgList & $GSM_A5_7Bit"]} {
		return $GSM_A5_7
	} else {exit "ChooseEncrAlg: unexpected encrAlgList=$encrAlgList"}
}

proc SendCphrModeCmplt { chosen_encr_alg } {
	
	global _sig glBssapDb glMsId

	new CPHR_MODE_CMPLT s
	wr s chsn_encr_algo $chosen_encr_alg

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s

    nextstate BssapConnectActive
}

#------------------------------------------------------------#
# 3.1.15 "General SCCP Abnormal Conditions" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.16 "Initial MS Msg" procedure functions 
#------------------------------------------------------------#
proc SendInitialMsMsg { l3pdu } {

	global _sig _state glBtsDb glBssapDb glMsId glBscDb

	set lac [DbGet $glBssapDb $glMsId LAC]
	log "SendInitialMsMsg: lac=$lac"
	set ci [DbGet $glBssapDb $glMsId CellId]

	new CMPLT_L3_INFO s

	# Cell Identifier
	set 	cell_ident [GetCellIdentifier $lac $ci $glMsId]
	wr      s cell_idfr $cell_ident
	# L3 info
	wr      s l3_info $l3pdu

	LogOutputMsg $s

	# getting LinksetId from Bsc/Bts databases
	set bscid [GetBscIdByCellIdfr $lac $ci glBtsDb]

	if { $bscid == "-1" } {
		exit "SendInitialMsMsg: BSC not found for lac=$lac and ci=$ci"
	}

	set dpc [DbGet $glBssapDb $glMsId Dpc]
	if {[IsVoid $dpc]} {
		log "SendInitialMsMsg: void dpc"; #debug
		DbSet $glBssapDb $glMsId Dpc [DbGet $glBscDb $bscid Dpc]
		log "SendInitialMsMsg: ---> setting dpc=[DbGet $glBssapDb $glMsId Dpc]"
	}

	SendSccpNConnectReq $glBscDb $glMsId $bscid $s
}

#------------------------------------------------------------#
# 3.1.17 "Queueing Indication" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.18 "Data Link Control SAPI not Equal to 0" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.19 "BSSMAP Error Handling" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.20 "Load Indication" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.21 "Voice group call service and voice broadcast service
#         call set-up and resource assignment" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.22 "Voice group call service and voice broadcast service
#         assignment" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.23 "void"
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.24 "Voice group call uplink control" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.25 "PDSS1 flow control" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.26 "Circuit re-selection" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.27 "LSA handling" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.28 "Location Acquisition" procedure functions
#------------------------------------------------------------#
proc RcvPerfLocReq { } {
	
	global _sig 

	LogInputMsg $_sig

	# Send Location Response to MSC
	SendPerfLocRsp

}

# Warning !!! Hardcoded values inside
proc SendPerfLocRsp { } {
	
	global _sig glBssapDb glMsId

	new PERF_LOC_RSP s
	wr s loc_estm 00

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

#------------------------------------------------------------#
# 3.1.29 "Connectionless Information Transfer" procedure functions
#------------------------------------------------------------#
# see "SendSccpNUnitdataReq" and "DecSccpNUnitdataInd"

#------------------------------------------------------------#
# 3.1.30 "Common Id" procedure functions 
#------------------------------------------------------------#
proc SendCommonId { } {

	global _sig glBssapDb glMsDb glMsId

	set 	Imsi [DbGet $glMsDb $glMsId IMSI]

	# sending COMMON_ID
	new 	COMMON_ID s
	wr  s imsi $Imsi

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

proc RcvCommonId { } {

	global _sig glBssapDb glMsDb glMsId

	LogInputMsg $_sig

	# check COMMON_ID
	set Imsi [rd _sig imsi]
	set imsi [DbGet $glMsDb $glMsId IMSI]
	if { $Imsi != $imsi } {
		exit "Error: Unexpected IMSI ($Imsi) in COMMON ID, expected $imsi"
	}
}

##############################################################
# DTAP procedures (see TS 3GPP 08.06 v.8.0.1)
##############################################################

proc SendDirectTransfer { dlci l3pdu } {

	global _sig glBssapDb glMsId

	new DTAP_DATA s
	## Dlci
	wr s Dlci $dlci
	## Data
	wr s Data $l3pdu

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

proc RcvDirectTransfer { } {

	global _sig glMsId

	LogInputPrim $_sig

	set l3pdu [rd _sig Data]
		
	SendRrDataInd $l3pdu
}

##############################################################
# PRMITIVES HANDLING
##############################################################

#------------------------------------------------------------#
# receiving CTL sap signals 
#------------------------------------------------------------#

# BSSAP_CTL_RESET
proc RcvCtlReset { } {

	# Global Variables
	global _sig glBscDb 

	LogInputMsg $_sig

	set bscid [rd _sig BscId]

	# Start reset guard period
	set tid [DbGet $glBscDb $bscid T_13id]
	if { [tmrtout $tid] != 0 } {
		tmrstart $tid
	}
}

#------------------------------------------------------------#
# receiving signals from SCCP adaptation layer 
#------------------------------------------------------------#

# CONNECT_ACK
proc RcvConnectAck { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	set spcstkidcid [rd _sig SpcStkIdCid]
	set spc [GetSpc $spcstkidcid]
	set stkid [GetStkId $spcstkidcid]

	if { ![DbKeyExists $glBssapDb SpcStkIdCid $spcstkidcid] } {
		# Store SpcStkIdCid
		DbSet $glBssapDb $glMsId SpcStkIdCid $spcstkidcid
	} else {
		log "RcvConnectAck: ERROR: spcstkidcid=$spcstkidcid already exists in the glBssapDb\															for the MsId=[DbGetIdx $glBssapDb SpcStkIdCid $spcstkidcid]"
	}

	DbSet $glBssapDb $glMsId Spc $spc
	DbSet $glBssapDb $glMsId StkId $stkid

	nextstate BssapWaitConfirm
}

# CONNECT_ACK
proc RcvConnectAckPgRes { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig
		
	set spcstkidcid [rd _sig SpcStkIdCid]
	set spc [GetSpc $spcstkidcid]
	set stkid [GetStkId $spcstkidcid]

	# Store SpcStkIdCid
	DbSet $glBssapDb $glMsId SpcStkIdCid $spcstkidcid
	DbSet $glBssapDb $glMsId Spc $spc
	DbSet $glBssapDb $glMsId StkId $stkid

	nextstate BssapWaitCnfForPaging
}

# CONNECT_IND
proc RcvConnectIndForHov { } {

	global _sig _state glSpcStkIdCid

	LogInputPrim $_sig
		
	set glSpcStkIdCid [rd _sig SpcStkIdCid]

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	if { $_sig != "?"} {
		eval $_state
	}
}

# CONNECT_CNF
proc RcvConnectCnf { } {

	global _sig _state

	LogInputPrim $_sig

	SendRrEstCnf 

	# Store Pdu in _sig 
	set _sig [rd _sig Pdu]
	if { ![IsVoid $_sig] } {
		eval $_state
	}

	nextstate BssapConnectActive 
}

proc RcvConnectCnfForPaging { } {

	global _sig _state

	LogInputMsg $_sig

	SendRrEstInd 

	# Store Pdu in _sig 
	set _sig [rd _sig Pdu]
	if { $_sig != "?" } {
		eval $_state
	}

	nextstate BssapConnectActive
}

# DISCONNECT_IND
proc RcvDisconnectInd { } {

	global _sig _state glBssapDb glMsId glMsDb

	LogInputPrim $_sig

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	if { $_sig != "?" } {
		eval $_state
	}

	#  only if we are not in External Handover proc
	set target [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
	if { [IsVoid $target]  } {	

		# Send Release Ind to MM
		set cause "Normal Event"
		SendRrRelInd $cause

		set lai [DbGet $glMsDb $glMsId SysInfoLAI]
		
		# Send System Info to MM
		new     RR_SYSINFO_IND s
		wr      s MsId $glMsId
		wr      s LAI $lai
		send    s
		LogOutputMsg $s

		nextstate BssapIdle
	}

	# Remove or change SS7 link for this instance
	BssapMovInst $glMsId
}

# DATA_IND
proc RcvDataInd { } {

	global _sig _state glMsId 

	LogInputMsg $_sig

	# Store Pdu in _sig 
	set _sig [rd _sig Pdu]
	if { $_sig != "?" } {
		eval $_state
	}
}

#------------------------------------------------------------#
# receiving primitives from upper level
#------------------------------------------------------------#

proc RcvCtlResetResources { } {

	LogInputMsg $::_sig

	set cause 07; # 'OM intervention'
	SendResetResource $cause
}

# RR_EST_REQ
proc RcvRrEstReq { } {

	global _sig glBssapDb glMsId
	global glVGCSBSSAPPid
	
	LogInputPrim $_sig

	set est_cause [rd _sig EstCause]
	set l3pdu [rd _sig Pdu]
	# Set Channel Type Infos
	set res [SetChannelType $est_cause]
	log "RcvRrEstReq: est_cause = $est_cause res = $res"
	switch -exact -- $est_cause {
		"Voice Group Call" {
			new VGCS_CALL_BEGIN s
			wr s MsId $glMsId	
			wr s SpcStkIdCid [DbGet $glBssapDb $glMsId SpcStkIdCid]
			send s $glVGCSBSSAPPid
		}
		"Subsequent Talker Uplink Request" {
			new VGCS_SUBTALKER s
			wr s MsId $glMsId
			wr s SpcStkIdCid [DbGet $glBssapDb $glMsId SpcStkIdCid]
			send s $glVGCSBSSAPPid
		}
	}

	if { $res == "-1" } {
		logscr "RR Establishment failed"
	} elseif { $res == "-2" } {
		log "RcvRrEstReq: est_cause = $est_cause"
		#new UL_REQ s
		#new BSSAP_CTL_SEND_ON_VGCS_LINK t
		#wr t SignalToSend $s
		#send t $glVGCSBSSAPPid
		#remcmd $glVGCSBSSAPPid "SendUplinkRequest"
	} else {
		SendInitialMsMsg $l3pdu
	}
}

# RR_DATA_REQ
proc RcvRrDataReq { } {

	global _sig   

	LogInputPrim $_sig

	# Dlci
	set dlci 0

	# retrieving "pdu" from RR_DATA_REQ
	set l3pdu [rd _sig Pdu]

	# sending DTAP_DATA
	SendDirectTransfer $dlci $l3pdu
}

# RR_NEWTMSI_REQ
proc RcvRrNewTmsiReq { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig
	# Set new Tmsi
	DbSet $glBssapDb $glMsId TMSI [rd _sig TMSI]
}

#------------------------------------------------------------#
# sending primitives to upper level
#------------------------------------------------------------#

# BSSAP_CTL_RESET_ACK
proc SendBssapCtlResetAck { } {

	new 	BSSAP_CTL_RESET_ACK r

	send r
	LogOutputMsg $r
}

# RR_EST_CNF
proc SendRrEstCnf { } {

	global glMsId 

	new RR_EST_CNF r
	wr r MsId $glMsId

	send r
	LogOutputMsg $r
}

# RR_EST_IND
proc SendRrEstInd { } {

	global glMsId 

	# Warning: Index is stored in Cid
	new RR_EST_IND r
	wr r MsId $glMsId

	send r
	LogOutputMsg $r
}

# RR_REL_IND
proc SendRrRelInd { cause } {

	# Global Variables
	global glMsId

	new RR_REL_IND r
	wr r MsId $glMsId
	wr r Cause $cause

	send r
	LogOutputMsg $r
}

# RR_DATA_IND
proc SendRrDataInd { l3pdu } {

	global _sig glMsId
	
	new  RR_DATA_IND r 
	wr r MsId $glMsId
	wr r Pdu $l3pdu

	send r
	LogOutputPrim $r
}

# RR_SYNC_IND
proc SendRrSyncInd { res cause } {

	global _sig glMsId

	new RR_SYNC_IND r
	wr r MsId $glMsId
	wr r Res $res
	wr r Cause $cause

	send r
	LogOutputMsg $r
}

proc RcvRrJoicGcReq { } {
	global _sig _mmpid glRrGcReqMsId glRrGcReqGrCallRef
	global glBssapDb glMsId glVGCSBSSAPPid glMSVgcsDb
	
	set glRrGcReqMsId [rd _sig MsId]
	set glRrGcReqGrCallRef [rd _sig GroupCallRef]
	set grCallRef [rd _sig GroupCallRef]

	new VGCS_JOIN_REQ s
	wr s MsId $glMsId
	wr s SpcStkIdCid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	wr s GroupCallRef $grCallRef
	send s $glVGCSBSSAPPid

	#new UL_RELSE_IND s
	#wr s cause 0e
	#new BSSAP_CTL_SEND_ON_VGCS_LINK t
	#wr t GroupCallReference $glRrGcReqGrCallRef
	#wr t SignalToSend $s

	#send t $glVGCSBSSAPPid

	#remcmd $glVGCSBSSAPPid [list SendOnVGCSDedicatedLink $s]

	nextstate WaitForDedicatedClearCommand
}

proc RcvRrAbortReq { } {
	
	global glMsId _sig glBssapDb

	set msId [rd _sig MsId]

	logscr "Received RR_ABORT_REQ for msId = $msId glMsId = $glMsId"

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	if { ![IsVoid $spcstkidcid] } {
		SendClrReq 01 
	} else {
		log "RcvRrAbortReq: (spcstkidcid is void) --> it skips the sending of the 'CLR_REQ' message"
	}
}

proc RecvClearCommand { } {
	
	LogInputPrim $::_sig
	RcvClrCmd
	nextstate WaitForDisconnectInd
}

proc RecvDiscInd { } {
	
	nextstate BssapIdle
}

proc RecvDedClearCommand { } {
	
	global glRrGcReqGrCallRef glRrGcReqMsId
	
	new RR_JOIN_GC_CNF s
	wr s MsId $glRrGcReqMsId
	wr s GroupCallRef $glRrGcReqGrCallRef
	wr s Mode "group_receive"
	send s
	#Manage clear command as usual
	RcvClrCmd
	nextstate WaitForDedicatedDisconnectInd
}

proc RecvDediDiscInd { } {
	
	nextstate BssapIdle
}

proc RcvAsgReqBssapIdle { } {
	
	global glMsId glBssapDb glSpcStkIdCid
	
	DbSet $glBssapDb $glMsId SpcStkIdCid $glSpcStkIdCid
	SendSccpNConnectRes $glSpcStkIdCid ?
	RcvAssignmentReq
	nextstate BssapConnectActive
}

proc RecvJoinGcReqIdle { } {
	
	global glMsId glBssapDb glVGCSBSSAPPid _sig
	
	new RR_JOIN_GC_CNF s
	wr s MsId $glMsId
	send s
	new VGCS_JOIN_REQ t
	wr t MsId $glMsId
	wr t GroupCallRef [rd _sig GroupCallRef]
	send t $glVGCSBSSAPPid
}

proc ClearTMSI { msId } {
	
	DbSet $::glBssapDb $msId TMSI "?"
}

##############################################################
# FSM
##############################################################

state BssapWaitConfig {
	BSSAP_OM_CFG 			BssapConfig      
	default 				Unexpected
}

proc RcvRstCircAck { } {
	global numTs _gstate
	set numTs [expr $numTs - 1]

	if { $numTs == 0 } {
		nextstate $_gstate
	}

}

state WaitingForAllRstCircAck {
	RST_CIRC_ACK			RcvRstCircAck
	default 				Unexpected
}

state BssapIdle {
	CONNECT_ACK 			RcvConnectAck
	CONNECT_IND 			RcvConnectIndForHov
	RR_EST_REQ 				RcvRrEstReq
    PAG         			RcvPaging
	ASG_REQ					RcvAsgReqBssapIdle
	RR_JOIN_GC_REQ			RecvJoinGcReqIdle
	RST_CIRC				RecvRstCircIdle
	RR_ABORT_REQ			RcvRrAbortReq
	RR_DATA_REQ				LogInputSig
	default 				Any
}
#RR_ABORT_REQ			RcvRrAbortReq aggiunto nello stato sopra Carlo 28/11/2011
#RR_DATA_REQ			LogInputSig aggiunto nello stato sopra Carlo 13/03/2012

state BssapWaitForResetAck {
	RST_ACK 				RcvResetAck
	T_4						T_4Expired
   	RST 					BssapWaitForResetAck_RcvReset
	default					Unexpected
}

state BssapPagingResponse {
	CONNECT_ACK 			RcvConnectAckPgRes
	default					Any
}

state BssapWaitConfirm {
	CONNECT_CNF				RcvConnectCnf
	DTAP_DATA 				RcvDirectTransfer
	default 				Any
}

state BssapWaitCnfForPaging {
	CONNECT_CNF				RcvConnectCnfForPaging
	default 				Any
}

state BssapConnectActive {
	DTAP_DATA 				RcvDirectTransfer
	CPHR_MODE_CMD 			RcvCphrModeCmd
	COMMON_ID				RcvCommonId
	CLR_CMD					RcvClrCmd
	DISCONNECT_IND 			RcvDisconnectInd
	ASG_REQ 				RcvAssignmentReq
	PERF_LOC_REQ			RcvPerfLocReq
	RR_DATA_REQ 			RcvRrDataReq
	RR_NEWTMSI_REQ			RcvRrNewTmsiReq
	RR_JOIN_GC_REQ			RcvRrJoicGcReq
	RR_ABORT_REQ			RcvRrAbortReq
	RR_SYNC_REQ				LogInputSig
	default 				Any
}

state WaitForClearCommand {
	CLR_CMD					RecvClearCommand
	default { Unexpected }
}

state WaitForDisconnectInd {
	DISCONNECT_IND 			RecvDiscInd
	default { Unexpected }
}
state WaitForDedicatedClearCommand {
	CLR_CMD					RecvDedClearCommand
	default { Unexpected }
}

state WaitForDedicatedDisconnectInd {
	DISCONNECT_IND 			RecvDediDiscInd
	default { Unexpected }
}

state WaitRtpOpenAck {
	RTP_OPEN_ACK			RecvRtpOpenAck
	RAB_OPEN_ACK            RcvRabOpenAck
	PLAY_OPEN_ACK           LogInputSig
	START_ACK               RcvStartAck
	RTP_OPEN_NAK            RecvRtpOpenNak
	RAB_OPEN_NAK            { LogInputSig ; exit }
	PLAY_OPEN_NAK           { LogInputSig ; exit }
	START_NAK               { LogInputSig ; exit }
	PERF_LOC_REQ			RcvPerfLocReq
	CLR_CMD					RecvClearCommand
	RR_ABORT_REQ			RcvRrAbortReq
	default 				Any
}

state Any {
	BSSAP_CTL_RESET 			RcvCtlReset
	T_13						T_13Expired
	BSSAP_HOV_REQUIRED 			RcvBssapHov
	BSSAP_HOV_DETECT 			SendHovDetect
   	RST 						RcvReset
	BLKG_ACK					RcvBlkAck
	T_1							T_1Expired
	CIRC_GROUP_BLKG_ACK     	RcvCircGroupBlkAck
	CLSMK_REQ					RcvClsmkReq
	HOV_REQ						RcvHovRequest
	HOV_CMD						RcvHovCommand
	TERMINATE_ACK           	LogInputSig
	PLAY_CLOSE_ACK          	LogInputSig
	RAB_CLOSE_ACK          		RcvRabCloseAck 
	RTP_CLOSE_ACK          		RcvRtpCloseAck
	RTP_CLOSE_NAK          		LogInputSig 
	RAB_CLOSE_NAK           	LogInputSig
	RESET_RESOURCE          	RcvResetResource
	INTERNAL_HO_ENQ				RcvIntHovEnquiry
	INTERNAL_HO_RQD_REJ			RcvIntHovRqdReject
	INTERNAL_HO_CMD				RcvIntHovCmd
	BSSAP_CTL_RESET_RESOURCES   RcvCtlResetResources
	RESET_RESOURCE_ACK			RcvResetResourceAck
	default 					Unexpected
}

#EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE#
