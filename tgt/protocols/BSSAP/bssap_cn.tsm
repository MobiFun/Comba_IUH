##############################################################
# $URL: http://memo.prisma/svn/tm/scriptProt/BSSAP_COMBA/tags/BSSAP_COMBA-1.2.0/scripts/bssap_cn.tsm $
#
# $Author: roger $
#
# Description: BSSAP layer on CN side
#
# $Rev: 53313 $
#
# $Date: 2012-07-19 15:19:13 +0200 (Thu, 19 Jul 2012) $
##############################################################

##############################################################
# INIT
##############################################################


proc Init { args } {
	global __tm_top __pag_attempts
	global protName _HandleRxSignalProc _self __dtap_embed
	global glBscDb glBssapDb glMsDb glMsDbOffset glAoip
	global glVGCSBSSAPPid glPagAttempts glClrCmplteTimerDuration
	global __enable_abnormals
	global glBssapPlmn __bssap_plmn

	# Includes
	include "common/utils/generalUtils.tsm"
	include "common/utils/Ss7SaalUtils.tsm"
	include "common/utils/L3Utils.tsm"
	include "protocols/BSSAP/bssap_common.tsm"
	include "protocols/BSSAP/bssap_utils.tsm"
	include "protocols/BSSAP/bssap_multi_inst.tsm"
	include "protocols/BSSAP/bssaple_cn.tsm"
	include "ctl/userplane.tsm"

	# SVN Revision Checking #
    set url "\$URL: http://memo.prisma/svn/tm/scriptProt/BSSAP_COMBA/tags/BSSAP_COMBA-1.2.0/scripts/bssap_cn.tsm $"
    set rev "\$Rev: 53313 $"
    logv1 "[GetName $url]: version [Version "script" $url $rev]"

	# evaluate configuration
	set cfgFile [lindex $args 0]
	uplevel #0 include $cfgFile

	# protocol name 
	if { ![isSplitted] } {
		set protName BSSAP
	} else {
		if { [ismaster] } {
			set protName BSSAPMASTER
		} else {
			set protName BSSAPSLAVE
		}
	}
	if { [info exist __enable_abnormals] && $__enable_abnormals } {
		include "protocols/BSSAP/bssap_abnormals.tsm"
	}

	SetNetside

	register $protName

	# Create Ms Db
	set glMsDb [lindex $args 1]
	set sortedDbList [lsort -integer -decreasing [DbGetIndexList $glMsDb]]
	set glMsDbOffset [expr {[lindex $sortedDbList 0] + 1}]

	# Calculate the PLMN string
	# RetrievePLMN sets glBssapPlmn
	RetrievePLMN

	if { [info exists __bssap_plmn] } {
		set purePlmn [PurePlmn 2]
	} else {
		set purePlmn [PurePlmn]
	}

	# Compare IMSI of the mobiles with 'old' HPLMN (value of the cfg file)
	if { [ComparePlmnImsi $purePlmn $glMsDb] != -1 } {
		#log "Init: -WARNING- --> the mobiles [lsort -integer [ComparePlmnImsi $purePlmn $glMsDb]] have the IMSI that doesn't belove to the HPLMN=$purePlmn"
	}

	# Bssap Adaptation Layer
	set Al [lindex $args 2]
	include "$Al"

	# Create Internal Ms Database
	set glBssapDb BssapDb
	CreateBssapDb $glBssapDb

	# Create Internal Bsc Database
	set glBscDb BssapBscDb
	CreateBscDb $glBscDb
	
	# Resource Management
	global gTotalCics
	set gTotalCics 0
	
	# Check of the UserPlane type
	set upCheck [CheckMscPcl 1]
	logv1 "A over ip userplane glAoip=$glAoip; upCheck=$upCheck"

	# Compare between MscPcl and TargetMscPcl
	if {$glAoip} {
		set srv_tgt_upCompare [Match_MscPcl_TargetMscPcl]
		logv1 "srv_tgt_upCompare=$srv_tgt_upCompare"	
		if { !$srv_tgt_upCompare } {
			logscr "########"
			logscr "WARNING: TO CHECK THE $glMsDb: the TargetMscPcl includes at least a codec not included in the AoipMscPcl"
			logscr "########"
			# Carlo workaround 04/08/2011: si puÃ² pensare in alternativa di fare una exit
			set upCheck 1; # forzo a MIXED
		}
	}

	global glUpType
	set codecSelectionByBsc [CodecSelectionByBsc]
	logv1 "Init: codecSelectionByBsc=$codecSelectionByBsc"

	##################
	logscr "codecSelectionByBsc=$codecSelectionByBsc; A over ip glAoip=$glAoip; upCheck=$upCheck; UpSupported=[IpUpSupported]"
	if { [IpUpSupported] } { 
		logscr "A over ip with UserPlane ENABLED"
	} else {
		logscr "A over ip with UserPlane DISABLED"
	}
	#################

	if { !$codecSelectionByBsc } {
	# case of codec chosen from MSC
		if { !$glAoip || !$upCheck } {
			set glUpType $upCheck; # 0: TDM
			CreateTrafficRes
			logv1 "******** only TDM ********"
		} elseif { $glAoip && $upCheck == 1 } {
			set glUpType $upCheck; # 1: Mixed IP/TDM
			CreateTrafficRes
			# MultiMgwIP management
			set ::glIpAddIndex 0
			log "glIpAddIndex=$::glIpAddIndex"
			set ::glFirst 1
			logv1 "******** Mixed IP/TDM ********"
		} elseif { $glAoip && $upCheck == 2 } {
			set glUpType $upCheck; # 2: IP
			# MultiMgwIP management
			set ::glIpAddIndex 0
			log "Init: glIpAddIndex=$::glIpAddIndex"
			set ::glFirst 1
			logv1 "******** only IP ********"
		} else {
			logscr "Init: ERROR: the UP must be defined!"
		}
	} else {
		# the codec is chosen from the BSC
		CreateTrafficRes ; # sempre fatta anche nel caso IP perche il BSC puo in seguito chiedere up di tipo tdm
		if { !$glAoip || $upCheck == 0 } {
			set glUpType $upCheck; # 0: TDM
			logv1 "******** only TDM ******** --"
		} elseif { $glAoip && $upCheck == 1 } {
			set glUpType $upCheck; # 1: Mixed IP/TDM
			set ::glIpAddIndex 0
			log "glIpAddIndex=$::glIpAddIndex --"
			set ::glFirst 1
			logv1 "******** Mixed IP/TDM ******** --"
		} elseif { $glAoip && $upCheck == 2 } {
			set glUpType $upCheck; # 2: IP
			set ::glIpAddIndex 0
			log "Init: glIpAddIndex=$::glIpAddIndex --"
			set ::glFirst 1
			logv1 "******** only IP ******** --"
		} else {
			logscr "Init: ERROR: the UP must be defined! --"
		}
	}

	# Paging Attempts
	if { [info exists __pag_attempts] } {
		set glPagAttempts $__pag_attempts
	} else {
		set glPagAttempts 3
	}

	# handle multi-instance
	set _HandleRxSignalProc RxSignalProc

	# Create the BSSAP VGCS and store his pid
	if { $__tm_top > 5 } {
		set grCallDbName [lindex $args 3]
		set glVGCSBSSAPPid [spawn "protocols/BSSAP/vgcs_bssap_cn.tsm \
                                  $_self $cfgFile $glBscDb $glBssapDb $grCallDbName"]
	}

	if [GsInterfaceActive] {
		global glBSSAPPLUSPid
		set glBSSAPPLUSPid [spawn "bssap_plus_cn.tsm $cfgFile $glMsDb $_self"]
	}

	# Set the length of the guard timer for the ClearCommand reply
	set glClrCmplteTimerDuration 15000

	# It is set to 1 if the MM is doing a remote command
	global gMMRemote
	set gMMRemote 0

	# Number of times for sending of the RST signal to the BSC (O&M parameter)
	global glNumOfAvailReset glNumOfTotReset

	set glNumOfTotReset 5
	set glNumOfAvailReset $glNumOfTotReset
	logv1 "Init: glNumOfAvailReset=$glNumOfAvailReset"

	if { !$glAoip || !$glUpType } {
		set ::glNumTotRstCircuit 5
		set ::glNumAvailRstCircuit $::glNumTotRstCircuit
		logv1 "Init: -UP TDM- glNumAvailRstCircuit=$::glNumAvailRstCircuit"
	} elseif { $glAoip && $glUpType == 1 } {
		set ::glNumTotRstCircuit 5
		set ::glNumAvailRstCircuit $::glNumTotRstCircuit
		set ::glNumTotRstResource 5
		set ::glNumAvailRstResource $::glNumTotRstResource
		logv1 "Init: -UP Mixed- glNumAvailRstCircuit=$::glNumAvailRstCircuit - glNumAvailRstResource=$::glNumAvailRstResource"
	} elseif { $glAoip && $glUpType == 2 } {
		set ::glNumTotRstResource 5
		set ::glNumAvailRstResource $::glNumTotRstResource
		logv1 "Init: -UP IP- glNumAvailRstResource=$::glNumAvailRstResource"
	}

	# Initialization for Reset TDM Circuit
	global glnumTimeSlot
	set glnumTimeSlot 0

	# Create Instance Null
	global glInstNull
	set glInstNull 0

	if { [MultiMgwTdm] } {
		set ::glBscIdx 0; #initialization
	}
	
	nextstate BssapWaitConfig
}

##############################################################
# Configuration procedure
##############################################################

proc BssapConfig { } {

	global glBssapDb glMsDb glInstNull

	if { [LbInterfaceActive] } {
		set nstate BssapLeIdle
	} else {
		set nstate BssapIdle
	}

	DbCreateDefEntry $glBssapDb $glInstNull
	DbSet $glBssapDb $glInstNull State $nstate 
	DbSet $glBssapDb $glInstNull CurrResetIndex 0
	DbSet $glBssapDb $glInstNull SaveQue [sdlNewSaveQue]

	# Configure Parameters for every DB Index
	set idxlist [DbGetIndexList $glMsDb]
	foreach idx $idxlist {
		CreateNewBssapEntity $nstate $idx
	}

	if [GsInterfaceActive] {
		global gFirstState
		set gFirstState $nstate
		SendBssapPlusConfig

		nextstate WaitForBssapPlusConfig
	} else {
		BssapSetupCompleted
		nextstate $nstate
	}
	if { $::glAoip } {
		# filling the 'UpType' field in case of AoIP enabled
		CheckMscPcl 2
	}
}

proc BssapSetupCompleted { } {
	SendNotifyOk

	logscr ""
	if { [LbInterfaceActive] } {
		logscr "BSSAP-LE BRING-UP COMPLETE"
	} else {
		logscr "BSSAP BRING-UP COMPLETE"
	}
	logscr ""
}

proc SendBssapPlusConfig { } {
	global glBSSAPPLUSPid

	new BSSAPPLUS_OM_CFG s
	send s $glBSSAPPLUSPid
	LogOutputMsg $s

}

proc BssapPlusCfgAck { } {
	global gFirstState

	BssapSetupCompleted	

	nextstate $gFirstState
}

proc CreateNewBssapEntity { initstate idx } {

	global glBssapDb glPagAttempts

	log "CreateNewBssapEntity: idx=$idx"

	DbCreateDefEntry $glBssapDb $idx

	# Set State
	DbSet $glBssapDb $idx State $initstate 

	# Set PagAttempts
	DbSet $glBssapDb $idx PagAttempts $glPagAttempts

	# Timer T_PAG
	set tPagId [tmrnew T_PAG 5000]
	DbSet $glBssapDb $idx T_PAGid $tPagId
	# Timer T_CIPHR
	set tid [tmrnew T_CIPHR 7000]
	DbSet $glBssapDb $idx T_CIPHRid $tid
	DbSet $glBssapDb $idx AbortReqFlag 0
	DbSet $glBssapDb $idx AbortReqFlagGs 0
	DbSet $glBssapDb $idx QueueIdListIndex 0

	# Timer T_RG_TRR2 (min: 0 sec; default: 3.5 sec)
	set tHoReqNotAnsw [tmrnew T_RG_TRR2 3500]
	DbSet $glBssapDb $idx T_RG_TRR2id $tHoReqNotAnsw

	if { $::glAoip } {
		# all the 'CallId' can be Resetted
		DbSet $glBssapDb $idx SendResetIpForCallId 0
		DbSet $glBssapDb $idx SendResetCircuit 0
	}
	
	# useful in particular for the load (Carlo TMA-479)
	DbSet $glBssapDb $idx SaveQue [sdlNewSaveQue]
}

proc RemoveBssapEntity { idx } {

	global glBssapDb 

	# Free Timers
	tmrfree [DbGet $glBssapDb $idx T_PAGid]
	tmrfree [DbGet $glBssapDb $idx T_CIPHRid]
	tmrfree [DbGet $glBssapDb $idx T_RG_TRR2id]

	DbRemEntry $glBssapDb $idx
}

proc SendNotifyOk { } {

	new BSSAP_OM_CFG_ACK s
	send  s
	LogOutputMsg $s
}

proc GetCuttedPermSpeech { hexPerm unavaList } {
	set res ""

	log "GetCuttedPermSpeech hexPerm=$hexPerm unavaList=$unavaList" 
	set hexLen [expr [string length $hexPerm] / 2]
	for {set i 0} {$i < $hexLen} {incr i} {
		if { [lsearch -exact $unavaList $i] == -1 } {
			append res [string range $hexPerm [expr $i * 2] [expr ($i * 2) + 1]]
		}
	}
	log "GetCuttedPermSpeech res=$res"
	return $res
}

##############################################################
# BSSMAP procedures (see TS 3GPP 08.08 v.8.15.0)
##############################################################

#------------------------------------------------------------#
# 3.1.1 "Assignment" procedure functions 
#------------------------------------------------------------#
proc SendAssignmentReq { spi ch_rate perm_speech datarate priority {grCallRef ?} } {

	global protName glBscDb glBtsDb glBssapDb glMsId glMsDb glAoip

	set lac [DbGet $glBssapDb $glMsId LAC]
	set cellid [DbGet $glBssapDb $glMsId CellId]
	set bscid [GetBscIdByCellIdfr $lac $cellid glBtsDb]
	if { $bscid == "-1" } {
		abort "BSC identity unknown (LAC=$lac, CellId=$cellid)"
	}

	# Channel Type
	DbSet $glBssapDb $glMsId Spi $spi
	DbSet $glBssapDb $glMsId ChannelRate $ch_rate
	DbSet $glBssapDb $glMsId PermSpeech $perm_speech
	DbSet $glBssapDb $glMsId DataRate $datarate
	DbSet $glBssapDb $glMsId Priority $priority
	set ch_type [GetChannelType $spi $ch_rate $perm_speech $datarate]

	set permSpeechIndex 0

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]

		if { [CodecSelectionByBsc] } {
			set initMscUpType 	[DbGet $glBssapDb $glMsId InitMscUpType]
			set actualMscUpType	[DbGet $glBssapDb $glMsId UpType]
			if { ![IsVoid $initMscUpType] && $initMscUpType != $actualMscUpType } {
				# restore the initial value of the UserPlane Type (copied from the MsDb)
				DbSet $glBssapDb $glMsId UpType $initMscUpType
			
				log "######################################################################################"
				log "SendAssignmentReq: ATTENTION --> upType=$upType RESTORED in BssapDb for glMsId=$glMsId"
				log "######################################################################################"
			}
		}
	}

	# Circuit Identity Code
	if { [DbGet $glBscDb $bscid AllocCics] == 0 } {
		if { $glAoip && [isSplitted] } {
			# MULTIPROCESS
			SendCommonAsgReq $ch_type $perm_speech $spi $ch_rate $grCallRef $priority $bscid $datarate "SendAssignmentReq"
			nextstate WaitForIpTdmAsgRes_AsgReq
			return
		}

		if { $glAoip } {
			set codecFromBsc [CodecSelectionByBsc]
		}

		if { !$glAoip || $upType == 0 || $upType == 1 } {
			GetTrfCic $bscid cic fail cicExt 1 permSpeechIndex

			if { [info exists fail] } {
				if { !$glAoip || $upType == 0 } {
					logscr "SendAssignmentReq: WARNING: Resource Assignment procedure failed \
									([BssapGetProtocolCause $protName $fail])"
					# BSSAP_AP_SYNC_CNF (cause: -1 = Resource Assignment Failed)
					SendApSyncCnf "-1" e1af
					return
				} elseif { $upType == 1 } {
				# TMA-441
					# AUoIP supporting UP MIXED IP/TDM
					log "===================="
					logscr "SendAssignmentReq: no TDM resources availables --> MSC continues searching IP resource"
					log "===================="
					set circ_idty_code "?"
				} else {
					log "SendAssignmentReq: ERROR: non dovrebbe mai entrare qui"
				}
			} else {
				set cic_ext [GetExtCic $bscid $cic]
				log "SendAssignmentReq: cic_ext=$cic_ext bscid=$bscid cic=$cic"	
				DbSet $glBssapDb $glMsId Cic $cic
				DbSet $glBssapDb $glMsId CicExt $cic_ext
				set circ_idty_code [ustoh $cic B]
				if { [info exist ::__enable_abnormals] && $::__enable_abnormals } {
					set circ_idty_code [GetFuzzyCic $circ_idty_code]
				}
			}
		} else {
			set circ_idty_code "?"
		}
	}

	# DTX Flag
	set dtx_flag [DbGet $glBscDb $bscid DTXflag]
	if { [string match {[01]} $dtx_flag] } {
		set dtx_flag [uctoh $dtx_flag]
	} else {
		set dtx_flag "?"
	}

	# Classmark Information
	set clmark2 [DbGet $glBssapDb $glMsId ClassMark2]

	if { !$glAoip } {
		SendAsgReq $glMsId $perm_speech $permSpeechIndex $spi $ch_rate $datarate $priority $dtx_flag $clmark2 $grCallRef $bscid $circ_idty_code "SendAssignmentReq"
	} else {
		if { [isSplitted] } {
			# MULTIPROCESS: all cases (TDM or MIXED or IP)
			SendCommonAsgReq $ch_type $perm_speech $spi $ch_rate $grCallRef $priority $bscid $datarate "SendAssignmentReq"
			nextstate WaitForIpTdmAsgRes_AsgReq
			return
		} else {
			# SINGLEPROCESS
			if { !$codecFromBsc && $upType == 0 || !$codecFromBsc && $upType == 1 || $codecFromBsc } {
				# UP chosen from MSC (of type TDM or MIXED) or chosen from BSC (all cases)
				SendAsgReq $glMsId $perm_speech $permSpeechIndex $spi $ch_rate $datarate $priority $dtx_flag $clmark2 $grCallRef $bscid $circ_idty_code "SendAssignmentReq"
			} elseif { !$codecFromBsc && $upType == 2 } {
				# UserPlane IP (codec and UP chosen from the MSC)
				SendAsgReq $glMsId $perm_speech $permSpeechIndex $spi $ch_rate $datarate $priority $dtx_flag $clmark2 $grCallRef $bscid ? "SendAssignmentReq"
			}
		}
	}
	nextstate WaitForAssignRes
}

proc SendDediAssignmentReq { spi ch_rate perm_speech datarate priority args } {

	global protName glBscDb glBtsDb glBssapDb glMsId glAoip glMsDb

	set lac [DbGet $glBssapDb $glMsId LAC]
	set cellid [DbGet $glBssapDb $glMsId CellId]
	set bscid [GetBscIdByCellIdfr $lac $cellid glBtsDb]
	if { $bscid == "-1" } {
		abort "BSC identity unknown (LAC=$lac, CellId=$cellid)"
	}

	# Channel Type
	DbSet $glBssapDb $glMsId Spi $spi 
	DbSet $glBssapDb $glMsId ChannelRate $ch_rate 
	DbSet $glBssapDb $glMsId PermSpeech $perm_speech 
	DbSet $glBssapDb $glMsId DataRate $datarate 
	DbSet $glBssapDb $glMsId Priority $priority 

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Circuit Identity Code
	if { !$glAoip || $upType == 0 || $upType == 1 } {
		if { [DbGet $glBscDb $bscid AllocCics] == 0 } {
			set permSpeechIndex 0
			GetTrfCic $bscid cic fail cicExt 1 permSpeechIndex
			if { [info exists fail] } {
				if { !$glAoip || $upType == 0 } {
					logscr "SendDediAssignmentReq: WARNING: Resource Assignment procedure failed \
							([BssapGetProtocolCause $protName $fail])"
					# BSSAP_AP_SYNC_CNF (cause: -1 = Resource Assignment Failed)
					SendApSyncCnf "-1" e1af
					return
				} elseif { $upType == 1 } {
				# TMA-441
					# AUoIP supporting UP MIXED IP/TDM
					log "===================="
					logscr "SendDediAssignmentReq: no TDM resources availables --> MSC continues searching IP resource"
					log "===================="
					set circ_idty_code "?"
				} else {
					log "SendDediAssignmentReq: ERROR : qui non dovrebbe mai entrare"
				}
			} else {
				set cic_ext [GetExtCic $bscid $cic]
				log "SendDediAssignmentReq: cic_ext=$cic_ext bscid=$bscid cic=$bscid"
				DbSet $glBssapDb $glMsId Cic $cic
				DbSet $glBssapDb $glMsId CicExt $cic_ext
				set circ_idty_code [ustoh $cic B]
			}
		} else {
			set circ_idty_code "?"
		}
	} else {
		set circ_idty_code "?"
	}

	# DTX Flag
	set dtx_flag [DbGet $glBscDb $bscid DTXflag]
	if { [string match {[01]} $dtx_flag] } {
		set dtx_flag [uctoh $dtx_flag]
	} else {
		set dtx_flag "?"
	}

	# Classmark Information
	set clmark2 [DbGet $glBssapDb $glMsId ClassMark2]

	SendAsgReq $glMsId $perm_speech $permSpeechIndex $spi $ch_rate $datarate $priority $dtx_flag $clmark2 $grCallRef $bscid $circ_idty_code "SendDediAssignmentReq"

	nextstate WaitForDediConnectAck
}

proc SendAsgReq { msid perm_speech permSpeechIndex spi ch_rate datarate priority dtx_flag clmark2 grCallRef bscid {circ_idty_code ?} callingProc } {

	global glBssapDb glBscDb glAoip

	new ASG_REQ s

	# Correct the channel types accordingly to the removed ones
	#set newPermSpeech [GetCuttedPermSpeech $perm_speech $unAvailableList]
	#wr s ch_type [GetChannelType $spi $ch_rate $perm_speech $datarate]
	log "SendAsgReq: perm_speech=$$perm_speech"
	if { ![IsVoid $permSpeechIndex] && $permSpeechIndex != 0 } {
		set len [string length $perm_speech]
		set chType [string range $perm_speech [expr $permSpeechIndex * 2] end]
	} else {
		set chType $perm_speech
	}
	log "SendAsgReq: chType=$chType"
	wr s ch_type [GetChannelType $spi $ch_rate $chType $datarate]
	wr s prio $priority
	wr s dwl_dtx_flag $dtx_flag
	wr s clsmk_info_2 $clmark2
	if { ![IsVoid $grCallRef] } {
		wr s group_call_ref $grCallRef
		wr s tlkr_flag [GetTalkerFlagPdu]
	}

	if { ![isSplitted] } {
		if { [info exists ::__aoip_ppu_list] } {
			# Multi Ppu handling #
			MultiPpuAssign
		} else {
			log "SendAsgReq: WARNING: the variable __aoip_ppu_list doesn't exist --> Multi Ppu management isn't done"
		}
	}

	if { $glAoip } {
		set upType [DbGet $glBssapDb $msid UpType]
		Trace "log" $::__trace_AUoIP "SendAsgReq" "msid=$msid --> upType = $upType"
	}

	set ::glIpAddIndex [DbGet $glBssapDb $msid PpuId]
	Trace "log" $::__trace_AUoIP "SendAsgReq" "glIpAddIndex=$::glIpAddIndex"
	
	if { !$glAoip || $upType == 0 } {
	# TDM
		if { ![IsVoid $callingProc] && $callingProc == "SendDediAssignmentReq" } {
			AsgReq_IeHandler "SendAsgReq" s $circ_idty_code
		} else {
			# case SendAssignmentReq singleprocessor or multiprocessor all cases
			AsgReq_IeHandler "SendAsgReq" s $circ_idty_code $::glIpAddIndex
		}
	} elseif { $upType == 1 } {
	# MIXED
		# all cases for multiprocessor version
		AsgReq_IeHandler "SendAsgReq" s $circ_idty_code $::glIpAddIndex
	} elseif { $upType == 2 } {
	# IP
		if { ![IsVoid $callingProc] && $callingProc == "SendDediAssignmentReq" } {
			AsgReq_IeHandler "SendAsgReq" s ?
		} else {
			# case SendAssignmentReq singleprocessor or multiprocessor all cases
			AsgReq_IeHandler "SendAsgReq" s ? $::glIpAddIndex
		}
	} else {
		log "SendAsgReq: ERROR!"
	}

	LogOutputMsg $s

	if { ![IsVoid $callingProc] && $callingProc == "SendAssignmentReq" } {
		set spcstkidcid [DbGet $glBssapDb $msid SpcStkIdCid]
		Trace "log" $::__trace_AUoIP "SendAsgReq" "callingProc=$callingProc; spcstkidcid=$spcstkidcid --> SendSccpNDataReq"
		SendSccpNDataReq $spcstkidcid $s
	} elseif { ![IsVoid $callingProc] && $callingProc == "SendDediAssignmentReq" } {
		Trace "log" $::__trace_AUoIP "SendAsgReq" "callingProc=$callingProc --> SendSccpNConnectReq"
		SendSccpNConnectReq $glBscDb $msid $bscid $s
	} elseif { ![IsVoid $callingProc] && $callingProc == "SLAVE_RcvCommonIpTdmResourcesAsgRes_AsgReq" } {
		log "multiprocessor version (msid=$msid)"
		set spcstkidcid [DbGet $glBssapDb $msid SpcStkIdCid]
		Trace "log" $::__trace_AUoIP "SendAsgReq" "spcstkidcid=$spcstkidcid"
		SendSccpNDataReq $spcstkidcid $s
	} else {
		log "SendAsgReq: ERROR."
		if { [IsVoid $callingProc ] } {
	  		log "SendAsgReq: callingProc is void"
		} else {
			log "SendAsgReq: callingProc=$callingProc"
		}
	}
}

proc AsgReq_IeHandler { callingProcName signal circ_idty_code {ipAddIndex ?} {ho_proc 0} } {

	global glBssapDb glMsId glMsDb glAoip

	set name "AsgReq_IeHandler"
	
	upvar $signal s

	if { $glAoip } {
		set vl	4; #//verbosity level
		set logvb "logv"
		append logvb $vl

		if { $callingProcName == "SendHovRequest" } {
			## external HOV ##
		 	set upType [DbGet $glBssapDb $glMsId TargetUpType]
			log "AsgReq_IeHandler: called by External HOV, target UP type is $upType"
		} else {
			set upType [DbGet $glBssapDb $glMsId UpType]
			$logvb "AsgReq_IeHandler: glMsId=$glMsId; upType=$upType"; #cDEBUG
		}
	}

	if { $glAoip && $upType } {
		# IP or MIXED version
		if { ![isSplitted] } {
		# SINGLEPROCESSOR version
			if { ![IsVoid $ipAddIndex]  } {
				UPoIPcnSet aoipMgwAddr port callid $ipAddIndex
			} else {
				UPoIPcnSet aoipMgwAddr port callid
			}
			Trace "log" $::__trace_AUoIP $name "set in $glBssapDb for the MsId=$glMsId the key parameter LocalIp:$aoipMgwAddr, LocalPort:$port"
			DbSet $glBssapDb $glMsId LocalIp $aoipMgwAddr
			DbSet $glBssapDb $glMsId LocalPort $port
			if { $callingProcName == "SendHovRequest" } {
			#TMA-443
				DbSet $glBssapDb $glMsId HoLocalIp $aoipMgwAddr
				DbSet $glBssapDb $glMsId HoLocalPort $port
			}
		} else {
		# MULTIPROCESSOR version
			set aoipMgwAddr [DbGet $glBssapDb $glMsId LocalIp]
			set port [DbGet $glBssapDb $glMsId LocalPort]
			set callid [DbGet $glBssapDb $glMsId CallId]
			$logvb "$name Multiprocessor version: LocalIp=$aoipMgwAddr; LocalPort=$port; CallId=$callid"
		}

		if {!$ho_proc} {
			if { ![DbKeyExists $glBssapDb IpAddPort $aoipMgwAddr-$port] } {
				DbSet $glBssapDb $glMsId IpAddPort $aoipMgwAddr-$port
			} else {
				if { [DbGetIdx $glBssapDb IpAddPort $aoipMgwAddr-$port] != $glMsId } {
					logv4 "AsgReq_IeHandler: ERROR: IpAddPort=$aoipMgwAddr-$port \																					already exists in the $glBssapDb for the MsId=[DbGetIdx $glBssapDb IpAddPort $aoipMgwAddr-$port]"
				}
				#LogDbRecordsFromFieldValue $glBssapDb IpAddPort $aoipMgwAddr-$port
			}
		
			#23/06/2011: Carlo TODO: attenzione probabilmente occorrera quando fz ok eliminare dal if seguente il fatto che
			# questo if ed il suo elseif vengono eseguiti solo nel caso singleprocessor.

			if { ![DbKeyExists $glBssapDb CallId $callid] && ![isSplitted] } {
				DbSet $glBssapDb $glMsId CallId $callid; # Carlo 21/06/2011: TODO PROBABILMENTE OCCORRE RIVEDERE QS NEL CASO DI INTHOV
			} elseif { ![isSplitted] && [DbKeyExists $glBssapDb CallId $callid] } {
				$logvb "AsgReq_IeHandler: ERROR: CallId=$callid already exists in BssapDb for MsId=[DbGetIdx $glBssapDb CallId $callid]"
				#LogDbRecordsFromFieldValue $glBssapDb CallId $callid
			}
			wr s call_id $callid
		} else {
			set callid [DbGet $glBssapDb $glMsId CallId]
			wr s call_id $callid; # Carlo 21/06/2011: TODO PROBABILMENTE OCCORRE RIVEDERE QS NEL CASO DI INTHOV
		}

		$logvb "AsgReq_IeHandler: glMsId=$glMsId --> callid=$callid"

		if { $upType == 2 || $upType == 1 && ![IsVoid $aoipMgwAddr] && ![IsVoid $port] } {
			$logvb "AsgReq_IeHandler: IP case (upType=$upType)"
			set aoip_TransportLayerAddress [GetAUPoIPContainer $aoipMgwAddr $port]
			wr s aoip_tla $aoip_TransportLayerAddress

			if { $glAoip } {
				$logvb "AsgReq_IeHandler: aoip_tla=$aoip_TransportLayerAddress; glMsId=$glMsId"
			}
		} elseif { $upType == 1 && ![IsVoid $aoipMgwAddr] && ![IsVoid $port] } {
			$logvb "AsgReq_IeHandler: MIXED case (upType=$upType) and management for only ip"

			logscr "TODO evolution in case of singleprocess"
			# 05/10/11 Carlo TODO evolution (in case singleprocess maybe abort in a particular situation because
			# no Cic created when MscPcl is only IP type while on the bss side the BssScl is both TDM and IP type
			# and the __BscChooseCodec is equal to 1).

		} else {
			logv4 "AsgReq_IeHandler: MIXED case (upType=$upType) but management for only tdm .. wait to receive the resource (tla) for IP"
		}

		if {!$ho_proc} {
			if { ![ActiveRandomMscPcl] } {
				wr s codec_list [DbGet $glMsDb $glMsId AoipMscPcl]
			} else {
				# dinamic casual generation of the Preferred Codec List
				wr s codec_list [RandomMscPclGenerator]
			}
		} else {
			wr s codec_list [DbGet $glMsDb $glMsId AoipMscPcl]
		}

		if { $upType == 1 && [CodecSelectionByBsc] } {
			# TMA-422 feature requests by Alcatel Shanghai
			if { ![IsVoid $circ_idty_code] } {
				# TMA-441
				wr s circ_idty_code $circ_idty_code
			}
		}
	} elseif { $glAoip && $upType == 0 && [CodecSelectionByBsc] } {
		Trace "log" $::__trace_AUoIP AsgReq_IeHandler "case up TDM (upType=$upType) && CodecSelectionByBsc=[CodecSelectionByBsc]"
		if {!$ho_proc} {
			# TMA-422: also pure TDM must have 'codec-list' IE included in the ASG_REQ
			if { ![ActiveRandomMscPcl] } {
				wr s codec_list [DbGet $glMsDb $glMsId AoipMscPcl]
			} else {
				# dinamic casual generation of the Preferred Codec List
				wr s codec_list [RandomMscPclGenerator]
			}
		} else {
			if { $callingProcName == "SendHovRequest" } {
				## external HOV ##
				set tgtMscCodec [DbGet $glMsDb $glMsId AoipTargetMscPcl]
				# Carlo store temporarily into 'HoSpeechCodec' field the tgtMscCodec (it will need to set it with the value from the BSC) 
				DbSet $glBssapDb $glMsId HoSpeechCodec $tgtMscCodec
				wr s codec_list $tgtMscCodec
			} else {
				wr s codec_list [DbGet $glMsDb $glMsId AoipMscPcl]
			}
		}

		if { ![IsVoid $circ_idty_code] } {
			# TMA-441
			wr s circ_idty_code $circ_idty_code
		}

	} elseif { !$glAoip || $upType == 0 && ![CodecSelectionByBsc] } {
		wr s circ_idty_code $circ_idty_code
	} else {
		logscr "$callingProcName: ERROR: glAoip=$glAoip; upType=$upType"
	}
}

proc RcvAssignCmplt { } {

	global _sig glAoip glBssapDb glMsId glMsDb

	LogInputMsg $_sig

	set vl 1; #//verbosity level
	set logvb "logv"
	append logvb $vl

	if { $glAoip } {
		if { ![CodecSelectionByBsc] } {
			set upType [DbGet $glBssapDb $glMsId UpType]
		} else {
			# retrieve UP type chosen from the BSC
			set bss_codec_list [rd _sig speech_codec]
			#set bss_codec_list [rd _sig codec_list]; # commented for TMA-438
			set upBssSide [GetUpFromCodec $glMsId 0 $bss_codec_list]
			if { [string equal $upBssSide "MIXED"] } {
				$logvb "RcvAssignCmplt: UP MIXED IP/TDM chosen from the BSC"
				set upBssSide [UP_Discriminator $bss_codec_list 1]
			}
			set upBssType [SetUpNumber $upBssSide]
			$logvb "RcvAssignCmplt: glMsId=$glMsId: upBssSide=$upBssSide --> upBssType=$upBssType"

			# Releases resource that aren't correspondant to the UpType choose from the BSC
			set upMscType [DbGet $glBssapDb $glMsId UpType]
			# Save the initial value of the UserPlane Type (copied from the MsDb)
			DbSet $glBssapDb $glMsId InitMscUpType $upMscType

			$logvb "##########################################################################"
			$logvb "RcvAssignCmplt: ATTENTION --> upType CHANGED in BssapDb for glMsId=$glMsId"
			$logvb "##########################################################################"

			if { $upBssType == 0 } {
				# UP type choose from BSC is TDM --> releases the IP resource (Tla)
				ReleaseTla

				#----- bug fixing Carlo 29/11/2011 -- up mixed; case multiprocess -----#
				DbSet $glBssapDb $glMsId LocalIp ?
				DbSet $glBssapDb $glMsId LocalPort ?
				DbSet $glBssapDb $glMsId CallId ?
				DbSet $glBssapDb $glMsId IpAddPort ?
				$logvb "RcvAssignCmplt: released ip resources about glMsId=$glMsId:"
				$logvb "--> LocalIp=[DbGet $glBssapDb $glMsId LocalIp]"
				$logvb "--> LocalPort=[DbGet $glBssapDb $glMsId LocalPort]"
				$logvb "==> IpAddPort=[DbGet $glBssapDb $glMsId IpAddPort]"
				$logvb "--> CallId=[DbGet $glBssapDb $glMsId CallId]"
				#----- .......................................................... -----#
	
			} elseif { $upBssType == 2 } {
				# UP type choose from the BSC is IP --> releases the TDM resource (Cic)
				LogDb $glBssapDb; #cDEBUG
				ReleaseExtCic $glMsId "CicExt"
				DbSet $glBssapDb $glMsId Cic "?"
				DbSet $glBssapDb $glMsId CicExt "?"
			} else {
				$logvb "ERROR: value not possible (TDM or IP are the only possible types; the MIXED isn't allowed!)"
			}
			# UP type value that arrives from BSC is stored in DB (substituing the value copied the first time from the MsDb)
			DbSet $glBssapDb $glMsId UpType $upBssType
			set upType [DbGet $glBssapDb $glMsId UpType]
		}
	}

	if { $glAoip && $upType } {
		set spch_ver [rd _sig spch_ver]
		set spch_codec [rd _sig speech_codec]
		$logvb "RcvAssignCmplt: spch_ver=$spch_ver; spch_codec=$spch_codec"

		# store in the SpeechVer field the speech version
		DbSet $glBssapDb $glMsId SpeechVer $spch_ver
	
		# store the codec type (it's the second nibble of the 'speech codec element' IE)
		DbSet $glBssapDb $glMsId SpeechCodec $spch_codec
	
		if { [ForceReset "after_assignment_complete" $upType] } {
				return
		}
		set aupoip_container [rd _sig aoip_tla]

		if { $upType == 1 && [IsVoid $aupoip_container] } {
			$logvb "RcvAssignCmplt: in Mixed mode if aoip_tla is void --> TDM Cic selected"
			SendSyncCnf
		} elseif { $upType == 2 && [IsVoid $aupoip_container] } {		
			$logvb "RcvAssignCmplt: ERROR: in IP mode if aoip_tla is void"	
		} else {
			UPoIPcnGet $aupoip_container ip_add port

			DbSet $glBssapDb $glMsId DestIp $ip_add
			DbSet $glBssapDb $glMsId DestPort $port
			$logvb "RcvAssignCmplt: glMsId=$glMsId --> spch_codec_Peer=$spch_codec; ip_add_Peer = $ip_add; port_Peer = $port"

			if { [IpUpSupported] } {
				set localIp 	[DbGet $glBssapDb $glMsId LocalIp]
				set localPort 	[DbGet $glBssapDb $glMsId LocalPort]
				if { [DbKeyExists $glBssapDb IpAddPort $localIp-$localPort] } {
					$logvb "RcvAssignCmplt: idx=[DbGetIdx $glBssapDb IpAddPort $localIp-$localPort] --> IpAddPort_db=[DbGet $glBssapDb $glMsId IpAddPort]"
				} else {
					$logvb "RcvAssignCmplt: ERROR: IpAddPort doesn't exist in the BssapDb"
					DbSet $glBssapDb $glMsId IpAddPort $localIp-$localPort
				}

				ActivateAoipResources $localIp $localPort $ip_add $port
				nextstate WaitRtpOpenAck
			} else {
				$logvb "RcvAssignCmplt: UserPlane over IP isn't supported: just signalling over IP"
				SendSyncCnf
			}

			# Trigger of the 'Internal HO Enquiry' (Alcatel Shanghai requirement)
			if { ![IsVoid [IntHovEnqNeeded]] && [IntHovEnqNeeded] } {
				SendIntHovEnquiry
			}
		}
	} elseif { !$glAoip || $upType == 0 } {
		###added by jiangtao####
		set spch_ver [rd _sig spch_ver]
        set spch_codec [rd _sig speech_codec]
        $logvb "RcvAssignCmplt: spch_ver=$spch_ver; spch_codec=$spch_codec"

        DbSet $glBssapDb $glMsId SpeechVer $spch_ver
        DbSet $glBssapDb $glMsId SpeechCodec $spch_codec
		########################
		SendSyncCnf
		if { ![IsVoid [IntHovEnqNeeded]] && [IntHovEnqNeeded] } {
			SendIntHovEnquiry
		}
	} else {
		logscr "RcvAssignCmplt: ERROR: glAoip=$glAoip; upType=$upType"
	}

	set loc_needed [DbGet $glMsDb $glMsId LocationNeeded]
	if { $loc_needed == 1 } {
		# Trigger Location Acquisition
		SendPerfLocReq
	} elseif { $loc_needed == 3 } {
		SendPerfLocReq_LORE1301
	}
}

proc SendSyncCnf { } {

	# Sending BSSAP_AP_SYNC_CNF (cause: 1 = Resource Assignment)
	set res 1
	SendApSyncCnf $res "?"

	nextstate BssapConnectActive
}

proc RcvAssignFail { } {

	global _sig glAoip glBssapDb glMsId

	LogInputMsgv0 $_sig

	logv4 "RcvAssignFail: cause=[rd _sig cause]; circ_pool=[rd _sig circ_pool]; codec_list=[rd _sig codec_list]"

	# Sending BSSAP_AP_SYNC_CNF (cause: -1 = Resource Assignment Failed)
	set res "-1"
	SendApSyncCnf $res "?"

	if { ![IsVoid [DbGet $::glBssapDb $glMsId PpuId]] && ![IsVoid [DbGet $::glBssapDb $glMsId CallId]] } {
		logv1 "RcvAssignFail: AoIP: releasing active resource"
		ReleaseTla

		#----- bug fixing Carlo 29/11/2011 -- up mixed; case multiprocess -----#
		DbSet $glBssapDb $glMsId LocalIp ?
		DbSet $glBssapDb $glMsId LocalPort ?
		DbSet $glBssapDb $glMsId CallId ?
		DbSet $glBssapDb $glMsId IpAddPort ?
		logv1 "RcvAssignFail: released ip resources about glMsId=$glMsId"
		logv4 "--> LocalIp=[DbGet $glBssapDb $glMsId LocalIp]"
		logv4 "--> LocalPort=[DbGet $glBssapDb $glMsId LocalPort]"
		logv1 "==> IpAddPort=[DbGet $glBssapDb $glMsId IpAddPort]"
		logv1 "--> CallId=[DbGet $glBssapDb $glMsId CallId]"
		#----- .......................................................... -----#

	} else {
		# doesn't exist IP resource for the glMsId
		logv4 "RcvAssignFail: PpuId=[DbGet $::glBssapDb $glMsId PpuId]; CallId=[DbGet $::glBssapDb $glMsId CallId]"
	}

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	if { $glAoip && $upType } {
		#Carlo TODO attenzione occorre vedere se qs si puo fare nel caso multiprocessor
		DbSet $glBssapDb $glMsId LocalIp "?"
		DbSet $glBssapDb $glMsId LocalPort "?"
		DbSet $glBssapDb $glMsId IpAddPort "?"
		DbSet $glBssapDb $glMsId CallId "?"
	} elseif { !$glAoip || $upType == 0 } {
		#set cic [DbGet $glBssapDb $glMsId Cic] 
		set cic_ext [DbGet $glBssapDb $glMsId CicExt]
		set cic [GetCicByExtCic $cic_ext]
	
		if { ![IsVoid $cic] } {
			ReleaseExtCic $glMsId "CicExt"
		}
		# Traffic Resource
		DisconnectResources	$glMsId $glBssapDb
	} else {
		logscr "RcvAssignFail: ERROR: glAoip=$glAoip; upType=$upType"
	}
	
	#Carlo workaround -- 14/09/2011 --
	if { $glAoip && [CodecSelectionByBsc] } {
		set initMscUpType [DbGet $glBssapDb $glMsId InitMscUpType]
		if { ![IsVoid $initMscUpType] } {
			# restore the initial value of the UserPlane Type (copied from the MsDb)
			DbSet $glBssapDb $glMsId UpType $initMscUpType
			
			logv4 "##########################################################################"
			logv4 "RcvAssignFail: ATTENTION --> upType RESTORED in BssapDb for glMsId=$glMsId"
			logv4 "##########################################################################"
		}
	}
	# ----	

	nextstate BssapConnectActive
}

#------------------------------------------------------------#
# 3.1.2 "Blocking and Unblocking" procedure functions
#------------------------------------------------------------#
proc RcvBlk { } {

	global _sig glBssapDb glMsId glAoip glUpType

	LogInputMsgv0 $_sig

	# Get Cic Value
	set cic_hex [rd _sig circ_idty_code]
	set cic [htous $cic_hex B]

	# Block and Respond
	#cicBlock $cic

	set stkId 	[DbGet $glBssapDb $glMsId StkId]
	set dpc 	[DbGet $glBssapDb $glMsId Dpc]

	if { !$glAoip || !$glUpType || $glAoip && $glUpType == 1 } {
		set res [CicBlockExt $cic $dpc]
		#CicBlockExt $cic $stkId

		# debug 13/04/2012: TMA-476 -start-
    	if { [IsVoid $res] || $res == 0 } {
			new 	BLKG_ACK s
			wr 		s circ_idty_code $cic_hex

			LogOutputMsgv0 $s
			SendSccpNUnitdataReq $s
		} else {
			logv4 "RcvBlk: 'BLKG_ACK' won't be sent to BSC because cic=$cic hasn't been blocked (invalid cicBlock with res=$res)"
		}
		# TMA-476 -end-
	} elseif { $glAoip && $glUpType == 2 } {
		logv4 "RcvBlk: WARNING: UserPlane allowed is only IP: eventually to check the values of the parameter 'AoipMscPcl' in the $::glMsDb"
		exit
	} else {
		logv4 "RcvBlk: WARNING: glUpType=$glUpType has a unexpected value (possible values are: 0, 1, 2)"
	}
}

proc RcvUblk { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Get Cic Value
	set cic_hex [rd _sig circ_idty_code]
	set cic [htous $cic_hex B]

	#set res [cicUnblock $cic]
	set stkId [DbGet $glBssapDb $glMsId StkId]
	
	# TMA-405
	set dpc [DbGet $glBssapDb $glMsId Dpc]
	set res [CicUnblockExt $cic $dpc]
	#set res [CicUnblockExt $cic $stkId]
	# -end 405- #

	if { $res >= 0} {
		new UBLKGN_ACK s
		wr s circ_idty_code $cic_hex
	} else {
		logscr "Invalid Unblocking Cic ($res)"
		return
	}

	LogOutputMsg $s
	SendSccpNUnitdataReq $s
}

proc RcvCircGroupBlk { } {

	global _sig glMsId glBssapDb

	LogInputMsg $_sig

	# Get Cic
	set cic [rd _sig circ_idty_code]
	set cic_base [htous $cic B]

	# Get Cic List
	set cic_list [rd _sig circ_idty_code_list]
	#logscr "xDebug: RcvCircGroupBlk cic_list: $cic_list"
	# Get Range: Cics affected are range + 1
	set cic_range [expr {[htouc [string range $cic_list 0 1]] + 1}]
	logscr "xDebug: RcvCircGroupBlk cic_list: $cic_list cic_range:$cic_range"
	# Get Status
	set status [string range $cic_list 2 end]
	set status_byteLen [expr {[string length $status] / 2}]
	#logscr "xDebug: RcvCircGroupBlk: status: $status, status_bytelen: $status_byteLen "
	# Block Cics
	for { set i 0 } { $i < $status_byteLen } { incr i } {
		set h [expr {2 * $i}]
		set oct [string range $status $h [expr {$h +1}]]
		set binoct [htob $oct]
		for { set j 7 } { $j >= 0 } { incr j -1 } {
			set index [string index $binoct $j]
			if { $index && $cic_range } {
				set offset [expr {[expr {7 - $j}] + [expr {$i * 8}]}]
				set cicTarget [expr {$cic_base + $offset}]
				incr cic_range -1

				# CICEXT
				logscr "xDebug: RcvCircGroupBlk cicTarget:$cicTarget"
				set stkid [DbGet $glBssapDb $glMsId StkId]

				#Carlo fix 09/06/2010 about TMA-372 -start- #
				set dpc	[DbGet $glBssapDb $glMsId Dpc]
				logv4 "RcvCircGroupBlk: stkid=$stkid; dpc=$dpc"
				set res [CicBlockExt $cicTarget $dpc]
				#CicBlockExt $cicTarget $stkid
				# -end- #
			}
		}
	}

	# Carlo 26/01/2011 -start-
	if { [IsVoid $res] || $res != 0 } { 
		logscr "RcvCircGroupBlk: WARNING: any Cics have been blocked (invalid cicBlock with res=$res)"
	}; # -end-

	new CIRC_GROUP_BLKG_ACK s
	wr s circ_idty_code $cic
	wr s circ_idty_code_list $cic_list

	LogOutputMsg $s
	SendSccpNUnitdataReq $s
}

proc RcvCircGroupUnblk { } {

	global _sig glMsId glBssapDb

	LogInputMsg $_sig

	# Get Cic
	set cic [rd _sig circ_idty_code]
	set cic_base [htous $cic B]

	# Get Cic List
	set cic_list [rd _sig circ_idty_code_list]

	# Get Range: Cics affected are range + 1
	set cic_range [expr {[htouc [string range $cic_list 0 1]] + 1}]

	# Get Status
	set status [string range $cic_list 2 end]
	set status_byteLen [expr {[string length $status] / 2}]

	# Block Cics
	for { set i 0 } { $i < $status_byteLen } { incr i } {
		set h [expr {2 * $i}]
		set oct [string range $status $h [expr {$h +1}]]
		set binoct [htob $oct]
		for { set j 7 } { $j >= 0 } { incr j -1 } {
			set index [string index $binoct $j]
			if { $index && $cic_range } {
				set offset [expr {[expr {7 - $j}] + [expr {$i * 8}]}]
				set cicTarget [expr {$cic_base + $offset}]
				incr cic_range -1

				# CICEXT
				#set res [cicUnblock $cicTarget] 
				set spc [DbGet $glBssapDb $glMsId StkId]

				# TMA-405
				set dpc	[DbGet $glBssapDb $glMsId Dpc]
				set res [CicUnblockExt $cicTarget $dpc]
				#set res [CicUnblockExt $cicTarget $spc]
				# -end 405- #

				if { $res < 0 && $res != "-4" && $res != "-6" } {
					logscr "RcvCircGroupUnblk: WARNING: invalid cicUnblock (res=$res)" 
					#return
				}
			}
		}
	}

	new CIRC_GROUP_UBLKGN_ACK s
	wr s circ_idty_code $cic
	wr s circ_idty_code_list $cic_list

	LogOutputMsg $s
	SendSccpNUnitdataReq $s
}

#------------------------------------------------------------#
# 3.1.3 "Resource Indication" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.4 "Reset" procedure functions
#------------------------------------------------------------#

proc CompleteReset { retVal } {
	global glInstNull glBssapDb

	log "CompleteReset: retVal=$retVal"
	if { $retVal == -1 } {
		DbSet $glBssapDb $glInstNull CurrResetIndex 0
		SendResetAck
		UnblockAllBscCics

		#// Carlo workaround 01/04/2011
		SendBssapCtlResetAck
		nextstate BssapIdle

	} else {
		if { $::glAoip && [info exists ::__Dbssap_PerGlobalReset] } {
			log "CompleteReset: 'Global Periodic Reset' triggering"
			# PERIODIC GLOBAL RESET
			TriggerPeriodicReset GLOBAL
		} else {
			# Start Timer for reprocessing RST
			DbSet $glBssapDb $glInstNull CurrResetIndex $retVal
			tmrstart [tmrnew T_RST 500]
		}
	}
}

proc RcvReset { } {
	global _sig glInstNull glBssapDb

	LogInputMsg $_sig

	# Start resetting instances
	set startIdx [DbGet $glBssapDb $glInstNull CurrResetIndex]
	log "RcvReset: startIdx=$startIdx"
	if { $startIdx != 0 } {
		# a new RST was received, still processing the old one	
		return
	} else {
		set dpc [DbGet $glBssapDb $glInstNull Dpc]
		if {[IsVoid $dpc]} {
        	log "RcvReset: void dpc"
    	}
		CompleteReset [BssapPartialReset $startIdx]
	}
}

proc RcvTReset { } {

	global _sig _src glInstNull glBssapDb

	LogInputMsg $_sig

	# Free Timer
	if { $_src != 0 } {
		tmrfree $_src
	}

	# Start resetting instances
	set startIdx [DbGet $glBssapDb $glInstNull CurrResetIndex]
	CompleteReset [BssapPartialReset $startIdx]
}

proc RcvResetAck { } {

	global _sig glBscDb
	
	LogInputMsg $_sig

	# Reset TDM Circuit
	set ::glnumTimeSlot 0; # when Global Reset procedure is completed then no Cic are busy (no active calls).

	# Carlo 03/11/2010 2 MGW management -start-
	if { [MultiMgwTdm] } {
		set bsclist [lsort -integer [DbGetIndexList $glBscDb]]
		log "RcvResetAck: bsclist=$bsclist"; #cDEBUG
		if { $::glBscIdx < [llength $bsclist] } {
			# Setting new Bsc Index
            set bscid [lindex $bsclist $::glBscIdx]

			# Check RST ACK Timer ###
			set tResetAckid [DbGet $glBscDb $bscid T_16id]
			if { [tmrrunning $tResetAckid] } {
				tmrstop $tResetAckid
			} else {
				log "RcvResetAck: no Reset Timer running"
			}
			###

            incr ::glBscIdx
			if { $::glBscIdx == [llength $bsclist] } {
				SendBssapCtlResetAck
				nextstate BssapIdle
			} else {
        		log "RcvResetAck: received RST ACK from the BSC $bscid ... waiting to receive all the RST_ACK from all the BSCs"
			}
		} else {
			SendBssapCtlResetAck
			nextstate BssapIdle
		}
	#-end-
    } else {
		SendBssapCtlResetAck
		nextstate BssapIdle
	}
}

proc RcvResetCircuit { } {

	global _sig _state glMsId glBssapDb glTarget
	
	LogInputMsg $_sig

	set cic_hex [rd _sig circ_idty_code]
	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause [rd _sig cause]

	SendResetCircAck $cic_hex

	# Check if Call in progress 
	set cic [htous $cic_hex B]

	set idx [IsCicUsed $cic CicExt]
	set idxTarget [IsCicUsed $cic CicExtTarget]	

	if { $idx != "-1" } {

	#if { [DbKeyExists $glBssapDb Cic $cic] } { 
	
		#set idx [DbGetIdx $glBssapDb Cic $cic]
		# Msg is not from target
		if { [info exists glTarget] } {
			unset glTarget
		}
	#} elseif { [DbKeyExists $glBssapDb CicTarget $cic] } {
	} elseif { $idxTarget != "-1" }
		#set idx [DbGetIdx $glBssapDb CicTarget $cic]
		set glTarget [DbGet $glBssapDb $idx SpcStkIdCidTarget]
	} else {
		log "[lindex $_sig 0] Ignored, No Call Associated to Cic $cic"
		return
	}	
	
	# Re-Get Instance out of Cic
	GetInstance $idx $glBssapDb glMsId

	# Re-Process Signal
	eval $_state
}

proc RcvResetCircuitAck { } {

	global _sig glnumTimeSlot glBssapDb glMsId

	LogInputMsgv0 $_sig

	set vl	4; #//verbosity level
	set logvb "logv"
	append logvb $vl

	if { $glnumTimeSlot >= 1 } {
		# there is at least one time slot busy
		set glnumTimeSlot [expr {$glnumTimeSlot - 1}]
		set cic_released [htous [rd _sig circ_idty_code] B]
		$logvb "RcvResetCircuitAck: cic_released=$cic_released"

		set ms_released [GetMsIdFromCic $cic_released]
		$logvb "RcvResetCircuitAck: mobiles released: ms_released = $ms_released"

		if { ![isSplitted] } {
		# SINGLEPROCESSOR version
			set idx [DbGetIdx $glBssapDb Cic $cic_released]
			log "RcvResetCircuitAck: idx=$idx"
			set bscid [DbGet $glBssapDb $idx BscId]
			log "RcvResetCircuitAck: cic_released=$cic_released <--> Ms:$idx on bscid=$bscid"
			set tid [DbGet $::glBscDb $bscid T_RESET_TDMCIRCUITid]
			if { ![IsVoid $tid] && [tmrrunning $tid] } {
				tmrstop $tid
			} else {
				log "RcvResetCircuitAck: tid=$tid -> NO Periodic Reset timer 'T_RESET_TDMCIRCUIT' activated towards bscid=$bscid"
			}
			# Carlo 17/10/2011 -start- to be tested				
			if { ![IsVoid $cic_released] } {
				log "RcvResetCircuitAck: release cic=$cic_released on the bscid=$bscid for the mobile idx=$idx"
				#cicRelease $bscid $cic_released
				#DbSet $glBssapDb $idx Cic "?"
				#DbSet $glBssapDb $idx CicExt "?"
				
				# Carlo: 17/10/2011  workaround aggiungo il rilascio vero della segnalazione corrispondente
				GetInstance $idx $glBssapDb glMsId
				log "idx=$idx -> glMsId=$glMsId"
				log "RcvResetCircuitAck: state = [DbGet $glBssapDb $idx State]"
				if { [DbGet $glBssapDb $idx State] == "BssapConnectActive" } {
					ReleaseFromResetCircuitAck $idx $cic_released
				} else {
					log "RcvResetCircuitAck: for mobile idx=$idx the State is != 'BssapConnectActive' --> nothing action done"
				}
			} else {
				log "RcvResetCircuitAck: cic void --> nothing action done!"
			}
			# -end-
		} else {
		# MULTIPROCESS version
			if { [IsVoid $ms_released] || [IsEmpty $ms_released] } {
				$logvb "RcvResetCircuitAck: ERROR: ms_released has an unexpected value"
			} else {
				# from this time the received messages 'BSSAP_RESET_TDMCIRCUIT_REQ' will be again managed for this msid
				DbSet $glBssapDb $ms_released SendResetCircuit 0

				# Carlo workaround 12/03/2012 (to be tested in ASB) -start patch-
				# Reset all params for this instance and release the Cic
				BssapResetInst $ms_released

				DbSet $glBssapDb $ms_released Cic ?
				DbSet $glBssapDb $ms_released CicExt ?
				# -end patch-

				$logvb "RcvResetCircuitAck: found ms_released=$ms_released -> put to void both 'Cic','CicExt'; SendResetCircuit=0 in BssapDb"

				# send reply to the slave				
				SendBssapResetTdmCircuitRes $ms_released
			}
		}
	} else {
		$logvb "RcvResetCircuitAck: WARNING: glnumTimeSlot=$glnumTimeSlot --> received Unexpected Reset Circuit Ack"
		nextstate BssapIdle
		return -1
	}
}

proc RcvUnequippedCirc { } {

	LogInputMsg $::_sig

	if { [isSplitted] } {
		# Multiprocess version
		SendUniqueppedCircuit_To_Slave
	} else {
		# Singleprocess version
		log "WARNING: TODO"
		# Carlo TODO
	}
}

proc RcvResetResource { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Stop Timer
	StartStopTimerRstResource 0

	set resList [GetCallIdListFromSig [rd _sig res_list]]
	log "RcvResetResource: resList = $resList"

	ReleaseIP $resList

	SendResetResourceAck [rd _sig res_list]
}

proc RcvResetResourceAck { } {

	global _sig glBssapDb glBscDb glMsId

	LogInputMsg $_sig

	set vl	4; #//verbosity level
	set logvb "logv"
	append logvb $vl

	# Stop Timer
	StartStopTimerRstResource 0

	set resList [GetCallIdListFromSig [rd _sig res_list]]
	$logvb "RcvResetResourceAck: list of the CallId released: resList = $resList"

	set msList [GetMsIdListFromCallIdList $resList]
	$logvb "RcvResetResourceAck: list of the mobiles released: msList = $msList"

	LogDb $glBssapDb; #cDEBUG

	if { ![IsVoid $msList] } {
		if { ![isSplitted] } {
		# Singleprocess version
			foreach msid $msList {
				# it deletes for e.g. the CallId parameter
				ResetIpKeyParameters $msid
				$logvb "RcvResetResourceAck: released IP parameters (including the CallId) for the mobile $msid"
				set callId_Released [DbGet $glBssapDb $msid CallId]
				$logvb "Ms=$msid --> after resetIpKeyParameters --> CallId_Released=$callId_Released"
				if { ![IsVoid $callId_Released] } { $logvb "ERROR: the CallId for ms=$msid hasn't been deleted from the BssapDb" }

				# Carlo: 17/10/2011 rilascio della segnalazione corrispondente
				GetInstance $msid $glBssapDb glMsId
				$logvb "RcvResetResourceAck: state = [DbGet $glBssapDb $msid State]"
				if { [DbGet $glBssapDb $msid State] == "BssapConnectActive" } {
					set cause 60; # protocol error
					RcvClrReqServing $cause
				} else {
					$logvb "RcvResetResourceAck: for msid=$msid the State is != 'BssapConnectActive' --> nothing action done"
				}
			}
		} else {
		# Multiprocess version
			foreach msid $msList {
				# it deletes for e.g. the CallId parameter
				ResetIpKeyParameters $msid
				set callId_Released [DbGet $glBssapDb $msid CallId]
				#log "Ms=$msid --> after ResetIpKeyParameters --> callId_Released=$callId_Released"
				if { ![IsVoid $callId_Released] } { $logvb "ERROR: the CallId for ms=$msid hasn't been deleted from the BssapDb !!" }

				# this mobile returns available to be resetted
				DbSet $glBssapDb $msid SendResetIpForCallId 0
				$logvb "RcvResetResourceAck: msid=$msid -> (DbGet glBssapDb msid SendResetIpForCallId)=[DbGet $glBssapDb $msid SendResetIpForCallId]"
			}

			# Send answer to slave
			SendBssapResetResourceRes $msList
		}
	} else {
		$logvb "RcvResetResourceAck: msList is void --> there aren't mobiles which must release the IP Resources (maybe that these resources have already been released)"
	}

	if { 0 } {
	# if callId received is different from callId sent with the RESET_RESOURCE then it re-send the RESET_RESOURCE
	
	# Carlo TODO occorre inserire un campo nel database dove si memorizza la 'callId_list' quando e' stata inviata la RESET_RESOURCE
	# temporary hardcoded (non effettuo il match tra callId sent e callId received)

		# OCCORRE CALCOLARSI il bscid
		#set bscid .....

	  	# Stop Timer T_RMSC if it's running
		set tid [DbGet $glBscDb $bscid T_RMSCid]
		if { ![IsVoid $tid] && [tmrrunning $tid] } {
			tmrstop $tid
		}
		ResetIpResource
	} else {
		$logvb "RcvResetResourceAck: the callIdList received is equal to callIdList sent with the RESET_RESOURCE"
	}	
}

proc SendReset { bscid { rstTimer ? } } {

	global _sig glBscDb glBssapDb glMsId

	log "SendReset: bscid=$bscid"
	set spc 	[DbGet $glBscDb $bscid Opc]
	set stkId 	[DbGet $glBscDb $bscid StkId]
	log "SendReset: bscid=$bscid; spc=$spc; stkId=$stkId; glMsId=$glMsId"

	DbSet $glBssapDb $glMsId Spc $spc
	DbSet $glBssapDb $glMsId StkId $stkId

	#Carlo MGW in Aflex
	DbSet $glBssapDb $glMsId Dpc [DbGet $glBscDb $bscid Dpc]

	set cause 07; # "OM intervention"

	SendGlobalReset $cause

	# TODO
	# Add "Blocking procedure

	#TMA-337 Carlo patch 25/02/2010
	if { ![IsVoid $rstTimer] } {
		tmrstart [tmrnew T_RST 1000]
	} elseif { $::glAoip && [info exists ::__Dbssap_PerGlobalReset] } {
		# PERIODIC GLOBAL RESET
		log "SendReset: TriggerPeriodicReset for the bscid:$bscid"
		TriggerPeriodicReset GLOBAL $bscid
	} else {
		log "SendReset: Reset Timer not request"; #cDEBUG

		# Carlo 10/12/2010: gestione caso Aflex TDM con 2 MGW e gli MSCs connessi ciascuno ad un unico MGW (Not Cross-Connected)
		# (gestione del problema della RST inviata prima che il link tra MGW e BSC sia up:
		# in questo caso reinvio la RST scaduto un timer di non rx dell RST_ACK).
		# Andrebbe fatto solo nel caso di un solo BSC
		# if { [MultiMgwTdm] && [DbSize $glSs7StkDb] == 1 }
		# invece lo faccio anche nel caso di piu BSC 
		if { [MultiMgwTdm] } {
			# Start (time to receipt RST_ACK)
			set tid [DbGet $glBscDb $bscid T_16id]
			if { [tmrtout $tid] != 0 } {
				tmrstart $tid
			}
		}
	}
	#
	nextstate BssapWaitForResetAck
}

proc T_16Expired { } {

	global _sig _src glBscDb glNumOfAvailReset

	LogInputMsg $_sig

	set bscid [DbGetIdx $glBscDb T_16id $_src]

	incr glNumOfAvailReset -1
	if { !$glNumOfAvailReset } {
		exit "T_16Expired: exhausted all $::glNumOfTotReset reset attempts"
	} else {
		# Send again a RST
		set cause 07; # "OM intervention"

		SendGlobalReset $cause

		set tid [DbGet $glBscDb $bscid T_16id]
		tmrstart $tid
	}
}

proc T_ResetIpResource { } {

	LogInputMsg $::_sig

	set bscid [DbGetIdx $::glBscDb T_RESET_IPRESOURCEid $::_src]

	log "*****************"
	log "T_ResetIpResource: bscid=$bscid --> dpc=[DbGet $::glBscDb $bscid Dpc]"
	log "*****************"

	# check if timer T_RMSC is running
	set tid [DbGet $::glBscDb $bscid T_RMSCid]
	if { ![IsVoid $tid] && [tmrrunning $tid] } {
		#tmrstop $tid; #Carlo commented 29/12/2011 TMA-447
		return; # Carlo added 29/12/2011
	}

	ResetIpResource

	if { [info exists ::__Dbssap_PerIpReset] } {
		# PERIODIC IP RESET case
		TriggerPeriodicReset IPRESOURCE
	}

	nextstate WaitResetResAck
}

proc T_RmscExpired { } {

	LogInputMsg $::_sig

	if { $::glNumAvailRstResource > 0 } {
		set bscid [DbGetIdx $::glBscDb T_RMSCid $::_src]
		ResetIpResource
		incr ::glNumAvailRstResource -1
	} else {
		log "T_RmscExpired: exhausted all $::glNumOfAvailReset Reset Resource attempts --> the resources associated to callId_list are released!"
	}
}

proc T_GlobalReset { } {

	LogInputMsg $::_sig

	set totalNumberOfBsc [DbSize $::glBscDb]
	log "T_GlobalReset: totalNumberOfBsc=$totalNumberOfBsc"

	set cause 60; # "protocol error"
	set bscId [DbGetIdx $::glBscDb T_RESET_GLOBALid $::_src]

	log "--------------------------------------------"
	log "T_GlobalReset: _src=$::_src --> bscid=$bscId"
	log "--------------------------------------------"

	set res [GlobResetRqrd $cause $bscId]
	
	if { !$res } {
		nextstate BssapWaitForResetAck
	}
}

proc T_ResetTdmCircuit { } {

	LogInputMsg $::_sig

	ResetCircuit

	if { [info exists ::__Dbssap_PerCircReset] } {
		# PERIODIC TDM CIRCUIT RESET
		TriggerPeriodicReset TDMCIRCUIT
	}

	nextstate WaitRstCircAck
}

proc TriggerPeriodicReset { typeReset { bscId ? } } {

	global glBscDb _src

	set timer_reset "T_RESET_"
	append timer_reset "$typeReset"
	append timer_reset "id"

	if { [IsVoid $bscId] } { 
		set bscid [DbGetIdx $glBscDb $timer_reset $_src]
	} else {
		set bscid $bscId
	}
	
	log "********************"
	log "TriggerPeriodicReset: bscid=$bscid; typeReset=$typeReset; timer_reset=$timer_reset"; #cDEBUG
	log "********************"

	LogDb $glBscDb; #cDEBUG

	if { [IsVoid $bscid] || [IsEmpty $bscid] } {
		log "TriggerPeriodicReset: ERROR!"
	}
	
	set tid [DbGet $glBscDb $bscid $timer_reset]
	if { ![IsVoid $tid] && [tmrtout $tid] != 0 && ![tmrrunning $tid] } {
		logv4 "TriggerPeriodicReset: tmrstart $typeReset"
		tmrstart $tid
	} else {
		log "TriggerPeriodicReset: tid=$tid; (tmrtout=[tmrtout $tid]) --> no Periodic Reset $typeReset triggered"
	}
}

proc StartStopTimerRstResource { type {bscid ?} } {

	global glBssapDb glBscDb glMsId

	if { [IsVoid $bscid] } {
		set currBscDpc [DbGet $glBssapDb $::glInstNull Dpc]
		set bscid [DbGetIdx $glBscDb Dpc $currBscDpc]
		log "StartStopTimerRstResource: currBscDpc=$currBscDpc --> bscid=$bscid"
	}

	set tid [DbGet $glBscDb $bscid T_RMSCid]
	if {!$type} {
		# Before check if timer T_RMSC is running
		if { ![IsVoid $tid] && [tmrrunning $tid] } {
			tmrstop $tid
		}
	} else {
		# if timer is already running (RESET_RESOURCE already sent), then I don't start the timer
		if { ![IsVoid $tid] && ![tmrrunning $tid] } {
			tmrstart $tid
		}
	}
}

#------------------------------------------------------------#
# 3.1.5 "External Handover" procedure functions
#------------------------------------------------------------#
proc RcvHovRequired { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Classmark Information
	set clmark2 [DbGet $glBssapDb $glMsId ClassMark2]

	set oldToNewBssInfo [rd _sig old_bss_to_new_bss_info]
	logv1 "RcvHovRequired glMsId=$glMsId oldToNewBssInfo=$oldToNewBssInfo"
	DbSet $glBssapDb $glMsId OldToNewBssInfo $oldToNewBssInfo

	# "Classmark" procedure embedded in "External Handover" procedure
	if { [IsVoid $clmark2] } {
		SendClsmkReq

		# Store Handover Required in local Db
		DbSet $glBssapDb $glMsId HovReq $_sig

		nextstate DuringExternalHov
	} else {
		SendHovRequest $_sig
	}
	DbSet $glBssapDb $glMsId ResponseForHORequired [rd _sig rsp_req]
}

proc SendHovRequest { hov_req } {

	global protName glBscDb glBtsDb glBssapDb glMsId glMsDb glAoip

	# Channel Type
	set spi [DbGet $glBssapDb $glMsId Spi]
	set ch_rate [DbGet $glBssapDb $glMsId ChannelRate]
	set perm_speech [DbGet $glBssapDb $glMsId PermSpeech]
	set datarate [DbGet $glBssapDb $glMsId DataRate]
	log "SendHovRequest: spi=$spi, ch_rate=$ch_rate, perm_speech=$perm_speech, datarate=$datarate"
	set ch_type [GetChannelType $spi $ch_rate $perm_speech $datarate]
	log "SendHovRequest: ch_type=$ch_type"

	# Encryption Information
	set encr_info [DbGet $glBssapDb $glMsId Encryption]
	if { [IsVoid $encr_info] } {
		set encr_info 01
	}

	# ClassMark2
	set clmark2 [DbGet $glBssapDb $glMsId ClassMark2]
	if { [IsVoid $clmark2] } {
		logscr "Handover procedure aborted (Mobile Station Classmark 2 unknown)"
		return -1
	}

	# Cell Identifier Serving
	set lac [DbGet $glBssapDb $glMsId LAC]
	set ci [DbGet $glBssapDb $glMsId CellId]
	set cell_idfr_srvng [GetCellIdentifier $lac $ci]

	# Cell Identifier Target
	# Warning: hardcoded disc (01 = LAC + single Cell)
	set cell_info [GetCellInfo [rd hov_req cell_idfr_list]]
	set lac_tgt [lindex $cell_info 0]
	set ci_tgt [lindex $cell_info 1]
	DbSet $glBssapDb $glMsId LACTarget $lac_tgt
	DbSet $glBssapDb $glMsId CellIdTarget $ci_tgt
	set cell_idfr_tgt [GetCellIdentifier $lac_tgt $ci_tgt]

	# Set Bsc Target Id
	set bsc_tgt [GetBscIdByCellIdfr $lac_tgt $ci_tgt glBtsDb]
	if { [string match "-1" $bsc_tgt] } {
		abort "BSC identity unknown (LAC=$lac_tgt, CellId=$ci_tgt)"
	}
	if { ![string compare "-2" $bsc_tgt] } {
		log "SendHovRequest: Hov rejected while the cell is unknown"
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		new HOV_RQRD_REJ s
		# Cause: invalid cell
		wr  s   cause   27
		SendSccpNDataReq $spcstkidcid $s
		return
	}

	if { $glAoip } {
		set upType [SetUpNumber [GetUpFromCodec $glMsId AoipTargetMscPcl]]
		DbSet $glBssapDb $glMsId TargetUpType $upType
		log "SendHovRequest: target UP type is $upType"

		##old version used before modifications for the external HOV ##
		#set upType [DbGet $glBssapDb $glMsId UpType]
	}

	if { !$glAoip || $upType == 0 } {
		# Circuit Identity Code
		## Note: we get a cic if:
		##  1) Speech/Data Indicator ("spi") is "speech" or "data"
		##  2) Core Network is "Circuit Master"

		set permSpeechIndex 0

		if { [string match {0[12]} $spi] \
		 &&  [string match 0 [DbGet $glBscDb $bsc_tgt AllocCics]] } {

			#AMULTIPROCESSEVOLUTION (TDM)
			if { [isSplitted] } {
				set grCallRef ?; #Carlo workaround for TMA-437
				set priority ?
				SendCommonAsgReq $ch_type $perm_speech $spi $ch_rate $grCallRef $priority $bsc_tgt $datarate "SendHovRequest" $hov_req
				nextstate WaitForCicAsgRes_HovReq
				#TODO Store the result of this operation
				return 0
			}

			GetTrfCic $bsc_tgt cic_tgt fail cicExt 0 permSpeechIndex

			if { [info exists fail] } {
				logscr "External Handover procedure failed \
                        ([BssapGetProtocolCause $protName $fail])"
				return -2
			} else {
				#DbSet $glBssapDb $glMsId CicTarget $cic_tgt
				#DbSet $glBssapDb $glMsId CicExt $cicExt
				set cic_ext [GetExtCic $bsc_tgt $cic_tgt]
				log "SendHovRequest: writing cics: cic_tgt=$cic_tgt bsc_tgt=$bsc_tgt cic_ext=$cic_ext"

				#TMA-379 -start-
				set idxExtTarget [IsCicUsed $cic_tgt CicExtTarget]	
				if { $idxExtTarget == "-1" } {
					log "SendHovRequest: cic=$cic_tgt is never used"
				} else {
					set debugIdx [DbGetIdx $glBssapDb CicExtTarget $cic_ext]
					log "SendHovRequest: debugIdx=$debugIdx"
					log "SendHovRequest: cic=$cic_tgt is already used in the idxExtTarget=$idxExtTarget"
					#LogDb $glBssapDb; #cDEBUG
				}
				# -end-

				DbSet $glBssapDb $glMsId CicExtTarget $cic_ext

				set circ_idty_code [ustoh $cic_tgt B]
			}
		} else {
			set circ_idty_code "?"
		}
	}

	# DTX Flag
	set dtx_flag [DbGet $glBscDb $bsc_tgt DTXflag]
	if { [string match {[01]} $dtx_flag] } {
		set dtx_flag [uctoh $dtx_flag]
	} else {
		set dtx_flag "?"
	}

	# Cause 
	set cause [rd hov_req cause]

	# Current Channel Type 1
	set curr_ch_type_1 [rd hov_req curr_ch_type_1]

	# Speech Version (Used)
	set spch_ver [rd hov_req spch_ver]

	DbSet $glBssapDb $glMsId HoSpeechVer $spch_ver

	new HOV_REQ s

	set override 0
	# When the QueueIdList Db field is used, the correction is not done
	if { [DbFieldExists $glMsDb QueueIdList] } {
		if { ![IsVoid [DbGet $glMsDb $glMsId QueueIdList]] } {
			set override 1
		}
	}

	if { !$glAoip || $upType == 0 } {
		if { $permSpeechIndex != 0 && !$override } {
			set len [string length $perm_speech]
			set chType [string range $perm_speech [expr $permSpeechIndex * 2] end]
		} else {
			set chType $perm_speech
		} 
	} else {
		# Carlo patch 26/09/2011 see email 23/09/2011 'week report' point 1.2
		set chType $perm_speech
	} 


	log "SendHovRequest: chType=$chType; spch_ver=$spch_ver"

	wr 	s ch_type [GetChannelType $spi $ch_rate $chType $datarate]
	wr 	s encr_info $encr_info
	wr 	s clsmk_info_2 $clmark2
	wr 	s cell_idfr_srvng $cell_idfr_srvng
	wr 	s prio [DbGet $glBssapDb $glMsId Priority]
	wr 	s dwl_dtx_flag $dtx_flag
	wr 	s cell_idfr_tgt $cell_idfr_tgt
	wr 	s cause $cause
	wr 	s clsmk_info_3 [DbGet $glBssapDb $glMsId ClassMark3]
	wr 	s curr_ch_type_1 $curr_ch_type_1
	wr 	s spch_ver $spch_ver

	#--------------------#
	if { [info exists ::__aoip_ppu_list] } {
		# Multi Ppu handling #
		MultiPpuAssign
	} else {
		log "SendHovRequest: variable __aoip_ppu_list doesn't exist --> Multi Ppu management not done"
	}
	#--------------------#

	if { !$glAoip || $upType == 0 || $upType == 1 } {
		AsgReq_IeHandler "SendHovRequest" s $circ_idty_code ? 1
	} elseif { $upType == 2 } {
		AsgReq_IeHandler "SendHovRequest" s ? ? 1
	} else {
		log "SendHovRequest: ERROR!"
	}

	# Get info to pass to the new Bss
	set oldToNewBssInfo [DbGet $glBssapDb $glMsId OldToNewBssInfo]
	if { ![IsVoid $oldToNewBssInfo] } {
		log "SendHovRequest: oldToNewBssInfo=$oldToNewBssInfo"
		wr		s	old_bss_to_new_bss_info	$oldToNewBssInfo
		# TMA-262
		# check if the Ms is DTM and sends the IMSI
        if { [hgetb $oldToNewBssInfo 0] == 6} {
			global glMsDb
           	set Imsi [DbGet $glMsDb $glMsId IMSI]
			wr s imsi $Imsi
		}
		# TMA-262 
		# Clear the field
		DbSet $glBssapDb $glMsId OldToNewBssInfo "?"
	}

	LogOutputMsg $s

	SendSccpNConnectReq $glBscDb $glMsId $bsc_tgt $s

	# TMA-358 ----------------
	StartTimerHovReqNotAnswer
	# ------------------------

	nextstate WaitForConnAckInHovReq

	set LcsState [DbGet $glBssapDb $glMsId LcsState]
	if { $LcsState==1 } {
		#Location Procedure ongoing->send Abort
		
		new PERF_LOC_ABRT s
		# lcs cause inter BSC Handover
		wr s lcs_cause 09
		LogOutputMsg $s
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		SendSccpNDataReq $spcstkidcid $s
	
		# Reset LCS State	
		DbSet $glBssapDb $glMsId LcsState 0
	}

	return 0
}

proc RcvHovFail { } {

	global _sig glBssapDb glMsId 
	
	LogInputMsg $_sig

	# TMA-358 ----------------
	StopTimerHovReqNotAnswer
	# ------------------------

	# Sending Clear Command
	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause [rd _sig cause]

	SendClrCmdTarget [list $prot_disc $trans_id $cause]

	DequeueApDataReq
}

proc RcvHovFailTgtOnly { } {

	global _sig glBssapDb glMsId 
	
	LogInputMsg $_sig

	# Sending Clear Command
	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause [rd _sig cause]

	SendClrCmdTarget [list $prot_disc $trans_id $cause]
	# Send Release Ind to MM
	set cause "Normal_Event"
	SendApRelInd $cause

	nextstate WaitForClrCmplt

}

proc RcvHovReqAck { } {

	global _sig _state glAoip glBssapDb glMsId
	
	log "Message [lindex $_sig 0] Received in State $_state"

	# TMA-358 ----------------
	StopTimerHovReqNotAnswer
	# ------------------------

	set l3pdu [rd _sig l3_info]

	if { $glAoip } {
		# changed by jiangtao ##
		set spch_codec [rd _sig speech_codec]

		if { [IsVoid $spch_codec] }  {
			# 28/05/2012: coded is added to deal to the void speech_codec in âHOV_REQ_ACKâ from bsc whose up is TDM
			set upType 0
		} else {
			set upType [SetUpNumber [UP_Discriminator $spch_codec]]
		}
		DbSet $glBssapDb $glMsId TargetUpType $upType
	}

	if { $glAoip && $upType } {
		DbSet $glBssapDb $glMsId HoSpeechCodec $spch_codec
		set aupoip_container [rd _sig aoip_tla]
		if { ![IsEmpty $aupoip_container] && ![IsVoid $aupoip_container] } {
			# in the IP or MIXED case the TLA isn't void
			UPoIPcnGet $aupoip_container ip_add port

			DbSet $glBssapDb $glMsId HoDestIp $ip_add
			DbSet $glBssapDb $glMsId HoDestPort $port
			log "RcvHovReqAck: spch_codec = $spch_codec; ip_add = $ip_add; port = $port"
		}
	} else {
		log "RcvHovReqAck: TDM signalling and userplane"
	}

	SendHovCommand $l3pdu
 
	nextstate _c_WaitForHovProcCompleted
}

proc RcvIntHoRqdWaitRtpOpenAck { } {

	logv1 "RcvIntHoRqdWaitRtpOpenAck: discard the message because it's waiting the Rtp Open Ack \														 from server on the LSU and resend 'INTERNAL_HO_ENQUIRY'"

	#Carlo 06/05/2011: non so se Ã¨ la soluzione migliore..occorre testare
	RcvMsgDiscard

	if { ![IsVoid [IntHovEnqNeeded]] && [IntHovEnqNeeded] } {
		SendIntHovEnquiry
	} else {
		# Carlo 05/07/2012: test for TMA-481
		
		set cause 07; # O&M intervention (48.008-730 3.2.2.5)
		DbSet $::glBssapDb $::glMsId ResponseForHORequired $cause
	
		log "Send HO Required Reject to the BSC with O&M intervention cause"

		set spcstkidcid [DbGet $::glBssapDb $::glMsId SpcStkIdCid]
		new HOV_RQRD_REJ s
		wr	s	cause	$cause

		LogOutputMsg $s
		SendSccpNDataReq $spcstkidcid $s
	}
}

proc RcvMsgDiscard { } {

	global _sig 
	
	log "[lindex $_sig 0] Discarded"

	if { [lindex $_sig 0] == "INTERNAL_HO_RQD" } {
		# used to debug the TMA-481
		logv1 "[lindex $_sig 0] Discarded"
	}
}

proc SendHovCommand { l3pdu } {

	global glBssapDb glMsId
	
	new HOV_CMD s
	wr 	s l3_info $l3pdu

	log "Sending Message HOV_CMD"

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

proc RcvHovDetect { } {

	global _sig
	
	LogInputMsg $_sig
}

# EXTERNAL HANDOVER COMPLETE received 
proc RcvHovCmplt { } {

	global _sig glMsId glBssapDb glBtsDb glBscDb glTrfDb

	LogInputMsg $_sig

	if { $::glAoip } {
		if { [IpUpSupported] } {
			if { [RcvAoipHovCmplt] } {
				return
			}
		} else {
			log	"RcvHovCmplt: UserPlane over IP isn't supported: just signalling over IP"
			
			#fangminyu 28/05/2012
			#comment the 'return',as msc is required to send clear request, otherwise bsc will initiate clear request and causes call drop
			#return; # in case of Aoip without UserPlane (no TDM and no IP) no more actions will be done

			# Carlo:it adds to skip the next 'if' and to go directly to next 'SendClrCmd'. 
			set connString ?
		}
	}

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause 0b; # Cause "Handover Successfull"

	set connString [DbGet $glBssapDb $glMsId CicConnection]
	log "RcvHovCmplt: connString=$connString"
	if { ![IsVoid $connString] } {
		set lsuPcm1 [lindex $connString 5]
		set ts1  [lindex $connString 6]
		set lsuPcm2 [lindex $connString 1]
		set ts2 [lindex $connString 2]

		set bsc1id [lindex $connString 10]
		set bsc2id [lindex $connString 8]
		log "RcvHovCmplt: bsc1id=$bsc1id; bsc2id=$bsc2id"; #cDEBUG

		# legenda: PCM2: OUT <-- PCM1: INPUT
		log "Disconnect LsuPcm2: $lsuPcm2 - Ts: $ts2"
    	log "from       LsuPcm1: $lsuPcm1 - Ts: $ts1"

		set spc [DbGet $glBssapDb $glMsId Spc]
		set stkid [DbGet $glBssapDb $glMsId StkId]

		if { [string compare "DPHONE" $lsuPcm2] && [string compare "DPHONE" $lsuPcm1] } {
			log "RcvHovCmplt: case where there are no DPHONE"

			LogDb $glTrfDb($bsc1id); #cDEBUG
			log "#################"; #cDEBUG
			set trfDb1 	$glTrfDb($bsc1id)

			LogDb $glTrfDb($bsc2id); #cDEBUG
			log "#################"; #cDEBUG
			set trfDb2	$glTrfDb($bsc2id)

			set pcm1	[GetPcmbyLsuPcm $lsuPcm1 $bsc1id $trfDb1]
			set pcm2	[GetPcmbyLsuPcm $lsuPcm2 $bsc2id $trfDb2]
			log "pcm1=$pcm1; pcm2=$pcm2"; #cDEBUG

			log "bsc1id=$bsc1id --> trfDb1=$trfDb1; bsc2id=$bsc2id --> trfDb2=$trfDb2"; #cDEBUG

			if { [DbKeyExists $trfDb1 Pcm $pcm1] } {
				##################################
				log "RcvHovCmplt: DISCONNECTION"
				##################################
				set pcm1Idx [DbGetIdx $trfDb1 Pcm $pcm1]
				set pcm2Idx [DbGetIdx $trfDb2 Pcm $pcm2]

				log "pcm1Idx=$pcm1Idx; pcm2Idx=$pcm2Idx"; #cDEBUG
				log "lsuPcm1=$lsuPcm1; lsuPcm2=$lsuPcm2"; #cDEBUG

				#//// TEST 16/02/2010  //////////////////#
				set dstId [DbGet $glBssapDb $glMsId DestId]
				log "RcvHovCmplt: glMsId=$glMsId on BSC1=$bsc1id under MSC1= --> dstId=$dstId on BSC2=$bsc2id under MSC2= "; #cDEBUG
				if { [IsVoid [CheckDstIdAFlex $dstId]] } {
					# A-FLEX
					logscr "RcvHovCmplt in A-FLEX case"
	
					log "RcvHovCmplt: connString=$connString"

					# Â§Â§Â§Â§Â§ TMA-381 Â§Â§Â§Â§Â§ #
					if { [IsVoid $lsuPcm1] && [IsVoid $lsuPcm2] && ![IsVoid $pcm1] && ![IsVoid $pcm2] } {
                    	log "RcvHovCmplt: case of NO TRAFFIC Testing (glMsId=$glMsId; dstId=$dstId)"
					# Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§ #
					} else {
						#-----------------#
						# 0: Disconnection
						AflexHovManagement 0 $connString $spc $stkid
						#-----------------#
					}
				} else {
					# NO A-FLEX case
				#////////////////////////////////////////#

					# Disconnect BiDirectional (mode=3)
					if { ![DbFieldExists $trfDb1 PcmType] && ![DbFieldExists $trfDb2 PcmType] || \
							![DbFieldExists $trfDb1 PcmType] && ![DbGet $trfDb2 $pcm2Idx PcmType] || \
							![DbGet $trfDb1 $pcm1Idx PcmType] && ![DbFieldExists $trfDb2 PcmType] || \
							![DbGet $trfDb1 $pcm1Idx PcmType] && ![DbGet $trfDb2 $pcm2Idx PcmType]} {

						#Carlo 28/01/2010 PATCH sembra nn funzionare la disconnect bidirez per le pcm
						# quindi faccio due disconnect monodir
						##SendPcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 3

						# All Electrical PCMs
						log "RcvHovCmplt: Disconnection $lsuPcm1 --> $lsuPcm2 "
						SendPcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 2
					
						log "RcvHovCmplt: Disconnection $lsuPcm2 --> $lsuPcm1"
						SendPcmDisconnect $spc $stkid $lsuPcm1 $ts1 $lsuPcm2 $ts2 2

					} elseif { [DbGet $trfDb1 $pcm1Idx PcmType] == 1 && [DbGet $trfDb2 $pcm2Idx PcmType] == 1 } {
						# All STM-1 mapped PCMs
						if { [IsEmpty [lindex [split $lsuPcm1 -] 1]] } {
							set stm1Pcm1Line [DbGet $trfDb1 $pcm1Idx Stm1Line]
							append lsuPcm1 -
							append lsuPcm1 $stm1Pcm1Line
						} elseif { [IsEmpty [lindex [split $lsuPcm2 -] 1]] } {
							set stm1Pcm2Line [DbGet $trfDb2 $pcm2Idx Stm1Line]
							append lsuPcm2 -
							append lsuPcm2 $stm1Pcm2Line
						}
						SendMixedStm1PcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 3 4
					} elseif { [DbGet $trfDb1 $pcm1Idx PcmType] == 0 && [DbGet $trfDb2 $pcm2Idx PcmType] == 1 } {
						# PCM 1 (In): Electrical;  PCM 2 (Out): STM-1 mapped
						if { [IsEmpty [lindex [split $lsuPcm2 -] 1]] } {
							set stm1Pcm2Line [DbGet $trfDb2 $pcm2Idx Stm1Line]
							append lsuPcm2 -
							append lsuPcm2 $stm1Pcm2Line
						}
						SendMixedStm1PcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 3 5
					} elseif { [DbGet $trfDb1 $pcm1Idx PcmType] == 1 && [DbGet $trfDb2 $pcm2Idx PcmType] == 0 } {
						# PCM 1 (In): STM-1 mapped; PCM 2 (Out): Electrical
						if { [IsEmpty [lindex [split $lsuPcm1 -] 1]] } {
							set stm1Pcm1Line [DbGet $trfDb1 $pcm1Idx Stm1Line]
							append lsuPcm1 -
							append lsuPcm1 $stm1Pcm1Line
						}
						SendMixedStm1PcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 3 6
					} else {
						logscr "RcvHovCmplt: ERROR --> the Pcm1Type=[DbGet $trfDb1 $pcm1Idx PcmType] and Pcm2Type=[DbGet $trfDb2 $pcm2Idx PcmType]                                                            must be equal to 0 or 1 if 'PcmType' field exists in the trfDb1=$trfDb1 and in the trfDb2=$trfDb2"
					}

				#////////////////////////////////////////#
				}; # END IF CHECK A-FLEX
				foreach idx [DbGetIndexList $glBssapDb] {
					if { ![IsVoid [DbGet $glBssapDb $idx CicConnection]] } {
						log "RcvHovCmplt: Disconnection occurred: Old_ConnString_Db=[DbGet $glBssapDb $idx CicConnection] "; #cDEBUG
					}
				}

				################################
				log "RcvHovCmplt: RECONNECTION"
				################################
				log "RcvHovCmplt: CicConnection_PreReconnection=[DbGet $glBssapDb $glMsId CicConnection]"
				set cic_ext [DbGet $glBssapDb $glMsId CicExtTarget]
				set cic [GetCicByExtCic $cic_ext]
				set tgtBscId [GetBscIdByExtCic $cic_ext]
				log "RcvHovCmplt: cic_ext=$cic_ext cic=$cic; tgtBscId=$tgtBscId"
				set tgtPcm1 [expr {$cic >> 5}]
				set tgtTs1 [expr {$cic & 0x1f}]
				set tgtTrfDb [DbGetName [DbGet $glBscDb $tgtBscId TrafficLinksDb]]
				log "RcvHovCmplt: tgtPcm1=$tgtPcm1 tgtTs1=$tgtTs1 tgtTrfDb=$tgtTrfDb"
				if { [DbKeyExists $tgtTrfDb Pcm $tgtPcm1] } {
					set pcm1Idx [DbGetIdx $tgtTrfDb Pcm $tgtPcm1]
					set lsuTgtPcm1 [DbGet $tgtTrfDb $pcm1Idx LsuPcm]
					if { [DbFieldExists $tgtTrfDb Stm1Line] } {
						if { ![IsEmpty [DbGet $tgtTrfDb $pcm1Idx Stm1Line]] && ![IsVoid [DbGet $tgtTrfDb $pcm1Idx Stm1Line]] } {
							set lsuTgtStm1Line [DbGet $tgtTrfDb $pcm1Idx Stm1Line]
							log "RcvHovCmplt: lsuTgtStm1Line=$lsuTgtStm1Line"; #cDEBUG
			
							append lsuTgtPcm1 -
							append lsuTgtPcm1 $lsuTgtStm1Line

						} else {
							log "RcvHovCmplt: the 'Stm1Line' field in $tgtTrfDb is empty or void"; #cDEBUG
						}
					} else {
						log "RcvHovCmplt: the 'Stm1Line' field doesn't exist in $tgtTrfDb"; #cDEBUG
					}
					log "RcvHovCmplt: lsuTgtPcm1=$lsuTgtPcm1"
				} else {
					abort "Error: PCM ($tgtPcm1) does not exist in Traffic Db ($tgtTrfDb)"
				}


				lset connString 5 	$lsuTgtPcm1; # new Pcm target
				lset connString 6 	$tgtTs1;	 # new Ts  target
			
				lset connString 10 	$tgtBscId
				lset connString 8	$bsc2id

				log "RcvHovCmplt: Target connString=$connString"

				set pcm2Idx 	 [DbGetIdx $trfDb2 Pcm $pcm2]

				if { [IsVoid [CheckDstIdAFlex $dstId]] } {
					# A-FLEX
					logscr "RcvHovCmplt in A-FLEX case"

					# Â§Â§Â§Â§Â§ TMA-381 Â§Â§Â§Â§Â§ #
					if { [IsVoid $lsuTgtPcm1] && [IsVoid $lsuPcm2] && ![IsVoid $tgtPcm1] && ![IsVoid $pcm2] } {
                    	log "RcvHovCmplt: case of NO TRAFFIC TESTING (glMsId=$glMsId; dstId=$dstId)"
					# Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§Â§ #
					} else {
						#-----------------#
						# 1: Reconnection
						AflexHovManagement 1 $connString $spc $stkid
						#-----------------#
					}
				} else {
					# NO A-FLEX case
					if { ![DbFieldExists $tgtTrfDb PcmType] && ![DbFieldExists $trfDb2 PcmType] || ![DbFieldExists $tgtTrfDb PcmType] && ![DbGet $trfDb2 $pcm2Idx PcmType] || ![DbGet $tgtTrfDb $pcm1Idx PcmType] && ![DbFieldExists $trfDb2 PcmType] || ![DbGet $tgtTrfDb $pcm1Idx PcmType] && ![DbGet $trfDb2 $pcm2Idx PcmType] } {
						set lsuTgtPcm1_1 [lindex [split $lsuTgtPcm1 -] 1]
						# All Electrical PCMs
						if { [IsVoid $lsuTgtPcm1_1] || [IsEmpty $lsuTgtPcm1_1] } {
							# Connect BiDirectional
							SendPcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1
						} else {
							log "RcvHovCmplt: WARNING: lsuTgtPcm1_1=$lsuTgtPcm1_1 isn't void or it isn't empty"; #cDEBUG
						}
					} elseif { [DbGet $tgtTrfDb $pcm1Idx PcmType] == 1 && [DbGet $trfDb2 $pcm2Idx PcmType] == 1 } {
						# All STM-1 mapped PCMs
						if { [IsEmpty [lindex [split $lsuPcm2 -] 1]] } {
							set stm1Pcm2Line [DbGet $trfDb2 $pcm2Idx Stm1Line]
							append lsuPcm2 -
							append lsuPcm2 $stm1Pcm2Line
						} elseif { [IsEmpty [lindex [split $lsuTgtPcm1 -] 1]] } {
							set stm1Pcm1Line [DbGet $tgtTrfDb $pcm1Idx Stm1Line]
							append lsuTgtPcm1 -
							append lsuTgtPcm1 $stm1Pcm1Line
						}
						log "RcvHovCmplt: STM-1 mapped PCMs; lsuPcm2=$lsuPcm2 ts2=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
						# Connect BiDirectional
						SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1 4
					} elseif { [DbGet $tgtTrfDb $pcm1Idx PcmType] == 0 && [DbGet $trfDb2 $pcm2Idx PcmType] == 1 } {
						# PCM 1: Electrical;  PCM 2: STM-1 mapped
						if { [IsEmpty [lindex [split $lsuPcm2 -] 1]] } {
							set stm1Pcm2Line [DbGet $trfDb2 $pcm2Idx Stm1Line]
							append lsuPcm2 -
							append lsuPcm2 $stm1Pcm2Line 
						}
						log "RcvHovCmplt: Pcm 1: Electrical --> PCM 2: STM-1 mapped PCMs; lsuPcm2=$lsuPcm2 ts2=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
						# Connect BiDirectional
						SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1 5
					} elseif { [DbGet $tgtTrfDb $pcm1Idx PcmType] == 1 && [DbGet $trfDb2 $pcm2Idx PcmType] == 0 } {
						# PCM 1: STM-1 mapped; PCM 2: Electrical
						if { [IsEmpty [lindex [split $lsuTgtPcm1 -] 1]] } {
							set stm1Pcm1Line [DbGet $tgtTrfDb $pcm1Idx Stm1Line]
							append lsuTgtPcm1 -
							append lsuTgtPcm1 $stm1Pcm1Line
						}
						log "RcvHovCmplt: PCM 1: STM-1 mapped PCM --> Pcm 2: Electrical; lsuPcm2=$lsuPcm2 ts2=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
						# Connect BiDirectional
						SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1 6
					} else {
						logscr "RcvHovCmplt: ERROR --> the Pcm1Type=[DbGet $tgtTrfDb $pcm1Idx PcmType] and Pcm2Type=[DbGet $trfDb2 $pcm2Idx PcmType] 															  have to be equal to 0 or 1"
					}
					log "RcvHovCmplt: Handover Terminated: Old_CicConnection=[DbGet $glBssapDb $glMsId CicConnection]"
				}; # END IF CHECK A-FLEX

			} else {
				log "RcvHovCmplt: WARNING: pcm1=$pcm1 (corresponding to lsuPcm1=$lsuPcm1) doesn't exist in the trfDb1=$trfDb1 so it's impossible to do disconnection and reconnection"
			}
		} else {
			log "RcvHovCmplt: case where one (INP or OUT) is a DPHONE"

			if { ![string compare $lsuPcm2 "DPHONE"] } {
				LogDb $glTrfDb($bsc1id); #cDEBUG
				log "#################"; #cDEBUG
				set trfDb1 	$glTrfDb($bsc1id)
				set pcm1	[GetPcmbyLsuPcm $lsuPcm1 $bsc1id $trfDb1]
				log "pcm1=$pcm1"; #cDEBUG

			} elseif { ![string compare $lsuPcm1 "DPHONE"] } {
				LogDb $glTrfDb($bsc2id); #cDEBUG
				log "#################"; #cDEBUG
				set trfDb2	$glTrfDb($bsc2id)
				set pcm2	[GetPcmbyLsuPcm $lsuPcm2 $bsc2id $trfDb2]
				log "pcm2=$pcm2"; #cDEBUG
			}

			#####################################
			log "RcvHovCmplt: - DISCONNECTION -"
			#####################################
			# -------------------- #
			# Start TMA-348
			if { ![string compare $lsuPcm2 "DPHONE"] && [DbKeyExists $trfDb1 Pcm $pcm1] } {
				set pcm1Idx [DbGetIdx $trfDb1 Pcm $pcm1]
				if { ![DbFieldExists $trfDb1 PcmType] || ![DbGet $trfDb1 $pcm1Idx PcmType] } {
					# PCM2 (OUT) is an Electrical PCM while INPUT is a DPHONE
					SendPcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 2
					SendPcmDisconnect $spc $stkid $lsuPcm1 $ts1 $lsuPcm2 $ts2 2
				} elseif { [DbGet $trfDb1 $pcm1Idx PcmType] == 1 } {
					# PCM2 (OUT) is a STM-1 mapped PCM while INPUT is a DPHONE
					SendMixedStm1PcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 2 7
					SendMixedStm1PcmDisconnect $spc $stkid $lsuPcm1 $ts1 $lsuPcm2 $ts2 2 8
				} else {
					log "WARNING: pcm1=$pcm1 is neither an Electrical PCM nor an STM-1 mapped PCM"
				}
			} elseif { ![string compare $lsuPcm1 "DPHONE"] && [DbKeyExists $trfDb2 Pcm $pcm2] } {
				set pcm2Idx [DbGetIdx $trfDb2 Pcm $pcm2]
				if { ![DbFieldExists $trfDb2 PcmType] || ![DbGet $trfDb2 $pcm2Idx PcmType] } {
					# OUT is a DPHONE while PCM1 (INPUT) is an Electrical PCM
					SendPcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 2
					SendPcmDisconnect $spc $stkid $lsuPcm1 $ts1 $lsuPcm2 $ts2 2
				} elseif { [DbGet $trfDb2 $pcm2Idx PcmType] == 1 } {
					# OUT is a DPHONE while PCM1 (INPUT) is an STM-1 mapped PCM
					SendMixedStm1PcmDisconnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 2 7
					SendMixedStm1PcmDisconnect $spc $stkid $lsuPcm1 $ts1 $lsuPcm2 $ts2 2 8
				} else {
					log "WARNING: pcm2=$pcm2 is neither an Electrical PCM nor an STM-1 mapped PCM"
				}
			} else {
				log "RcvHovCmplt: WARNING: both pcm1 doesn't exist in trfDb1 and pcm2 doesn't exist in the trfDb2 so it's impossible to do 'disconnection'"
			}
			 # End TMA-348
			# -------------------- #
			#####################################
			log "RcvHovCmplt: - RECONNECTION -"
			#####################################
			log "RcvHovCmplt: OLD_CicConnection=[DbGet $glBssapDb $glMsId CicConnection]"
			set cic_ext [DbGet $glBssapDb $glMsId CicExtTarget]
			set cic [GetCicByExtCic $cic_ext]
			set tgtBscId [GetBscIdByExtCic $cic_ext]
			log "RcvHovCmplt: cic_ext=$cic_ext cic=$cic; tgtBscId=$tgtBscId"
			set tgtPcm1 [expr {$cic >> 5}]
			set tgtTs1 [expr {$cic & 0x1f}]
			set tgtTrfDb [DbGetName [DbGet $glBscDb $tgtBscId TrafficLinksDb]]
			log "RcvHovCmplt: tgtPcm1=$tgtPcm1 tgtTs1=$tgtTs1 tgtTrfDb=$tgtTrfDb"
			if { [DbKeyExists $tgtTrfDb Pcm $tgtPcm1] } {
				set pcm1Idx [DbGetIdx $tgtTrfDb Pcm $tgtPcm1]
				set lsuTgtPcm1 [DbGet $tgtTrfDb $pcm1Idx LsuPcm]
				log "RcvHovCmplt: lsuTgtPcm1=$lsuTgtPcm1"
			} else {
				abort "Error: PCM ($tgtPcm1) doesn't exist in Traffic Db ($tgtTrfDb)"
			}

			# ----------------------------- connString scheme ---------------------------------------------- #
			#
			# LsuPCM $lsuPcm2 $ts2 From	LsuPCM $lsuPcm1	$ts1 BSC2 $bsc2 BSC1 $bsc1
			#	0		1		2	3	  4		  5		  6	  7		8	 9	   10	
			#
			# ---------------------------------------------------------------------------------------------- #

			lset connString 5 $lsuTgtPcm1
			lset connString 6 $tgtTs1

			lset connString 10 	$tgtBscId
			lset connString 8	$bsc2id

			DbSet $glBssapDb $glMsId CicConnection $connString

			if { [string compare $lsuTgtPcm1 "DPHONE"] } {
				# non Ã¨ un dphone
				LogDb $tgtTrfDb; #cDEBUG
			}

			if { ![DbFieldExists $tgtTrfDb PcmType] || ![DbGet $tgtTrfDb $pcm1Idx PcmType] } {
			# Electrical PCMs - DPHONE
				# Connect BiDirectional
				SendPcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1

			} elseif { [DbGet $tgtTrfDb $pcm1Idx PcmType] == 1 } {
			# STM-1 mapped PCMs - DPHONE
				set stm1Pcm1Line [DbGet $tgtTrfDb $pcm1Idx Stm1Line]
				log "stm1Pcm1Line=$stm1Pcm1Line"; #cDEBUG
				if { [IsEmpty [lindex [split $lsuTgtPcm1 -] 1]] } {
					append lsuTgtPcm1 -
					append lsuTgtPcm1 $stm1Pcm1Line
				}
			
				lset connString 5 $lsuTgtPcm1
				DbSet $glBssapDb $glMsId CicConnection $connString

				log "RcvHovCmplt: STM-1 mapped PCMs --> DPHONE;  dphone=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
				# Connect BiDirectional
				SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1 8
			} else {
				logscr "RcvHovCmplt: WARNING!"
			}
			log "RcvHovCmplt: NEW_CicConnection=[DbGet $glBssapDb $glMsId CicConnection]"
		}

		# Update Destination Db, just in case of MS to MS call
		if { [string compare $lsuPcm1 "DPHONE"] && [string compare $lsuPcm2 "DPHONE"] } {
		
			foreach idx [DbGetIndexList $glBssapDb] {
				if { ![IsVoid [DbGet $glBssapDb $idx CicConnection]] } {
					log "RcvHovCmplt: Old_ConnString_Db=[DbGet $glBssapDb $idx CicConnection] "; #cDEBUG
				}
				if { ![IsVoid [DbGet $glBssapDb $idx PcmType]] } {
					log "RcvHovCmplt: Old_PcmType_Db=[DbGet $glBssapDb $idx PcmType]"
				}
			}

			set twinString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"

			if { [DbKeyExists $glBssapDb CicConnection $twinString] } {
				set twinIdx [DbGetIdx $glBssapDb CicConnection $twinString]
				set newConnString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuTgtPcm1 $tgtTs1 BSC2 $bsc2id BSC1 $tgtBscId"

				# TMA-381 (added the if)
				if { ![DbKeyExists $glBssapDb CicConnection $newConnString] } {
					DbSet $glBssapDb $twinIdx CicConnection $newConnString
				} elseif { [DbKeyExists $glBssapDb CicConnection $newConnString] && [IsVoid $lsuTgtPcm1] && [IsVoid $lsuPcm2] } {
					log "RcvHovCmplt: newConnString already exists in the $glBssapDb: case of lsuTgtPcm1 and lsuPcm2 both void"
				} else {
					log "RcvHovCmplt: WARNING ..."
				}
				
				# TMA-353
				if { ![IsEmpty [lindex [split $lsuTgtPcm1 -] 1]] && ![IsVoid [lindex [split $lsuTgtPcm1 -] 1]] } {
					set tgtPcmType1 1
				} else {
					set tgtPcmType1 0
				}
			
				#log "RcvHovCmplt: tgtPcmType1=$tgtPcmType1"; #cDEBUG

				#Carlo: qs twinIdx Ã¨ il MsId (il mobile che effettua l'handover)
				DbSet $glBssapDb $twinIdx PcmType $tgtPcmType1

				if { $glMsId != $twinIdx } {
					log "RcvHovCmplt: ERROR: glMsId=$glMsId different from twinIdx=$twinIdx"; #cDEBUG
				}
			} else {
				abort "Error: Can't find Connection in Peer ($twinString)"
			}
		
			log "RcvHovCmplt: Handover Terminated: New_CicConnection_DIRECT=[DbGet $glBssapDb $glMsId CicConnection]"

			# aggiorno nel Db la connex inversa; attenzione: gli indici dei BSC sono invertiti perche Ã¨ la connex inversa
			set twinStringReverse "LsuPCM $lsuPcm1 $ts1 From LsuPCM $lsuPcm2 $ts2 BSC2 $bsc1id BSC1 $bsc2id"

			if { [DbKeyExists $glBssapDb CicConnection $twinStringReverse] } {
				set twinIdx [DbGetIdx $glBssapDb CicConnection $twinStringReverse]
				set newConnStringReverse "LsuPCM $lsuTgtPcm1 $tgtTs1 From LsuPCM $lsuPcm2 $ts2 BSC2 $tgtBscId BSC1 $bsc2id"

				# TMA-381 (added the if)
				if { ![DbKeyExists $glBssapDb CicConnection $newConnStringReverse] } {
					DbSet $glBssapDb $twinIdx CicConnection $newConnStringReverse
				} elseif { [DbKeyExists $glBssapDb CicConnection $newConnStringReverse] && [IsVoid $lsuTgtPcm1] && [IsVoid $lsuPcm2] } {
					log "RcvHovCmplt: newConnStringReverse already exists in the $glBssapDb: case of lsuTgtPcm1 and lsuPcm2 both void"
				} else {
					log "RcvHovCmplt: -WARNING-"
				}


				# TMA-353
				if { ![IsEmpty [lindex [split $lsuPcm2 -] 1]] && ![IsVoid [lindex [split $lsuPcm2 -] 1]] } {
					set pcmType2 1
				} else {
					set pcmType2 0
				}

				#log "RcvHovCmplt: pcmType2=$pcmType2"; #cDEBUG

				#Carlo: qs twinIdx Ã¨ il dstId (il mobile che Ã¨ 'passivo' rispetto al handover)
				DbSet $glBssapDb $twinIdx PcmType $pcmType2

				# --------------- #

				#LogDb $glBssapDb; #cDEBUG

				if { [IsVoid [CheckDstIdAFlex $twinIdx]] } {
					global __tstm_db
					# A_FLEX: it informs the other MSC of the new connection consequent to the HO (new connStringReverse)
					if { [info exists __tstm_db] } {
						set tstmIndexOwn [gettstmindex]

						set pcmType1	[DbGet $glBssapDb $glMsId PcmType] 
						set stm1Line1	[DbGet $glBssapDb $glMsId Stm1Line]
						set bscId1		[DbGet $glBssapDb $glMsId BscId]

						# Signal Building
						set connect_sig [list BSSAP_HOV_DATA_IND $glMsId $newConnStringReverse $tstmIndexOwn "?"]

						global __bssap_plmn
						if { [info exists __bssap_plmn]	&& $__bssap_plmn == "99f921" } {
							# only for Alcatel Velizy testbed where all2all userscripts use
							set protocolName "Fix2MCORE"
						} else {
							set protocolName "M2MCCORE"
						}

						log "RcvHovCmplt: glMsId=$glMsId tstmIndexOwn=$tstmIndexOwn protocolName=$protocolName"

						# Inform CORE Tstm the new PCM value for the mobile managed by other MSC
						sendtotstm 0 $protocolName $connect_sig

						log "$connect_sig --> MsId=[lindex $connect_sig 1]"; #cDEBUG

					} else {
						log "RcvHovCmplt: __tstm_db doesn't exist"
					}
				}
				# --------------- #

			} else {
				#TMA-381 (added the next if condition)
				if { ![IsVoid $lsuTgtPcm1] && ![IsVoid $lsuPcm2] } {
					abort "Error: Can't find Reverse Connection in Peer ($twinStringReverse)"
				} else {
					log "RcvHovCmplt: case of NO TRAFFIC TESTING !!!"
				}
			}

			log "RcvHovCmplt: Handover Terminated: New_CicConnection_REVERSE=[DbGet $glBssapDb $twinIdx CicConnection]"
			log "RcvHovCmplt: Ms $glMsId <--> Ms $twinIdx"; #cDEBUG

			foreach idx [DbGetIndexList $glBssapDb] {
				if { ![IsVoid [DbGet $glBssapDb $idx CicConnection]] } {
					log "RcvHovCmplt: idx=$idx; New_ConnString_Db=[DbGet $glBssapDb $idx CicConnection] "; #cDEBUG
				}
				if { ![IsVoid [DbGet $glBssapDb $idx PcmType]] } {
					log "RcvHovCmplt: idx=$idx; New_PcmType_Db=[DbGet $glBssapDb $idx PcmType]"
				}
			}
			#Carlo ----DEBUG TMA-353 ------------ #
			log "Ms_HoGenerator:$glMsId; NewPcmType_Ms_HoGenerator=[DbGet $glBssapDb $glMsId PcmType]; lsuTgtPcm1_1=[lindex [split $lsuTgtPcm1 -] 1]"
			log "Ms_passive:$twinIdx; NewPcmType_Ms_Passive=[DbGet $glBssapDb $twinIdx PcmType]; lsuPcm2_1=[lindex [split $lsuPcm2 -] 1]"
			# ----------------------------------- #
		}
	}

	# Clear Serving
	SendClrCmd [list $prot_disc $trans_id $cause]

	nextstate _c_WaitForClrCmpltHov
	
	DequeueApDataReq
}

# case for EXTERNAL HANDOVER
proc RcvHovCmpltTarget { } {

	global _sig glBssapDb glMsId
	
	LogInputMsg $_sig

	# Check if Serving was already Released
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	if { ![IsVoid $spcstkidcid] } {
		nextstate _c_WaitForClrCmpltHov
	} else {
		# Switch Target Connection into Serving
		BssapMovInst $glMsId
		nextstate BssapConnectActive
	}

	DequeueApDataReq
}

# see Alcatel document 'DATA_RCP_EP9_3BL30002LOAAPQAHA_ed1.pdf' (RG_TRR2)
proc StartTimerHovReqNotAnswer { } {

	global glBssapDb glMsId

	# Timer T_RG_TRR2 (min: 0 sec; default: 3.5 sec)
	set tidHoReqNoAnws [DbGet $glBssapDb $glMsId T_RG_TRR2id]

	if { [tmrtout $tidHoReqNoAnws] != 0 } {
		tmrstart $tidHoReqNoAnws
	}

	log "StartTimerHovReqNotAnswer: starting T_RG_TRR2 timer $tidHoReqNoAnws"; #cDEBUG
}

proc T_HoReqNotAnswerExpired { } {

	global glBssapDb glMsId

	LogInputSig

	# Ho Required Failed: (48.008-730  3.2.1.37)
	set cause 07; # O&M intervention (48.008-730 3.2.2.5)
	DbSet $glBssapDb $glMsId ResponseForHORequired $cause

	log "Send HO Required Reject to the BSC with O&M intervention cause"

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	new HOV_RQRD_REJ s
	wr	s	cause	$cause

	LogOutputMsg $s
 
	SendSccpNDataReq $spcstkidcid $s

	# start Workaround 09/08/2010 for Alcatel Shanghay ------------- #
	log "T_HoReqNotAnswerExpired: RELEASES TARGET EXTENSION CIC for the mobile $glMsId...."; #cDEBUG 
	ReleaseExtCic $glMsId "CicExtTarget"
	# stop Workaround

	# Carlo PATCH 09/03/2010 ---#
	nextstate BssapConnectActive
	#---------------------------#
}

proc StopTimerHovReqNotAnswer { } {

	global glBssapDb glMsId

	# Stop Timer T_RG_TRR2 if it's running
	set tid [DbGet $glBssapDb $glMsId T_RG_TRR2id]
	if { ![IsVoid $tid] && [tmrrunning $tid] } {
		tmrstop $tid
	}
}

#------------------------------------------------------------#
# 3.1.5a "Handover from GSM to another System" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.6 "Internal Intra-Cell Handover" procedure functions
#------------------------------------------------------------#
#------------------------------------------------------------#
# 3.1.7 "Internal Inter-Cell Handover" procedure functions
#------------------------------------------------------------#
proc RcvHovPerformed { } {

	global _sig glBssapDb glMsId __tm_top _self

	LogInputMsg $_sig

	set cell_info [GetCellInfo [rd _sig cell_idfr]]
	set lac [lindex $cell_info 0]
	set ci [lindex $cell_info 1]
	
	# Update LAC / CellId
	if { ![IsVoid $lac] } {
		DbSet $glBssapDb $glMsId LAC $lac
	}
	if { ![IsVoid $ci] } {
		DbSet $glBssapDb $glMsId CellId $ci
	}
	if { $__tm_top > 5 } {
		global glBscDb
		if { [IsVgcs $glMsId $glBssapDb] } {
			# Inform the GCC layer 
			new BSSAP_CTL_VGCS_HOV_PERFD_IND s
			wr s Lac $lac
			wr s CellId $ci
			wr s MsId $glMsId
			send s $_self
		}
	}
}

proc RcvInternalHovRequired { } {

	global _sig glMsId glBssapDb
	
	LogInputMsg $_sig

	if { [ForceReset "after_internal_ho_req"] } {
		return
	}

	set cell_info [GetCellInfo [rd _sig cell_idfr]]
	set lac [lindex $cell_info 0]
	set ci [lindex $cell_info 1]
	DbSet $glBssapDb $glMsId LACTarget $lac
	DbSet $glBssapDb $glMsId CellIdTarget $ci
	logv1 "RcvInternalHovRequired: lac=$lac; ci=$ci"

	set targetBssScl [rd _sig codec_list]

	if { [IsVoid $targetBssScl] } {
		logv1 "RcvInternalHovRequired: WARNING: the target 'codec list Bss supported' IE, sent with Internal Handover Required, is void"
	} else {
		# store in the Bssap Db network side, the target codec list Bss supported
		DbSet $glBssapDb $glMsId AoipBscScl $targetBssScl
	}

	set tgtUpBssFromCodec [GetUpFromCodec $glMsId 0 $targetBssScl]
	if { $tgtUpBssFromCodec == "IP" || $tgtUpBssFromCodec == "MIXED" } {
		# see 3gpp-48008-960 Â§3.2.1.83 (this IE shall be included only if the codec list of the BssScl indicates an IP based UP interface)
		set aoipTla [rd _sig aoip_tla]
	} else {
		# in case UP of type TDM then this IE isn't present	
		set aoipTla ?
	}

	if { [IsEmpty $aoipTla] || [IsVoid $aoipTla] } {
		logv1 "RcvInternalHovRequired: aoip_tla is empty or void ... probably it isn't an IP based userplane interface"
		logv1 "RcvInternalHovRequired: case of INTERNAL_HOV of this type: IP -> TDM, MIXED -> TDM (TDM -> TDM is not allowed)"
	} else {
		# case TDM -> IP, MIXED -> IP, IP -> IP

		UPoIPcnGet $aoipTla ip_add port

		DbSet $glBssapDb $glMsId HoDestIp $ip_add
		DbSet $glBssapDb $glMsId HoDestPort $port
		logv1 "RcvInternalHovRequired: ip_add = $ip_add; port = $port"

		UPoIPcnSet aoipMgwAddr port callid

		DbSet $glBssapDb $glMsId HoLocalIp $aoipMgwAddr
		DbSet $glBssapDb $glMsId HoLocalPort $port
	}	


	logv1 "RcvInternalHovRequired: cause=[rd _sig cause]"

	if { [rd _sig cause] == 16 } {
		# 00010110: to see Alcatel document '0163_SFD_AUPoIP_02p1'
		logv1 "RcvInternalHovRequired: Response to an Internal Handover Enquiry message (cause=[rd _sig cause])"
	}

	IntHovRqrd_Handler
}

proc IntHovRqrd_Handler { } {

	global glBssapDb glMsId glMsDb

	#-- target
	# Speech Code List-BSS Supported
	set targetBssScl [DbGet $glBssapDb $glMsId AoipBscScl]
	logv1 "IntHovRqrd_Handler: BSS_Target_spch_codec_list=$targetBssScl"; #cDEBUG
	# Target Codec Type (second nibble of the first octet of "Speech Code List-BSS Supported")

	#-- serving
	# Serving Speech Version
	set spch_version [DbGet $glBssapDb $glMsId SpeechVer]
	# Serving Speech Codec (in particular the codec type is the second nibble of the first octet of the 'Speech Codec Element' IE)
	set spch_codec [DbGet $glBssapDb $glMsId SpeechCodec]
	# Serving UserPlane Type
	set source_uptype [UP_Discriminator $spch_codec]
	DbSet $glBssapDb $glMsId ServingUpType $source_uptype

	logv1 "IntHovRqrd_Handler: serving_spch_version=$spch_version; serving_spch_codec=$spch_codec; serving_UpType=$source_uptype"

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]

	if {[IsVoid $targetBssScl]} {
		logv1 "IntHovRqrd_Handler: WARNING: because the field 'Codec List Bss Supported' received from the BSC with the 'Internal Handover Required' is void --> the MSC will send to the BSC an 'Internal Handover Required Reject' with cause equal to 00"
		set cause_value 00	
		SendIntHovRqdRej $cause_value
		return
	}

	if { [DbFieldExists $glMsDb AoipTargetSpeechCodec] } {
		set targetMscSpeech_ver   0x[hocts [DbGet $glMsDb $glMsId AoipTargetSpeechCodec] 0 0]
		logv1 "IntHovRqrd_Handler: targetMscSpeech_ver=$targetMscSpeech_ver"; #cDEBUG
		set targetMscCodec 		  [expr {$targetMscSpeech_ver & 0x0f}]
	} else {
		logv1 "IntHovRqrd_Handler: WARNING: the 'AoipTargetSpeechCodec' field doesn't exist in the $glMsDb"
		set targetMscCodec ?
	}
	logv1 "IntHovRqrd_Handler: targetMscCodec=$targetMscCodec"

	# target codec list MSC preferred includes at least one target codec list BSS supported
	set tgtUpMscFromCodec [GetUpFromCodec $glMsId AoipTargetMscPcl]
	set tgtUpBssFromCodec [GetUpFromCodec $glMsId 0 $targetBssScl]

	set tgtMscPcl [DbGet $glMsDb $glMsId AoipTargetMscPcl]
	logv1 "IntHovRqrd_Handler: All Target UP that MSC supports ($tgtUpMscFromCodec) with tgtMscPcl=$tgtMscPcl"

	set targetUp [FirstCodecBssSclIncludedInMscPcl $targetBssScl $tgtMscPcl tgtMscCodec codecType]
	if { $targetUp == "IP" || $targetUp == "TDM" } { 
		set target_uptype $targetUp
	} else {
		set target_uptype $tgtUpBssFromCodec
	}
	logv1 "IntHovRqrd_Handler: target_uptype=$target_uptype; tgtMscCodec=$tgtMscCodec"

	DbSet $glBssapDb $glMsId TargetUpType $target_uptype
    DbSet $glBssapDb $glMsId HoSpeechCodec $tgtMscCodec

	if { [CodecSelectionByBsc] } {
	# case of codec selected by BSC
		if { ![IsVoid $targetMscCodec] && [MscPclIncludeBssScl AoipTargetMscPcl $targetBssScl] } {
			logv1 "entro qui 1"; #cDEBUG
			if { [CheckPossibility_IntHov_ByUpTypes $source_uptype $target_uptype] } {
				logv1 "entro qui 2"; #cDEBUG
				# target A-interface type is available

				#@@@ Carlo 17/11/2011 workaround to overcome the problem 'a small number of call drop in load test' --start--
				logv1 "DEBUG: ::glCcPid=$::glCcPid"
				if { [remcmd $::glCcPid "remCmdQueryReleaseSentOnCClayer $glMsId"] } {
					logv1 "IntHovRqrd_Handler:WARNING:'RELEASE' for MsId=$glMsId already received on CC layer so 'INT_HO_RQRD' is skipped"
					return
					#logclose; #callback to close the log in load&stress test (to be used with the 'tmpipe' for the log).
				}
				#@@@ --end--

				if { [SendIntHovCmd $tgtMscPcl $target_uptype] == 0 } {
					logv1 "entro qui 2bis"; #cDEBUG
					return
				}
			} else {
				logv1 "entro qui 3"; #cDEBUG
				set cause_value 36; # "Requested A-Interface UP Type unavailable" (00110110): Alcatel document '0163_SFD_AUPoIP_02p1'
				SendIntHovRqdRej $cause_value
				return
			}
		} else {
			logv1 "entro qui 4"; #cDEBUG
			# target codec list MSC preferred doesn't include any target codec list BSS supported
			set cause_value 44; # "Requested Codec Type or Codec Configuration not supported" (01000100)
			SendIntHovRqdRej $cause_value
			return
		}
	} else {
	# standard case: codec selected from the MSC
		set mscPcl [DbGet $glBssapDb $glMsId AoipMscPcl]
		if { ![IsVoid $targetMscCodec] && [MscPclIncludeBssScl AoipTargetMscPcl $mscPcl] } {
			logv1 "entro qui 6"; #cDEBUG
			if { [CheckPossibility_IntHov_ByUpTypes $source_uptype $target_uptype] } {
				logv1 "entro qui 7"; #cDEBUG
				# target A-interface type is available
				if { [SendIntHovCmd $tgtMscPcl $target_uptype] == 0 } {
					return
				}
			} else {
				logv1 "entro qui 8"; #cDEBUG
				set cause_value 36; # "Requested A-Interface UP Type unavailable" (00110110): Alcatel document '0163_SFD_AUPoIP_02p1'
				SendIntHovRqdRej $cause_value
				return
			}
		} else {
			logv1 "entro qui 9"; #cDEBUG
			# target codec list MSC preferred doesn't include any target codec list BSS supported
			set cause_value 44; # "Requested Codec Type or Codec Configuration not supported" (01000100)
			SendIntHovRqdRej $cause_value
			return
		}
	}

	if { [ForceReset "after_internal_ho_command"] } {
		return
	}

	nextstate _c_WaitForIntHovProcCompleted
}

proc SendIntHovCmd { tgtMscCodecList tgtMscUpType } {

	global glMsId glBssapDb

	# Speech Code List-BSS Supported
	set targetBssScl [DbGet $glBssapDb $glMsId AoipBscScl]
	log "*******************************************************************************************************"
	logv1 "SendIntHovCmd: targetBssScl=$targetBssScl; tgtMscCodecList=$tgtMscCodecList"
	logv1 " ******* --> tgtMscUpType=$tgtMscUpType ********"
	log "*******************************************************************************************************"

	set lac_tgt [DbGet $glBssapDb $glMsId LACTarget]
	logv1 "SendIntHovCmd: lac_tgt=$lac_tgt"; #cDEBUG
	set ci_tgt  [DbGet $glBssapDb $glMsId CellIdTarget]
	logv1 "SendIntHovCmd: ci_tgt=$ci_tgt"; #cDEBUG

	set bsc_tgt [GetBscIdByCellIdfr $lac_tgt $ci_tgt ::glBtsDb]
	logv1 "SendIntHovCmd: bsc_tgt=$bsc_tgt"; #cDEBUG

	# Channel Type
	set spi		[DbGet $glBssapDb $glMsId Spi]
	set ch_rate	[DbGet $glBssapDb $glMsId ChannelRate]
	set datarate	[DbGet $glBssapDb $glMsId DataRate]

	# TMA-443 (point 2)
	set tgtUp [DbGet $glBssapDb $glMsId TargetUpType]
	if { [IsVoid $tgtUp] || [IsEmpty $tgtUp] } {
		# funzione che ricerca qual'Ã¨ il primo codec in BssScl che Ã¨ presente pure in MscPcl
		set targetUp [FirstCodecBssSclIncludedInMscPcl $targetBssScl $tgtMscCodecList tgtMscCodec codecType]
		DbSet $glBssapDb $glMsId TargetUpType $targetUp
		DbSet $glBssapDb $glMsId HoSpeechCodec $tgtMscCodec
		logv1 "targetUp=$targetUp (tgtMscCodec=$tgtMscCodec); (codecType=$codecType)"
	} else {
		set targetUp 		$tgtUp
		set tgtMscCodec		[DbGet $glBssapDb $glMsId HoSpeechCodec]
	}

	if { ![IsEmpty $targetUp] && ![IsVoid $targetUp] } {
		if { ![IsEmpty $tgtMscCodec] && ![IsVoid $tgtMscCodec] } {
			logv1 "SendIntHovCmd: tgtMscCodec=$tgtMscCodec"; #cDEBUG
		} else {
			logv1 "SendIntHovCmd: WARNING: Target selected msc codec ($tgtMscCodec) doesn't include the target codec list BSS supported"
			set cause_value 44; # "Requested Codec Type or Codec Configuration not supported" (01000100)
			SendIntHovRqdRej $cause_value
			return
		}
	} else {
		logv1 "SendIntHovCmd: WARNING: target userplane ($targetUp) of the selected msc doesn't support the UP type requested by bss"
		set cause_value 36; # "Requested A-Interface UP Type unavailable" (00110110)
		SendIntHovRqdRej $cause_value
		return
	}

	logv1 "SendIntHovCmd: tgtMscUpType=$tgtMscUpType"

	if { [string equal $tgtMscUpType "TDM"] } {
		# TDM based UP interface
		logv1 "(glMsId=$glMsId): current UP type=xxxxx --> $tgtMscUpType"
		if { ![isSplitted] } {
			GetTrfCic $bsc_tgt cic_tgt fail cicExt 0 permSpeechIndex
			logv1 "SendIntHovCmd: cic_tgt=$cic_tgt"; #cDEBUG
			set circ_idty_code [ustoh $cic_tgt B]
			logv1 "SendIntHovCmd: circ_idty_code=$circ_idty_code"; #cDEBUG

			new INTERNAL_HO_CMD s
			wr s cic $circ_idty_code
      		wr s speech_codec $tgtMscCodec
		} else {
			# MULTIPROCESS (TDM)
			SendCicAsgReq $spi $ch_rate $bsc_tgt $datarate
		
			nextstate WaitForIpTdmAsgRes_IntHovCmd
			return 0
		}
	} elseif { [string equal $tgtMscUpType "IP"] || [string equal $tgtMscUpType "MIXED"] } {
		# check if IP or MIXED is allowed
		set upSupportedFromCodec [UpSupportedFromCodec $tgtMscCodec]
		if { $upSupportedFromCodec } {
			if { [isSplitted] } {
				# MULTIPROCESS (MIXED OR IP)
				if { [string equal $tgtMscUpType "IP"] } {
					SendTlaAsgReq $bsc_tgt
				} elseif { [string equal $tgtMscUpType "MIXED"] } {
					if { $upSupportedFromCodec == 11  } {
						# mixed
						SendCicAsgReq $spi $ch_rate $bsc_tgt $datarate
						SendTlaAsgReq $bsc_tgt
					} elseif { $upSupportedFromCodec == 12 } {
						# ip
						SendTlaAsgReq $bsc_tgt
					} elseif { $upSupportedFromCodec == 10 } {
						# tdm
						SendCicAsgReq $spi $ch_rate $bsc_tgt $datarate
					}
					DbSet $glBssapDb $glMsId TargetUpType $upSupportedFromCodec
				}
				nextstate WaitForIpTdmAsgRes_IntHovCmd
				return 0
			} else {
				new INTERNAL_HO_CMD s
				wr s speech_codec $tgtMscCodec
				# IP based UP interface
				wr s aoip_tla [GetAUPoIPContainer [DbGet $glBssapDb $glMsId HoLocalIp] [DbGet $glBssapDb $glMsId HoLocalPort]]

				if { [string equal $tgtMscUpType "MIXED"] } {
					GetTrfCic $bsc_tgt cic_tgt fail cicExt 0 permSpeechIndex
					logv1 "SendIntHovCmd: cic_tgt=$cic_tgt"; #cDEBUG
					set circ_idty_code [ustoh $cic_tgt B]
					logv1 "SendIntHovCmd: circ_idty_code=$circ_idty_code"; #cDEBUG

					wr s cic $circ_idty_code
				}
			}
		} else {
			logv1 "SendIntHovCmd: target selected msc codec doesn't support the IP or MIXED UserPlane requested"
			set cause_value 36; # "Requested A-Interface UP Type unavailable" (00110110)
			SendIntHovRqdRej $cause_value
			return
		}

		# Source Speech Codec (in particular the codec type is the second nibble of the first octet of the 'Speech Codec Element' IE)
        set spch_codec [DbGet $glBssapDb $glMsId SpeechCodec]
        # Source UserPlane Type
        set srvMscUpType [UP_Discriminator $spch_codec]

        logv1 "SendIntHovCmd: current UP type=$srvMscUpType  --  (current Speech Codec=$spch_codec)"; #cDEBUG
		logv1 "(glMsId=$glMsId) case: $srvMscUpType --> $tgtMscUpType"

		if { ![string equal $tgtMscUpType $srvMscUpType] && [string equal $srvMscUpType "TDM"] } {
			# TDM --> IP/MIXED (only in this case is present the 'Call identifier' IE)
			set callid [GetAUPoIPCallId]
			wr s call_id $callid
		} else {
			# All other cases
			logv1 "SendIntHovCmd: case different from 'TDM --> IP/MIXED' therefore 'Call identifier' IE isn't present in INTERNAL_HO_CMD"
		}
	} else {
		logv1 "SendIntHovCmd: ERROR: no possible UserPlane (TDM or IP) is set !"
		abort
	}

    DbSet $glBssapDb $glMsId HoSpeechCodec $tgtMscCodec

	LogOutputMsg $s
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

proc SendIntHovRqdRej { cause } {

	global glMsId glBssapDb

	new INTERNAL_HO_RQD_REJ s
	wr s cause $cause
	LogOutputMsg $s
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

proc RcvRejectIntHovEnquiry { } {

	global _sig

	if { [rd _sig cause] == 17 } {
		# 00010111: to see Alcatel document '0163_SFD_AUPoIP_02p1'
		logv1 "RcvRejectIntHovEnquiry: Internal Handover Enquiry reject"
		RcvIntHovFail
	} else {
		logv1 "RcvRejectIntHovEnquiry: the HOV FAILURE received in this state isn't in response to an Internal Handover Enquiry message"
		skipMsg
	}
}

proc RcvIntHovFail { } {

	global _sig glAoip glBssapDb glMsId
	
	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	if { $glAoip && $upType } {
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		DbSet $glBssapDb $glMsId HoSpeechVer "?"
		DbSet $glBssapDb $glMsId HoSpeechCodec "?"
		DbSet $glBssapDb $glMsId HoDestIp "?"
		DbSet $glBssapDb $glMsId HoDestPort "?"
		DbSet $glBssapDb $glMsId HoLocalIp "?"
		DbSet $glBssapDb $glMsId HoLocalPort "?"
	}

	nextstate BssapConnectActive

	DequeueApDataReq
}

proc RcvIntHovCmplt { } {

	global _sig glAoip glBssapDb glMsId

	LogInputMsg $_sig

	logv1 "RcvIntHovCmplt: bss_codec=[rd _sig speech_codec]; bss_codec_list=[rd _sig codec_list]"; #cDEBUG

	set HoSpeechCodec [rd _sig speech_codec]
	set SourceSpeechCodec [DbGet $glBssapDb $glMsId SpeechCodec]

	set source_uptype [UP_Discriminator $SourceSpeechCodec]
	logv1 "RcvIntHovCmplt: SourceSpeechCodec=$SourceSpeechCodec --> source_uptype=$source_uptype"

	set target_uptype [UP_Discriminator $HoSpeechCodec]
	logv1 "RcvIntHovCmplt: TargetSpeechCodec=$HoSpeechCodec --> target_uptype=$target_uptype"

	# Switch Resources Procedure
	if { $glAoip } {
		if { $source_uptype == "IP" &&  $target_uptype == "IP" } {
			logv1	"RcvIntHovCmplt: IP -> IP, nothing to do"
			nextstate BssapConnectActive
		} elseif { $source_uptype == "IP" &&  $target_uptype == "TDM"  } {
			# clear IP Procedure
			DbSet $glBssapDb $glMsId SpeechVer [DbGet $glBssapDb $glMsId HoSpeechVer]
			DbSet $glBssapDb $glMsId SpeechCodec [DbGet $glBssapDb $glMsId HoSpeechCodec]
			if { [IpUpSupported] } {
				ClearResources $glMsId
			}
			# set CIC
			DbSet $glBssapDb $glMsId CicExt [DbGet $glBssapDb $glMsId CicExtTarget]
			DbSet $glBssapDb $glMsId LAC [DbGet $glBssapDb $glMsId LACTarget]
			DbSet $glBssapDb $glMsId CellId [DbGet $glBssapDb $glMsId CellIdTarget]
			DbSet $glBssapDb $glMsId LACTarget "?"
			DbSet $glBssapDb $glMsId CellIdTarget "?"
			DbSet $glBssapDb $glMsId UpType 0
			nextstate BssapConnectActive
		} elseif { $source_uptype == "TDM" &&  $target_uptype == "IP" } {
			# release CIC
			 ReleaseExtCic $glMsId "CicExt"
			 DbSet $glBssapDb $glMsId Cic "?"
			 DbSet $glBssapDb $glMsId CicExt "?"
			# activate IP
			set hoLocalIp 	[DbGet $glBssapDb $glMsId HoLocalIp]
			set hoLocalPort [DbGet $glBssapDb $glMsId HoLocalPort]			

		 	DbSet $glBssapDb $glMsId LocalIp $hoLocalIp
			DbSet $glBssapDb $glMsId LocalPort $hoLocalPort
			
			if { ![DbKeyExists $glBssapDb IpAddPort $hoLocalIp-$hoLocalPort] } {
				# memorizzo nel BssapDb dello slave
				logv1 "RcvIntHovCmplt: ATTENZIONE: strano non dovrebbe entrare qui! ..."
				DbSet $glBssapDb $glMsId IpAddPort $hoLocalIp-$hoLocalPort
			} else {
				#TMA-484
				if { [DbGetIdx $glBssapDb IpAddPort $hoLocalIp-$hoLocalPort] != $glMsId } {
					logv1 "RcvIntHovCmplt: ERROR: IpAddPort=$hoLocalIp-$hoLocalPort already exists in BssapDb \															for the MsId:[DbGetIdx $glBssapDb IpAddPort $hoLocalIp-$hoLocalPort]"
				}
			}

			DbSet $glBssapDb $glMsId DestIp [DbGet $glBssapDb $glMsId HoDestIp]
			DbSet $glBssapDb $glMsId DestPort [DbGet $glBssapDb $glMsId HoDestPort]
			DbSet $glBssapDb $glMsId SpeechVer [DbGet $glBssapDb $glMsId HoSpeechVer]
			DbSet $glBssapDb $glMsId SpeechCodec [DbGet $glBssapDb $glMsId HoSpeechCodec]
			DbSet $glBssapDb $glMsId UpType 2
			if { [IpUpSupported] } {
				ActivateAoipResources $hoLocalIp $hoLocalPort \
					[DbGet $glBssapDb $glMsId HoDestIp] [DbGet $glBssapDb $glMsId HoDestPort]
		  		nextstate WaitRtpOpenAckIntHo
			} else {
				nextstate BssapConnectActive
			}
		} elseif { $source_uptype == "TDM" &&  $target_uptype == "TDM" } {
			logscr "TDM->TDM is not allowed"
		} else {
			logscr "RcvIntHovCmplt: other UP types (for e.g. MIXED) aren't handled"
		}
	} else {
		logv1 "RcvIntHovCmplt: (glAoip=$glAoip): case with signalling over TDM"
	}
}

proc SendIntHovEnquiry { } {
 
	global glMsDb glMsId glBssapDb

	logv1 "SendIntHovEnquiry: glMsId=$glMsId"; #cDEBUG

	if { ![DbFieldExists $glMsDb AoipTargetSpeechCodec] || ![DbFieldExists $glMsDb AoipTargetMscPcl] } {
		logv1 "SendIntHovEnquiry: 'AoipTargetSpeechCodec' or 'AoipTargetMscPcl' doesn't exist in the $glMsDb"
	} else {
		#set tgtMscPcl [DbGet $glMsDb $glMsId AoipTargetSpeechCodec]; # ??? Carlo: TODO check
		set tgtMscPcl [DbGet $glMsDb $glMsId AoipTargetMscPcl]

		set targetUpFromCodec [GetUpFromCodec $glMsId AoipTargetMscPcl]
		logv1 "SendIntHovEnquiry: targetUpFromCodec=$targetUpFromCodec"

		set servingUpType [DbGet $glBssapDb $glMsId UpType]

		if { ![IsVoid $tgtMscPcl] && ![IsVoid $targetUpFromCodec] &&\
			 $targetUpFromCodec == "IP" || $targetUpFromCodec == "MIXED" || $targetUpFromCodec == "TDM" && $servingUpType != 0 } {
			# Carlo workaround 12/09/2011: caso TDM -> IP deve essere possibile (solo caso TDM -> TDM non e' possibile)
			logv1 "SendIntHovEnquiry: ENTER"

			set targetSpeechCodec [GetFirstSpeechCodecFromCodecList $tgtMscPcl]
			if { ![IsVoid $targetSpeechCodec] } {
				# Internal Handover Enquiry
				new INTERNAL_HO_ENQ s
				wr s speech_codec $targetSpeechCodec

				LogOutputMsg $s
				set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
				SendSccpNDataReq $spcstkidcid $s
			} else {
				logv1 "SendIntHovEnquiry: WARNING: speech codec not available"
			}
		} else {
			logv1 "SendIntHovEnquiry: the requested A-Interface Type is not 'IP'"
		}
	}
}

#------------------------------------------------------------#
# 3.1.8 "Handover Candidate Enquiry" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.9 "Release of Radio Resource and Terrestrial Resource" 
#        procedure functions
#------------------------------------------------------------#

proc RcvClrReqHovFailed { } {

	global _sig glBssapDb glMsId glTarget

	LogInputMsg $_sig

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause [rd _sig cause]

	if { [info exists glTarget] } {
		# Sending Clear Command to Target
		SendClrCmdTarget [list $prot_disc $trans_id $cause]
		nextstate _c_WaitForHovProcCompleted
		DequeueApDataReq
	} else {
		# Sending Clear Command
		SendClrCmd [list $prot_disc $trans_id $cause]
		# Sending Clear Command to Target
		SendClrCmdTarget [list $prot_disc $trans_id $cause]
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		nextstate DuringExternalHov
	}
}

proc RcvClrReqHovCompleted { } {

	global _sig glBssapDb glMsId glTarget

	LogInputMsg $_sig

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause [rd _sig cause]

	if { [info exists glTarget] } {
		# Sending Clear Command to Target
		SendClrCmdTarget [list $prot_disc $trans_id $cause]
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		# Check if Serving was already Released
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		if { ![IsVoid $spcstkidcid] } {
			nextstate DuringExternalHov
		} else {
			# Switch Target Connection into Serving
			BssapMovInst $glMsId
			nextstate WaitForClrCmplt
		}
	} else {
		log "[lindex $_sig 0] Discarded, waiting for CLR_CMPLT"
	}	
}

proc RcvClrReq { } {

	global _sig glBssapDb glMsId glTarget

	LogInputMsg $_sig

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause [rd _sig cause]

	if { [info exists glTarget] } {
		# Sending Clear Command to Target
		SendClrCmdTarget [list $prot_disc $trans_id $cause]
		nextstate WaitForHovProcFailed 
	} else {
		# Sending Clear Command
		SendClrCmd [list $prot_disc $trans_id $cause]
		nextstate _c_WaitForHovProcComplTgtOnly
	}
}

proc RcvClrReqServing { {causeVal ?} {spcStkidCid ?} } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	
	if { ![IsVoid $causeVal] } {
		set cause $causeVal
	} else {
		set cause [rd _sig cause]
	}
	
	if { [ForceReset "after_clear_request"] } {
		return
	}

	if { [ForceNoAnswer] } {
		return
	}

	if { $::glAoip && ![IsEmpty $spcStkidCid] && ![IsVoid $spcStkidCid] } {
		# used in case of RESET_CIRCUIT
		SendClrCmdSpcStkIdCid $spcStkidCid [list 6 0 $cause]
	} else {
		# Sending Clear Command in standard case
		SendClrCmd [list $prot_disc $trans_id $cause]
	}

	# Stop Timer T_CIPHR (if it's running)
	set tid [DbGet $glBssapDb $glMsId T_CIPHRid]
	if { ![IsVoid $tid] && [tmrrunning $tid] } {
		tmrstop $tid
	}

	# Send Release Ind to MM
	set cause "Normal_Event"
	SendApRelInd $cause

	nextstate WaitForClrCmplt
}

proc RcvClrReqClrCmplt { } {

	global _sig

	LogInputMsg $_sig

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause [rd _sig cause]

	# Sending Clear Command
	SendClrCmd [list $prot_disc $trans_id $cause]
}

proc SendClrCmd { params } {

	global glBssapDb glMsId

	set prot_disc [lindex $params 0]
	set trans_id [lindex $params 1]
	set cause [lindex $params 2]

	set L3_Hdr_Info [uctoh $prot_disc]
	append L3_Hdr_Info [uctoh $trans_id]

	new CLR_CMD s
	wr s l3_hdr_info $L3_Hdr_Info
	wr s cause $cause
	
	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	log "SendClrCmd: spcstkidcid=$spcstkidcid"
	SendSccpNDataReq $spcstkidcid $s

	StartClrCmplteTimer $spcstkidcid
		
	# Reset LCS State	
	DbSet $glBssapDb $glMsId LcsState 0
}

proc SendClrCmdSpcStkIdCid { spcstkidcid params } {

	global glBssapDb glMsId

	set prot_disc [lindex $params 0]
	set trans_id [lindex $params 1]
	set cause [lindex $params 2]

	set L3_Hdr_Info [uctoh $prot_disc]
	append L3_Hdr_Info [uctoh $trans_id]

	new CLR_CMD s
	wr s l3_hdr_info $L3_Hdr_Info
	wr s cause $cause
	
	LogOutputMsg $s

	log "SendClrCmdSpcStkIdCid: spcstkidcid=$spcstkidcid"
	SendSccpNDataReq $spcstkidcid $s

	StartClrCmplteTimer $spcstkidcid
}

proc SendClrCmdTarget { params } {

	global glBssapDb glMsId

	set prot_disc [lindex $params 0]
	set trans_id [lindex $params 1]
	set cause [lindex $params 2]

	set L3_Hdr_Info [uctoh $prot_disc]
	append L3_Hdr_Info [uctoh $trans_id]

	new CLR_CMD s
	wr s l3_hdr_info $L3_Hdr_Info
	wr s cause $cause
	
	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
	if { ![IsVoid $spcstkidcid] } {
		SendSccpNDataReq $spcstkidcid $s

		StartClrCmplteTimer $spcstkidcid
	} else {
		logscr "SendClrCmdTarget: Error the SpcStkIdCidTarget is empty!"
	}
}

proc ReleaseExtCic { msId cicType } {

	global glBssapDb

	set cic_ext [DbGet $glBssapDb $msId $cicType]
	set cic [GetCicByExtCic $cic_ext]
	set bscId [GetBscIdByExtCic $cic_ext]
	if { ![IsVoid $cic] } {
		logv4 "ReleaseExtCic: releasing cic=$cic on the bscId=$bscId about the msId=$msId"
		if { ![isSplitted] } {
			cicRelease $bscId $cic
		} else {
			SendCicReleaseToMaster $bscId $msId $cic
		}
		DbSet $glBssapDb $msId $cicType "?"

		if { $cicType == "CicExt" } {
			DbSet $glBssapDb $msId Cic "?"
		} elseif { $cicType == "Cic" } {
			DbSet $glBssapDb $msId CicExt "?"
		} else {
			logv0 "ERROR"
		}
	} else {
		logv4 "ReleaseExtCic: cic void"
		set Cic [DbGet $glBssapDb $msId Cic]
		if { ![IsVoid $Cic] } {
			set BscId [DbGet $glBssapDb $msId BscId]
			logv4 "ReleaseExtCic: Releasing Cic=$Cic on the BscId=$BscId regarding the msId=$msId"
			if { ![isSplitted] } {
				cicRelease $BscId $Cic
			} else {
				SendCicReleaseToMaster $BscId $msId $Cic
			}
			DbSet $glBssapDb $msId Cic "?"
			DbSet $glBssapDb $msId CicExt "?"
		}
	}
}

proc ReleaseCic { msid dbname cicType } {

	# Reset Traffic Resource
	set cic [DbGet $dbname $msid $cicType] 
	if { ![IsVoid $cic] } {
		# CICEXT
		#cicRelease $cic
		global glBssapDb glMsId
		set spcStkIdCid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		set spc [lindex [split $spcStkIdCid -] 1]
		CicReleaseExt $cic $spc
		
		DbSet $dbname $msid $cicType "?"
		log "ReleaseCic: Releasing Cic $cic"
	} else {
		log "ReleaseCic: cic empty"
	}
}

proc RcvClrCmplt { } {

	global _sig glBssapDb glMsId glTarget glAoip

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]

		set spch_codec 		[DbGet $glBssapDb $glMsId SpeechCodec]
		if { ![IsVoid $spch_codec] } {
			set source_uptype 	[UP_Discriminator $spch_codec]
			set target_uptype 	[DbGet $glBssapDb $glMsId TargetUpType]
			log "-----------"
			log "RcvClrCmplt: source_uptype=$source_uptype --> target_uptype=$target_uptype"
			log "-----------"
		} else {
			if { [IpUpSupported] == 0 } {
				log "RcvClrCmplt: UserPlane Disabled"		
				set source_uptype ?
				set target_uptype ?
			} else {
				# in this time no parameters regarding userplane type are stored in BssapDb
				log "RcvClrCmplt: BSSAP stack initialization"
				set source_uptype ?
				set target_uptype ?
			}
		}
	}

	# Target or Serving
	if { [info exists glTarget] } {
		log "RcvClrCmplt: target"
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]

		StopClrCmplteTimerByLink $spcstkidcid

		# Reset Target Connection
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		# Reset Target Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"

		#Carlo : 02/12/2011: l'estensione (|| $source_uptype == "TDM" || $target_uptype == "TDM") NON Ã¨ stata testata da me	
		if { !$glAoip || $upType == 0 || $source_uptype == "TDM" || $target_uptype == "TDM" } {
			# Target Traffic Resource
			#ReleaseCic $glMsId $glBssapDb "CicTarget"
			ReleaseExtCic $glMsId "CicExtTarget"
		}

		# Release Target
		SendSccpNDisconnectReq $glTarget "?"
	} else {
		log "RcvClrCmplt: serving"
		# Stop Timer Paging (T_PAG)
		#tmrstop [DbGet $glBssapDb $glMsId T_PAGid]

		if { !$glAoip || ![IsVoid $upType] && $upType == 0 || $source_uptype == "TDM" || $target_uptype == "TDM" } {
			# Serving Traffic Resource
			#ReleaseCic $glMsId $glBssapDb "Cic"
			ReleaseExtCic $glMsId "CicExt"
			DisconnectResources $glMsId $glBssapDb
		}
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		StopClrCmplteTimerByLink $spcstkidcid

		SendSccpNDisconnectReq $spcstkidcid "?"

		if { [DbGet $glBssapDb $glMsId DoubleClear]==1 } {
			SendClrCmdTarget [list 6 0 21]
		}

		# Reset Serving Connection
		BssapMovInst $glMsId

		#TMA-356 ---- #
		set dstId [DbGet $glBssapDb $glMsId DestId]
		# Check if it is A-Flex
		if { ![IsVoid $dstId] } {
			# SpcStkIdCid of the Destination mobile
			set spcstkidcid_dest [DbGet $glBssapDb $dstId SpcStkIdCid]
			if { [IsVoid $spcstkidcid_dest] } {
				# Reset Served Instance if no target
				log "RcvClrCmplt: resetting served instance in case of A-Flex"
				DbSet $glBssapDb $dstId CicConnection "?"
				DbSet $glBssapDb $dstId PcmType "?"
				DbSet $glBssapDb $dstId Stm1Line "?"
				DbSet $glBssapDb $dstId LsuPcm "?"
				DbSet $glBssapDb $dstId Ts "?"
				DbSet $glBssapDb $dstId TstmIndex "?"
				DbSet $glBssapDb $dstId BscId "?"
				DbSet $glBssapDb $dstId DestId "?"
			} else {
				log "RcvClrCmplt: WARNING: Served Instance is target"; #cDEBUG
			}
		} else {
			log "RcvClrCmplt: No A-Flex case then No Reset Served Instance"; #cDEBUG
		}
	}

	if { ![IsVoid [DbGet $glBssapDb $glMsId PpuId]] && ![IsVoid [DbGet $glBssapDb $glMsId CallId]] } {
		# IP resource exists for the glMsId
		ReleaseTla

		#----- bug fixing Carlo 29/11/2011 -- up mixed; case multiprocess -----#
		DbSet $glBssapDb $glMsId LocalIp ?
		DbSet $glBssapDb $glMsId LocalPort ?
		DbSet $glBssapDb $glMsId CallId ?
		DbSet $glBssapDb $glMsId IpAddPort ?
		logv1 "RcvClrCmplt: released ip resources about glMsId=$glMsId:"
		log "--> LocalIp=[DbGet $glBssapDb $glMsId LocalIp]"
		log "--> LocalPort=[DbGet $glBssapDb $glMsId LocalPort]"
		logv1 "==> IpAddPort=[DbGet $glBssapDb $glMsId IpAddPort]"
		logv1 "--> CallId=[DbGet $glBssapDb $glMsId CallId]"
		#----- .......................................................... -----#

	} else {
		# doesn't exist IP resource for the glMsId
		Trace "log" $::__trace_AUoIP "RcvClrCmplt" "PpuId=[DbGet $::glBssapDb $glMsId PpuId]; CallId=[DbGet $::glBssapDb $glMsId CallId]"
	}

	#Carlo workaround -- 14/09/2011 --
	if { $glAoip && [CodecSelectionByBsc] } {

		log "RcvClrCmplt: restore initial value of the UserPlane Type for the glMsId=$glMsId"
		log "InitMscUpType=[DbGet $glBssapDb $glMsId InitMscUpType]"
		log "ActualMscUpType=[DbGet $glBssapDb $glMsId UpType]"

		set initMscUpType [DbGet $glBssapDb $glMsId InitMscUpType]
		if { ![IsVoid $initMscUpType] } {
			# restore the initial value of the UserPlane Type (copied from the MsDb)
			DbSet $glBssapDb $glMsId UpType $initMscUpType 

			log "########################################################################"
			log "RcvClrCmplt: ATTENTION --> upType RESTORED in BssapDb for glMsId=$glMsId"
			log "########################################################################"
		}

		log "RestoredMscUpType=[DbGet $glBssapDb $glMsId UpType]"
	}
	# ----	

	if { [DbGet $glBssapDb $glMsId DoubleClear]==1 } {
		nextstate WaitForClrCmplt
		DbSet $glBssapDb $glMsId DoubleClear "?"
	} else {
		nextstate BssapIdle
	}
}

proc RcvClrCmpltDuringHov { } {

	global _sig glBssapDb glMsId glTarget glAoip

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]

		StopClrCmplteTimerByLink $spcstkidcid

		# Reset Target Connection
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		# Reset Target Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Target Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "CicTarget"
			ReleaseExtCic $glMsId "CicExtTarget"
		}	
		# TMA-240
		# Release Target
		SendSccpNDisconnectReq $glTarget "?"
	} else {

		if { !$glAoip || $upType == 0 } {
			# Serving Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "Cic"
			ReleaseExtCic $glMsId "CicExt"
			# TMA-240
	        DisconnectResources $glMsId $glBssapDb
        }
		# Release Serving Connection
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		StopClrCmplteTimerByLink $spcstkidcid

		SendSccpNDisconnectReq $spcstkidcid "?"
		# Switch Target Connection into Serving
		BssapMovInst $glMsId
	}

	if { ![IsVoid [DbGet $::glBssapDb $glMsId PpuId]] && ![IsVoid [DbGet $::glBssapDb $glMsId CallId]] } {
		ReleaseTla

		# ----------------------------------------------- #
	# new management ***start***
		# Carlo 28/12/2011: TODO controllare se qui Ã¨ corretto il settaggio a ? del CallId, del LocalIp e del LocalPort
		# come negli altri casi dove c'Ã¨ la chiamata alla ReleaseTla

		DbSet $glBssapDb $glMsId LocalIp ?
		DbSet $glBssapDb $glMsId LocalPort ?
		DbSet $glBssapDb $glMsId CallId ?
		DbSet $glBssapDb $glMsId IpAddPort ?
		logv1 "RcvClrCmpltDuringHov: released ip resources about glMsId=$glMsId:"
		log "--> LocalIp=[DbGet $glBssapDb $glMsId LocalIp]"
		log "--> LocalPort=[DbGet $glBssapDb $glMsId LocalPort]"
		logv1 "==> IpAddPort=[DbGet $glBssapDb $glMsId IpAddPort]"
		log "--> CallId=[DbGet $glBssapDb $glMsId CallId]"
		# ----------------------------------------------- #

	} elseif { ![IsVoid [DbGet $::glBssapDb $glMsId PpuId]] } {
		log "RcvClrCmpltDuringHov: ATTENTION: PpuId is different from void but CallId is equal to void !!"
		
		if { ![isSplitted] } {
			if { [info exists ::__aoip_ppu_list] } {
				log "RcvClrCmpltDuringHov: Release active resource in case of single-processor"
				MultiPpuRelease
			} else {
				log "RcvClrCmpltDuringHov: variable __aoip_ppu_list doesn't exist --> Multi Ppu management not done"
			}
		} else {
			# multiprocess version ... TODO forse qui ci vorrebbe il rilascio tla ?
			log "RcvClrCmpltDuringHov:WARNING: ......... rilascio tla .. ?"
		}
	} elseif { ![IsVoid [DbGet $::glBssapDb $glMsId CallId]] } {
		log "RcvClrCmpltDuringHov: ATTENTION: CallId is different from void but PpuId is equal to void !!!"

		DbSet $glBssapDb $glMsId CallId ?
		log " --> CallId=[DbGet $glBssapDb $glMsId CallId]"
    # new management ***end***
		# ----------------------------------------------- #
	} else {
		# doesn't exist IP resource for the glMsId
		Trace "log" $::__trace_AUoIP "RcvClrCmpltDuringHov" "PpuId=[DbGet $::glBssapDb $glMsId PpuId]; CallId=[DbGet $::glBssapDb $glMsId CallId]"
	}

	#Carlo workaround -- 14/09/2011 --
	if { $glAoip && [CodecSelectionByBsc] } {
		set initMscUpType [DbGet $glBssapDb $glMsId InitMscUpType]
		if { ![IsVoid $initMscUpType] } {
			# restore the initial value of the UserPlane Type (copied from the MsDb)
			DbSet $glBssapDb $glMsId UpType $initMscUpType
			
			log "#################################################################################"
			log "RcvClrCmpltDuringHov: ATTENTION --> upType RESTORED in BssapDb for glMsId=$glMsId"
			log "#################################################################################"
		}
	}
	# ----	

	nextstate WaitForClrCmplt
}

proc RcvClrCmpltHovCompleted { } {

	global _sig glBssapDb glMsId glAoip

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	if { !$glAoip || $upType == 0 } {
		# Serving Traffic Resource
		# TMA-240
		#ReleaseCic $glMsId $glBssapDb "Cic"
		ReleaseExtCic $glMsId "CicExt"
	}

	# Release Serving Connection - if not already
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	if { ![IsVoid $spcstkidcid] } {

		StopClrCmplteTimerByLink $spcstkidcid

		SendSccpNDisconnectReq $spcstkidcid "?"
	}

	# Switch Target Connection into Serving
	BssapMovInst $glMsId

	nextstate BssapConnectActive	
}

proc RcvClrCmpltTgtOnly { } {

	global _sig glBssapDb glMsId glTarget glAoip

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {

		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
		StopClrCmplteTimerByLink $spcstkidcid

		# Reset Target Connection
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		# Reset Target Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Target Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "CicTarget"
			ReleaseExtCic $glMsId "CicExtTarget"
			# TMA-240
	        	DisconnectResources $glMsId $glBssapDb
        	}
		# Release Target
		SendSccpNDisconnectReq $glTarget "?"
		nextstate WaitForClrCmplt
	} else {
		if { !$glAoip || $upType == 0 } {
			# Serving Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "Cic"
			ReleaseExtCic $glMsId "CicExt"
			# TMA-240
	        DisconnectResources $glMsId $glBssapDb
        }
		# Release Serving Connection
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		SendSccpNDisconnectReq $spcstkidcid "?"
		StopClrCmplteTimerByLink $spcstkidcid
		# Partially Reset Serving Connection - completed with HOV_CMPLT
		DbSet $glBssapDb $glMsId SpcStkIdCid "?"
	}
}

proc RcvClrCmpltHovFailed { } {

	global _sig glBssapDb glMsId glTarget glAoip

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	if { !$glAoip || $upType == 0 } {
		# Target Traffic Resource
		# TMA-240
		#ReleaseCic $glMsId $glBssapDb "CicTarget"
		ReleaseExtCic $glMsId "CicExtTarget"
		# TMA-240
	}

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
	StopClrCmplteTimerByLink $spcstkidcid

	# Reset Target Connection
	DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
	# ResetTarget Cell Identification
	DbSet $glBssapDb $glMsId LACTarget "?"
	DbSet $glBssapDb $glMsId CellIdTarget "?"

	if { [info exists glTarget] } {
		# Release Target Connection
		SendSccpNDisconnectReq $glTarget "?"
	}

	nextstate BssapConnectActive
}

#------------------------------------------------------------#
# 3.1.10 "Paging" procedure functions
#------------------------------------------------------------#
proc SendPagingByLac { tmsi lac } {

	# Paging by LAC
	set cellidfr 05 
	append cellidfr $lac

	SendPaging $tmsi $cellidfr
}

proc SendPagingCGI { tmsi lac } {
	global glBssapDb glMsId __MCC __MNC

	# Paging by CGI
	set cellidfr 00
	append cellidfr [GetPLMN $__MCC $__MNC] 
	append cellidfr $lac
	set cellId [DbGet $glBssapDb $glMsId CellId]
	log "SendPagingCGI: cellId=$cellId"
	set cellId [ustoh $cellId B]
	append cellidfr $cellId

	SendPaging $tmsi $cellidfr
}

proc SendPagingToAllCells { tmsi } {

	global glBssapDb glMsId glBscDb

	# Page All Cells
	set cellidfr 06

	foreach idx [DbGetIndexList $glBscDb] {

		# Start TMA-238
		# Pagining only on Lac of the A
		set gslink [DbGet $glBscDb $idx GsLink]
		if { [IsVoid $gslink] || !$gslink } {
			DbSet $glBssapDb $glMsId Spc [DbGet $glBscDb $idx Opc] 
			DbSet $glBssapDb $glMsId StkId [DbGet $glBscDb $idx StkId]
			SendPaging $tmsi $cellidfr
		}
		# End TMA-238
	}
}

proc SendPaging { tmsi cellidfr } {
	
	global glMsDb glBssapDb glMsId glBscDb glBtsDb

	set imsi [DbGet $glMsDb $glMsId IMSI]

	log "SendPaging: glMsId=$glMsId; tmsi=$tmsi; cellidfr=$cellidfr"; #cDEBUG

	# Carlo 13/05/2010: PATCH to support MGW in A-Flex TDM (used in China Shangai) --start-- #
	#LogDb $glBscDb ; #cDEBUG
	foreach bscid [array names glBtsDb] {
		log "SendPaging: bscid=$bscid"
		#LogDb $glBtsDb($bscid)
	}
	set lac [DbGet $glBssapDb $glMsId LAC]
	set cellid [DbGet $glBssapDb $glMsId CellId]

	# Carlo 13/08/2010 PATCH for bug noticed in the log 0811 concerning TMA-379	-start-
	if { [IsVoid $lac] || [IsVoid $cellid] } {
		log "SendPaging: glMsId=$glMsId; lac=$lac; cellid=$cellid; bscid=$bscid"
		log "WARNING: LAC or/and CellId are void !"
	} else {
		set bscid [GetBscIdByCellIdfr $lac $cellid glBtsDb]
		if { $bscid == "-1" } {
			abort "BSC identity unknown (LAC=$lac, CellId=$cellid)"
		}
	}

	#TMA-400
	log "SendPaging: glMsId=$glMsId; bscid=$bscid"
	set dpc [DbGet $glBscDb $bscid Dpc]
	DbSet $glBssapDb $glMsId Dpc $dpc
	log "SendPaging: lac=$lac; cellid=$cellid; Spc_BSC=$dpc"
	
	# Carlo PATCH for bug when dpc is unknown (IP ACCESS 15/10/2010) -start-
    	if { [IsVoid $dpc] } {
        	logscr "DPC is void (dpc=$dpc)"
        	exit
    	}
	# Carlo TODO
	# attenzione va gestito il caso in cui il mobile tenta di fare una chiamata
	# ms fa LU in un tempo a
	# in un tempo b la rete va giu
	# in un tempo c il ms tenta di fare service req cioe di fare una chiamata --> va gestito questo caso per mobili reali
    	# 15/10/2010 -end-

	# -end- PATCH for bug noticed in the TMA-379
	# --end PATCH for MGW-- #

	new  	PAG s

	# IMSI
	wr      s imsi $imsi
	# TMSI
	wr      s tmsi $tmsi
	# Cell Identifier List 
	wr      s cell_idfr_list $cellidfr

	LogOutputMsg $s
	SendSccpNUnitdataReq $s

	# Carlo -begin SS management-
	# *SS-CFNRC* (simulo il No Paging Response)
	
	#LogDb $glMsDb ; #cDEBUG
	#log "SendPaging: glMsId=$glMsId"; #cDEBUG

	if { [DbFieldExists $glMsDb Call_Forwarding] && [DbGet $glMsDb $glMsId Call_Forwarding] == "CFNRC" } {
		log "SendPaging: [DbGet $glMsDb $glMsId Call_Forwarding] activated on mobile $glMsId"; #cDEBUG

		# Setto il numero di tentativi di Paging fatti a 3 (quindi non devo piu' fare tentativi di Paging)
		DbSet $glBssapDb $glMsId PagAttempts 0
		
		# No Paging Response of the mobile	
		T_PagExpired

	# @Carlo -end SS management-
	} else {
		# Start timer for Paging
		set tid [DbGet $glBssapDb $glMsId T_PAGid]
		if { [tmrtout $tid] != 0 } {
			tmrstart $tid
		}
	}
}

proc T_PagExpired { } {

	global _sig glBssapDb glMsId glPagAttempts

	LogInputMsg $_sig

	# Update PagAttempts
	set attempts [DbGet $glBssapDb $glMsId PagAttempts]
	incr attempts -1
	DbSet $glBssapDb $glMsId PagAttempts $attempts

	if { $attempts <= 0 } {
		# Send Release Ind to MM
		set cause "Timer Expired"
		SendApRelInd $cause
		# Restore PagAttempts
		DbSet $glBssapDb $glMsId PagAttempts $glPagAttempts
	} else {
		SendPagingToAllCells [DbGet $glBssapDb $glMsId TMSI]
	}
}

proc T_RestartTPAG { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Attempts is not decreased

	# Start timer for Paging
	set tid [DbGet $glBssapDb $glMsId T_PAGid]
	if { [tmrtout $tid] != 0 } {
		tmrstart $tid
	}
}

#------------------------------------------------------------#
# 3.1.11 "Trace Invocation" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.12 "Flow Control" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.13 "Classmark Handling" procedure functions
#------------------------------------------------------------#
proc SendClsmkReq { } {

	global glBssapDb glMsId

	new CLSMK_REQ s

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}

proc RcvClsmkUpd { } {

	global _sig glBssapDb glMsId 

	LogInputMsg $_sig

	DbSet $glBssapDb $glMsId ClassMark2 [rd _sig clsmk_info_2]
	DbSet $glBssapDb $glMsId ClassMark3 [rd _sig clsmk_info_3]
}

proc RcvClsmkUpdExtHov { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	DbSet $glBssapDb $glMsId ClassMark2 [rd _sig clsmk_info_2]
	DbSet $glBssapDb $glMsId ClassMark3 [rd _sig clsmk_info_3]

	# If "Classmark" procedure is embedded in "External Handover" procedure
	set hov_req [DbGet $glBssapDb $glMsId HovReq]
	if { ![IsVoid $hov_req] } {
		set res [SendHovRequest $hov_req]
	} else {
		log "RcvClsmkUpdExtHov: the field HovReq in the BssapDb is void!"
		set res 0
	}	

	if { $res } {
		log "RcvClsmkUpdExtHov: Handover failed res=$res"
		set rqrd [DbGet $glBssapDb $glMsId ResponseForHORequired]
		if { ![IsVoid $rqrd] } {
			# Send HO failure
			set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
			new HOV_RQRD_REJ s
			wr	s	cause	22 
			SendSccpNDataReq $spcstkidcid $s
		}
		
		nextstate BssapIdle
	}
}

#------------------------------------------------------------#
# 3.1.14 "Cipher Mode Control" procedure functions
#------------------------------------------------------------#
proc SendCphrModeCmd { encr_info cipher_rsp_mode } {
	
	global glBssapDb glMsId

	new CPHR_MODE_CMD s
	wr s encr_info $encr_info
	wr s cphr_rsp_mode [uctoh $cipher_rsp_mode]

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s

	# Start timer to wait CiphrModeCmplte
	set tid [DbGet $glBssapDb $glMsId T_CIPHRid]
	if { [tmrtout $tid] != 0 } {
		tmrstart $tid
	}

    nextstate WaitCphrCmplt
}

proc RcvCphrModeCmpl { } {
	
	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Sending BSSAP_AP_SYNC_CNF (cause: 0 = ciphering)
	set res 0
	SendApSyncCnf $res "?"

	# Sending Common Id
	## SendCommonId

	# Stop Timer T_CIPHR
	set tid [DbGet $glBssapDb $glMsId T_CIPHRid]
	if { ![IsVoid $tid] && [tmrrunning $tid] } {
		tmrstop $tid
	}

    nextstate BssapConnectActive
}

proc T_CiphrExpired { } {

	global glBssapDb glMsId glPagAttempts

	LogInputSig

	# Send Release Ind to MM and release BSSAP Tranaction
	OutOfSync
	 
	#nextstate BssapIdle
}

#------------------------------------------------------------#
# 3.1.15 "General SCCP Abnormal Conditions" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.16 "Initial MS Msg" procedure functions 
#------------------------------------------------------------#
proc RcvInitialMsMsg { } {

	global _sig _state glBssapPlmn glBssapDb glMsId 

	log "[lindex $_sig 0] Received in State $_state"

	# Get Parameters
	set l3pdu [rd _sig l3_info]
	set cell_info [GetCellInfo [rd _sig cell_idfr]]
	set lac [lindex $cell_info 0]
	set ci [lindex $cell_info 1]

	set hplmn $glBssapPlmn
	set vplmn [GetPlmnInfo [rd _sig cell_idfr]]

	if { $vplmn == $hplmn } {
		set lai $hplmn
		#log "RcvInitialMsMsg: HPLMN=VPLMN=$hplmn is equal to the old_hplmn" 	
	} else {
		set lai $vplmn
		log "RcvInitialMsMsg: HPLMN=VPLMN=$vplmn is different from the old_hplmn=$hplmn" 	
	}
	append lai $lac

	log "RcvInitialMsMsg: codec_list [rd _sig codec_list]"

	# Handle Paging Response
	if { [string compare [decL3_PD l3pdu] "RR"] == 0 } {
		SendApEstCnf $lai $ci $l3pdu
	} else {
		SendApEstInd $lai $ci $l3pdu
	} 

	# Restore State, it was set to Idle in Connect Ind
	set _state [DbGet $glBssapDb $glMsId State]
}

#------------------------------------------------------------#
# 3.1.17 "Queueing Indication" procedure functions
#------------------------------------------------------------#
proc RcvQueuingInd { } {

	global _sig

	LogInputMsg $_sig
}

#------------------------------------------------------------#
# 3.1.18 "Data Link Control SAPI not Equal to 0" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.19 "BSSMAP Error Handling" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.20 "Load Indication" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.21 "Voice group call service and voice broadcast service
#         call set-up and resource assignment" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.22 "Voice group call service and voice broadcast service
#         assignment" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.23 "void"
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.24 "Voice group call uplink control" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.25 "PDSS1 flow control" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.26 "Circuit re-selection" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.27 "LSA handling" procedure functions
#------------------------------------------------------------#
# TODO

#------------------------------------------------------------#
# 3.1.28 "Location Acquisition" procedure functions
#------------------------------------------------------------#
# Warning !!! Hardcoded values inside
proc SendPerfLocReq { } {
	
	global glBssapDb glMsId glMsDb

	new PERF_LOC_REQ s
	# current geo location
	wr s loc_type 00

	set lac [DbGet $glBssapDb $glMsId LAC]
	set ci  [DbGet $glBssapDb $glMsId CellId]
	set	cell_ident [GetCellIdentifier $lac $ci $glMsId]
	wr s cell_idfr $cell_ident

	wr s clsmk_info_3 [DbGet $glBssapDb $glMsId ClassMark3]
	# client type PLMN operator
	wr s lcs_cli_type 20
	wr s lcs_prio 01
	wr s lcs_qos 00a80080
    wr s imsi [DbGet $glMsDb $glMsId IMSI]

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s

	DbSet $glBssapDb $glMsId LcsState 1
}

# see test LORE_1301
# wrong cell id, no "APDU", unsupported IEs->GANSS
proc SendPerfLocReq_LORE1301 { } {
	
	global glBssapDb glMsId glMsDb glBtsDb

	new PERF_LOC_REQ s
	# assistence information for target MS
	wr s loc_type 0104
	wr s clsmk_info_3 [DbGet $glBssapDb $glMsId ClassMark3]
	# client type PLMN operator
	wr s lcs_cli_type 20
	wr s lcs_prio 01
	wr s lcs_qos 00a80080
    wr s imsi [DbGet $glMsDb $glMsId IMSI]

	set lac [DbGet $glBssapDb $glMsId LAC]
	set ci  [DbGet $glBssapDb $glMsId CellId]
	set bscid [GetBscIdByCellIdfr $lac $ci glBtsDb]
	#LogDb $glBtsDb($bscid)
	set n [DbSize $glBtsDb($bscid)] 
	for {set i 1} {$i<=$n} {incr i} {
		set LacCellId [DbGet $glBtsDb($bscid) $i LacCellId]
		log "DBG LacCellId: $LacCellId"
		set lactmp [lindex [split $LacCellId "_"] 0]
		set citmp  [lindex [split $LacCellId "_"] 1]
		if { $lac!=$lactmp || $ci!=$citmp } {
			set lac $lactmp
			set ci  $citmp
			log "LORE1301 found wrong cell id: $lactmp $citmp"
			break;
		}
	}
	
	set	cell_ident [GetCellIdentifier $lac $ci $glMsId]
	wr s cell_idfr $cell_ident

	#galileo
	wr s ganss_loctype 01
	#wr s ganss_assdata 00000008aa73102030
	wr s ganss_assdata 0020800105

	set chrate [DbGet $glBssapDb $glMsId ChannelRate]
	log "DBG chrate=$chrate"

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
	
	DbSet $glBssapDb $glMsId LcsState 1
}

proc RcvPerfLocRsp { } {
	
	global _sig glBssapDb glMsId

	LogInputMsg $_sig
	
	# Reset LCS State	
	DbSet $glBssapDb $glMsId LcsState 0
}

proc RcvApPerfLocCmd {} {

	if { [LbInterfaceActive] } {
		return
	}
	
	global  glBscDb glBtsDb glBssapDb glMsId glMsDb

	new PERF_LOC_REQ s
	wr s loc_type 00
	wr s clsmk_info_3 [DbGet $glBssapDb $glMsId ClassMark3]
	wr s lcs_cli_type 20
	wr s lcs_prio 01
	wr s lcs_qos 00a80080
    wr s imsi [DbGet $glMsDb $glMsId IMSI]

	LogOutputMsg $s

	#set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	#SendSccpNDataReq $spcstkidcid $s

	
	#set bscid 1
	set lac [DbGet $glBssapDb $glMsId LAC]
	set cellid [DbGet $glBssapDb $glMsId CellId]
	set bscid [GetBscIdByCellIdfr $lac $cellid glBtsDb]
	if { $bscid == "-1" } {
		abort "BSC identity unknown (LAC=$lac, CellId=$cellid)"
	}
	SendSccpNConnectReq $glBscDb $glMsId $bscid $s

	nextstate WaitForConnectAck_PerfLoc
	# TODO: Add a timer
}

proc RecvConnAck_PerfLoc { } {
	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Store SpcStkIdCidTarget
	DbSet $glBssapDb $glMsId SpcStkIdCid [rd _sig SpcStkIdCid]

	nextstate WaitForConnectCnf_PerfLoc 
}

proc RecvConnCnf_PerfLoc {} {
	nextstate BssapConnectActive 
}


#------------------------------------------------------------#
# 3.1.29 "Connectionless Information Transfer" procedure functions
#------------------------------------------------------------#
# see "SendSccpNUnitdataReq" and "DecSccpNUnitdataInd"

#------------------------------------------------------------#
# 3.1.30 "Common Id" procedure functions 
#------------------------------------------------------------#
proc SendCommonId { msid } {

	global glBssapDb glMsDb glMsId

	set	Imsi [DbGet $glMsDb $msid IMSI]

	new 	COMMON_ID s
	wr  s imsi $Imsi

	LogOutputMsg $s

	set spcstkidcid [DbGet $glBssapDb $msid SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $s
}


##############################################################
# DTAP procedures (see TS 3GPP 08.06 v.8.0.1)
##############################################################

proc SendDirectTransfer { conn dlci l3pdu } {

	global glBssapDb

	new DTAP_DATA s
	## Dlci
	wr s Dlci $dlci
	## Data
	wr s Data $l3pdu

	LogOutputPrim $s

	SendSccpNDataReq $conn $s
}

proc RcvDirectTransfer { } {

	global _sig

	LogInputPrim $_sig

	set l3pdu [rd _sig Data]
		
	SendApDataInd $l3pdu
}

proc RcvDirTransfInCphrCmplt { } {

	RcvDirectTransfer

	log "Warning: Ciphering Mode Procedure Not Terminated Correctly"
	
	nextstate BssapConnectActive
}

##############################################################
# PRMITIVES HANDLING
##############################################################

#------------------------------------------------------------#
# receiving CTL sap signals 
#------------------------------------------------------------#

proc OmPcStateIndHnd { } {

	global _sig glBscDb _ompid

	LogInputSig

	set bscid [DbGetIdx $glBscDb Dpc [rd _sig Dpc]]
	log "OmPcStateIndHnd: Dpc=[rd _sig Dpc] -- > bscid=$bscid"
	LogDb $glBscDb; #cDEBUG

	# Reset All Bsc instances
	BssapAllInstReset

	if { ![IsVoid [rd _sig RstTimer]] } {
		#TMA-337
		log "OmPcStateIndHnd: RstTimer=[rd _sig RstTimer]"
		if { ![IsEmpty $bscid] && ![IsVoid $bscid] } {
			SendReset $bscid [rd _sig RstTimer]
		} else {
			log "OmPcStateIndHnd: BscId not determined --> ANY RESET"
		}
	} else {
		log "OmPcStateIndHnd: 'RstTimer' field of the received signal 'BSSAP_OM_PCSTATE_IND' is void"; #cDEBUG
		SendReset $bscid
	}
}

proc RcvCtlReset {} {
	
	global _sig glBscDb
	
	LogInputSig

	set bscid [rd _sig BscId]
	log "RcvCtlReset bscid=$bscid"
	if { ![IsEmpty $bscid] && ![IsVoid $bscid] } {
        if { [DbEntryExists $glBscDb $bscid] } {
			# Reset All Bsc instances
			BssapAllInstReset

			SendReset $bscid
		} else {
			logscr "Warning: bscid=$bscid not found!"
		}
	} else {
		logscr "Warning: Invalid bscid on CTL_RESET"
	}
}

# BSSAP_CTL_RESET_RESOURCES
proc RcvCtlResetResources { } {

	LogInputMsg $::_sig

	set cause 07; # 'OM intervention'
	ResetIpResource $cause

	if { [info exists ::__Dbssap_PerIpReset] } {
		# PERIODIC IP RESET case
		TriggerPeriodicReset IPRESOURCE
	}

	nextstate WaitResetResAck
}

# BSSAP_CTL_RESET_CIRC
proc RcvCtlResetTdmCircuit { } {

	LogInputMsg $::_sig

	ResetCircuit

	if { [info exists ::__Dbssap_PerCircReset] } {
		# PERIODIC TDM CIRCUIT RESET case
		TriggerPeriodicReset TDMCIRCUIT
	}

	nextstate WaitRstCircAck
}

# BSSAP_CTL_INT_HOV_ENQUIRY
proc RcvCtlIntHovEnquiry { } {

	global _sig

	LogInputMsg $_sig

	SendIntHovEnquiry
}

#------------------------------------------------------------#
# receiving signals from SCCP adaptation layer
#------------------------------------------------------------#

# CONNECT_ACK
proc RcvConnAckInHovReq { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Store SpcStkIdCidTarget
	DbSet $glBssapDb $glMsId SpcStkIdCidTarget [rd _sig SpcStkIdCid]

	nextstate WaitForConnCnfInHovReq

	RestoreEvent
}

# CONNECT_IND
proc RcvConnectInd { } {

	global _sig _state glSpcStkIdCid 

	LogInputPrim $_sig

	# Get Parameters
	set glSpcStkIdCid [rd _sig SpcStkIdCid]
	log "RcvConnectInd: glSpcStkIdCid=$glSpcStkIdCid"

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	
	log "RcvConnectInd: _sig=$_sig"

	if { ![IsVoid $_sig] } {
		eval $_state
	}
}

# CONNECT_CNF (with "Handover Request Ack")
proc RcvConnCnfInHovReq { } {

	global _sig _state

	LogInputPrim $_sig

	nextstate WaitForHovReqAck

	if { ![RestoreEvent] } {
		# Store Pdu in _sig 
		set _sig [rd _sig Pdu]
		if { ![IsVoid $_sig] } {
			eval $_state
		}
	}
}

# DISCONNECT_IND
proc RcvDisconnectInd { } {

	global _sig glMsId glBssapDb glTarget glAoip

	LogInputPrim $_sig

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	if { ![IsVoid $_sig] } {
		log "Message $_sig Received in DISCONNECT_IND"
	}

#	LogDb $glBssapDb; #cDEBUG

	# Checking if release target or old connection
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	if { [info exists glTarget] || ![IsVoid $spcstkidcid] } {

		StopClrCmplteTimerByLink $spcstkidcid

		# Reset SpcStkIdCidTarget
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		# Reset Target Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"

		# Reset Traffic Resource
		ReleaseExtCic $glMsId "CicExtTarget"
		
		if { !$glAoip || $upType == 0 } {

			# Reset Traffic Resource
			ReleaseExtCic $glMsId "CicExtTarget"
		
			if { 0 } {
				# Reset Traffic Resource
				#set cic [DbGet $glBssapDb $glMsId CicTarget] 
				set cic [DbGet $glBssapDb $glMsId CicExtTarget]
	 
				if { ![IsVoid $cic] } {
					# CICEXT
					set spc [DbGet $glBssapDb $glMsId Spc]
					#cicRelease $cic
					log "RcvDisconnectInd: glMsId=$glMsId; cic=$cic; spc=$spc"; #cDEBUG

					CicReleaseExt $cic $spc

					DbSet $glBssapDb $glMsId CicTarget "?"
					log "BSSAP: Releasing Cic $cic"
				} else {
					log "RcvDisconnectInd: cic=$cic is void"; #cDEBUG
				}
			}
		}

		nextstate BssapConnectActive
	} else {

		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		StopClrCmplteTimerByLink $spcstkidcid

		# Stop LE Release Timers 
		RemoveLeTimers
		
		# Stop Timer Paging (T_PAG)
		#tmrstop [DbGet $glBssapDb $glMsId T_PAGid]
		
		# Remove SS7 link for this instance
		BssapMovInst $glMsId
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		nextstate BssapIdle
	}
}

# T_CLEARCOMPLETE
proc RcvTClrCmplte { } {

	global _sig glMsId glBssapDb glTarget glAoip

	LogInputSig	

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}
	
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
	
	# Checking if release target or old connection
	if { ![IsVoid $spcstkidcid] } {
		log "RcvTClrCmplte: $spcstkidcid $glMsId (get by SpcStkIdCidTarget)"
		SendSccpNDisconnectReq $spcstkidcid "?"
		# Reset SpcStkIdCidTarget
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Reset Traffic Resource
			set cic [DbGet $glBssapDb $glMsId CicTarget] 
			if { ![IsVoid $cic] } {
				# CICEXT
				set spc [DbGet $glBssapDb $glMsId Spc]			
				#cicRelease $cic
				CicReleaseExt $cic $spc
		
				DbSet $glBssapDb $glMsId CicTarget "?"
				log "BSSAP: Releasing Cic $cic"
			}
		}
		# Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		nextstate BssapConnectActive
	} else {
		log "RcvTClrCmplte: $spcstkidcid $glMsId (get by SpcStkIdCid)"
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		if { ![IsVoid $spcstkidcid] } {
			SendSccpNDisconnectReq $spcstkidcid "?"

		  	if { !$glAoip || $upType == 0 } {
				# Reset Traffic Resource
				set cic [DbGet $glBssapDb $glMsId CicExt]
				set cic [GetCicByExtCic $cic]
				if { ![IsVoid $cic] } {
					# CICEXT
					#set spc [DbGet $glBssapDb $glMsId Spc]
					set spc [lindex [split $spcstkidcid -] 1]
					log "defense and spc=$spc and cic=$cic"
					#cicRelease $cic
					CicReleaseExt $cic $spc
					DbSet $glBssapDb $glMsId CicExt "?"
					log "BSSAP: Releasing Cic $cic"
					DbSet $glBssapDb $glMsId Cic "?"
				}
			}
		}
		DbSet $glBssapDb $glMsId CicConnection ?

		# Stop Timer Paging (T_PAG)
		#tmrstop [DbGet $glBssapDb $glMsId T_PAGid]
		# Remove SS7 link for this instance
		BssapMovInst $glMsId
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		nextstate BssapIdle
	}
}
# DISCONNECT_IND in state _c_WaitForHovProcComplTgtOnly
proc RcvDisconnectIndTgtOnly { } {

	global _sig glMsId glBssapDb glTarget glAoip

	LogInputPrim $_sig

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	if { ![IsVoid $_sig] } {
		log "Message $_sig Received in DISCONNECT_IND"
	}

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
		StopClrCmplteTimerByLink $spcstkidcid
		# Reset Target
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Reset Target Traffic Resource
			set cic [DbGet $glBssapDb $glMsId CicTarget] 
			if { ![IsVoid $cic] } {
				# CICEXT
				set spc [DbGet $glBssapDb $glMsId Spc]			
				#cicRelease $cic
				CicReleaseExt $cic $spc
		
				DbSet $glBssapDb $glMsId CicTarget "?"
				log "BSSAP: Releasing Cic $cic"
			}
			DisconnectResources	$glMsId $glBssapDb
		}
		# Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		# Check if Serving was already Released
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		if { ![IsVoid $spcstkidcid] } {
			# Clear the instance
			BssapMovInst $glMsId
			nextstate BssapIdle
		} else {
			nextstate WaitForClrCmplt
		}
	} else {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		StopClrCmplteTimerByLink $spcstkidcid	
		# Partially Reset Serving Connection - completed with HOV_CMPLT
		DbSet $glBssapDb $glMsId SpcStkIdCid "?"
	}
}
# T_CLEARCOMPLETE in state _c_WaitForHovProcComplTgtOnly
proc RcvTClrCmpltTgtOnly { } {

	global _sig glMsId glBssapDb glTarget glAoip

	LogInputPrim $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
		SendSccpNDisconnectReq $spcstkidcid "?"
		# Reset Target
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Reset Target Traffic Resource
			set cic [DbGet $glBssapDb $glMsId CicTarget] 
			if { ![IsVoid $cic] } {
				# CICEXT
				set spc [DbGet $glBssapDb $glMsId Spc]			
				#cicRelease $cic
				CicReleaseExt $cic $spc
		
				DbSet $glBssapDb $glMsId CicTarget "?"
				log "BSSAP: Releasing Cic $cic"
			}
			DisconnectResources	$glMsId $glBssapDb
		}
		# Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		# Check if Serving was already Released
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		if { ![IsVoid $spcstkidcid] } {
			# Clear the instance
			BssapMovInst $glMsId
			nextstate BssapIdle
		} else {
			nextstate WaitForClrCmplt
		}
	} else {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		SendSccpNDisconnectReq $spcstkidcid "?"
		# Partially Reset Serving Connection - completed with HOV_CMPLT
		DbSet $glBssapDb $glMsId SpcStkIdCid "?"
	}
}
# DISCONNECT_IND in state _c_WaitForClrCmpltHov
proc RcvDisconnectIndHovCompleted { } {

	global _sig glMsId glBssapDb glTarget glAoip

	LogInputPrim $_sig

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	if { ![IsVoid $_sig] } {
		log "Message $_sig Received in DISCONNECT_IND"
	}

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
		StopClrCmplteTimerByLink $spcstkidcid
		# Reset Target
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Reset Target Traffic Resource
			set cic [DbGet $glBssapDb $glMsId CicTarget] 
			if { ![IsVoid $cic] } {
				# CICEXT
				set spc [DbGet $glBssapDb $glMsId Spc]			
				#cicRelease $cic
				CicReleaseExt $cic $spc
	
				DbSet $glBssapDb $glMsId CicTarget "?"
				log "BSSAP: Releasing Cic $cic"
			}
			DisconnectResources	$glMsId $glBssapDb
		}
		# Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		# Check if Serving was already Released
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		if { ![IsVoid $spcstkidcid] } {
			# Clear the instance
			BssapMovInst $glMsId
			nextstate BssapIdle
		} else {
			nextstate WaitForClrCmplt
		}
	} else {
		# Switch Target Connection into Serving
		BssapMovInst $glMsId
		nextstate BssapConnectActive
	}	
}

# T_CLEARCOMPLETE in state _c_WaitForClrCmpltHov
proc RcvTClrCmplteHovCompleted { } {
	global _sig glMsId glBssapDb glTarget glTmrClrSpcStkidCid glAoip

	LogInputSig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]

		# Disconnect the link
		#SendSccpNDisconnectReq $spcstkidcid "?"
		# To be sure the exact timer's clear sccp is released
		log "RcvTClrCmplteHovCompleted: releasing the exact sccp link $glTmrClrSpcStkidCid of timer"
		SendSccpNDisconnectReq $glTmrClrSpcStkidCid "?"

		# Reset Target
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Reset Target Traffic Resource
			set cic [DbGet $glBssapDb $glMsId CicTarget] 
			if { ![IsVoid $cic] } {
				# CICEXT
				set spc [DbGet $glBssapDb $glMsId Spc]			
				#cicRelease $cic
				CicReleaseExt $cic $spc
	
				DbSet $glBssapDb $glMsId CicTarget "?"
				log "BSSAP: Releasing Cic $cic"
			}
			DisconnectResources	$glMsId $glBssapDb
		}
		# Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		# Check if Serving was already Released
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		if { ![IsVoid $spcstkidcid] } {
			# Clear the instance
			BssapMovInst $glMsId
			nextstate BssapIdle
		} else {
			nextstate WaitForClrCmplt
		}
	} else {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		# Switch Target Connection into Serving
		BssapMovInst $glMsId
		nextstate BssapConnectActive
		log "RcvTClrCmplteHovCompleted: cleaning the old connection while not yet cleared"
		#SendSccpNDisconnectReq $spcstkidcid "?"
		
		SendSccpNDisconnectReq $glTmrClrSpcStkidCid "?"
	}	
}

# DISCONNECT_IND in state DuringExternalHov
proc RcvDisconnectIndDuringHov { } {

	global _sig glMsId glBssapDb glTarget glAoip

	LogInputPrim $_sig

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	if { ![IsVoid $_sig] } {
		log "Message $_sig Received in DISCONNECT_IND"
	}

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {

		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
		StopClrCmplteTimerByLink $spcstkidcid

		# Reset Target Connection
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		# Reset Target Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Target Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "CicTarget"
			ReleaseExtCic $glMsId "CicExtTarget"
		}
		# TMA-240
		# Release Target
		SendSccpNDisconnectReq $glTarget "?"
	} else {
		if { !$glAoip || $upType == 0 } {
			# Serving Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "Cic"
			ReleaseExtCic $glMsId "CicExt"
			# TMA-240
	        DisconnectResources $glMsId $glBssapDb
        }
		# Release Serving Connection
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		StopClrCmplteTimerByLink $spcstkidcid	
		SendSccpNDisconnectReq $spcstkidcid "?"
		# Switch Target Connection into Serving
		BssapMovInst $glMsId
	}

	nextstate WaitForClrCmplt
}

# T_CLEARCOMPLETE in state DuringExternalHov
proc RcvTClrCmplteDuringHov { } {

	global _sig glMsId glBssapDb glTarget glAoip

	LogInputPrim $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Target or Serving
	if { [info exists glTarget] } {

		# Reset Target Connection
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		# Reset Target Cell Identification
		DbSet $glBssapDb $glMsId LACTarget "?"
		DbSet $glBssapDb $glMsId CellIdTarget "?"
		if { !$glAoip || $upType == 0 } {
			# Target Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "CicTarget"
			ReleaseExtCic $glMsId "CicExtTarget"
		}
		# TMA-240
		# Release Target
		SendSccpNDisconnectReq $glTarget "?"
		unset glTarget
	} else {
		if { !$glAoip || $upType == 0 } {
			# Serving Traffic Resource
			# TMA-240
			#ReleaseCic $glMsId $glBssapDb "Cic"
			ReleaseExtCic $glMsId "CicExt"
			# TMA-240
	        DisconnectResources $glMsId $glBssapDb
        }
		# Release Serving Connection
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		StopClrCmplteTimerByLink $spcstkidcid	
		SendSccpNDisconnectReq $spcstkidcid "?"
		# Switch Target Connection into Serving
		BssapMovInst $glMsId
	}

	nextstate WaitForClrCmplt
}

proc RcvDisconnectIndInHovReqNotCompleted { } {
	
	global _sig glMsId glBssapDb glTarget glAoip

	LogInputPrim $_sig

	# Store Pdu in _sig
	set _sig [rd _sig Pdu]
	if { ![IsVoid $_sig] } {
		log "Message $_sig Received in DISCONNECT_IND"
	}

	#LogDb $glBssapDb; #cDEBUG

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Checking if release target or old connection
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
	if { [info exists glTarget] || ![IsVoid $spcstkidcid] } {

		StopClrCmplteTimerByLink $spcstkidcid

		# Reset SpcStkIdCidTarget
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
		
		if { !$glAoip || $upType == 0 } {
			#TMA-337 start
			# Check if timer T_RG_TRR2 is running
			set tid [DbGet $glBssapDb $glMsId T_RG_TRR2id]
			if { ![IsVoid $tid] && [tmrrunning $tid] } {
				# DISCONNECT_IND received when the HOV_REQ_ACK isn't still received
				set cic [DbGet $glBssapDb $glMsId CicExtTarget]
				if { ![IsVoid $cic] } {
					log "RcvDisconnectIndInHovReqNotCompleted: -- glMsId=$glMsId; cic=$cic --"
					set cicbyExtCic [GetCicByExtCic $cic]
					set stkId [DbGet $glBssapDb $glMsId StkId]
					set cicReleaseResult [CicReleaseExt $cicbyExtCic $stkId]
					if { $cicReleaseResult == -1 } {
						log "RcvDisconnectIndInHovReqNotCompleted: WARNING: No Cic Release done for the cicbyExtCic=$cicbyExtCic; stkId=BSC_SPC=$stkId"
					} else {
						# TMA-379 PATCH for bug fixing: Carlo 13/08/2010 -start-
						#DbSet $glBssapDb $glMsId CicTarget "?"
						DbSet $glBssapDb $glMsId CicExtTarget "?"
						# TMA-379 -end-
						log "BSSAP: Releasing cicbyExtCic $cicbyExtCic (obtained from cic=$cic)"
					}
				} else {
					log "RcvDisconnectIndInHovReqNotCompleted: WARNING: cic=$cic is void"
				}
				# Reset Cell Target Identification
				DbSet $glBssapDb $glMsId LACTarget "?"
				DbSet $glBssapDb $glMsId CellIdTarget "?"
				# Release Serving Traffic Resource
				DisconnectResources $glMsId $glBssapDb
				# Release Serving Connection
				set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
				StopClrCmplteTimerByLink $spcstkidcid	
				SendSccpNDisconnectReq $spcstkidcid "?"
	
		# ----- #
		#		# Switch Target Connection into Serving
		#		BssapMovInst $glMsId
		# ----- #

				set apHeldEventBuf [DbGet $glBssapDb $glMsId ApHeldEventBuf]
				if { ![IsVoid $apHeldEventBuf] && $apHeldEventBuf == "CLR_REQ" } {
					# Clear the 'CLR_REQ' stored in the AP_HELD_EVENT_BUF field in the DataBase
					DbSet $glBssapDb $glMsId ApHeldEventBuf "?"
				} else {
					log "WARNING: apHeldEventBuf=$apHeldEventBuf --> no clear of the ApHeldEventBuf field in glBssapDb"; #cDEBUG
				}
				# Stop Timer T_RG_TRR2
				tmrstop $tid

				nextstate BssapIdle

			} else {
			#TMA-337 end
				# Reset Traffic Resource
				set cic [DbGet $glBssapDb $glMsId CicExtTarget]
				if { ![IsVoid $cic] } {
					# CICEXT
					set spc [DbGet $glBssapDb $glMsId Spc]
					#cicRelease $cic
					log "RcvDisconnectIndInHovReqNotCompleted: glMsId=$glMsId; cic=$cic; spc=$spc"
					CicReleaseExt $cic $spc
					
					# Carlo: to check se corretto CicTarget oppure se ci vuole CicExtTarget come nel caso if sopra
					DbSet $glBssapDb $glMsId CicTarget "?"
					log "BSSAP: Releasing Cic $cic"
				} else {
					log "RcvDisconnectIndInHovReqNotCompleted: cic=$cic is void"
				}
				# Reset Cell Identification
				DbSet $glBssapDb $glMsId LACTarget "?"
				DbSet $glBssapDb $glMsId CellIdTarget "?"
				nextstate BssapConnectActive
			}
		} else {
			# Cell Identification
			DbSet $glBssapDb $glMsId LACTarget "?"
			DbSet $glBssapDb $glMsId CellIdTarget "?"
			nextstate BssapConnectActive
		}
	} else {
		set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
		StopClrCmplteTimerByLink $spcstkidcid
		# Remove SS7 link for this instance
		BssapMovInst $glMsId
		# Send Release Ind to MM
		set cause "Normal_Event"
		SendApRelInd $cause
		nextstate BssapIdle
	}
}

#------------------------------------------------------------#
# receiving primitives from upper level
#------------------------------------------------------------#

# BSSAP_AP_EST_REQ
proc RcvApEstReq { } {

	global _sig glBssapDb glMsId __use_CGI

	LogInputPrim $_sig

	set tmsiVal [rd _sig TMSI]
	if { ![IsVoid $tmsiVal] } {
		set tmsi [hocts $tmsiVal 1 4]
	} else {
		set tmsi $tmsiVal
	}
	set l3pdu [rd _sig Pdu]

	# Paging procedure 
	DbSet $glBssapDb $glMsId TMSI $tmsi
	
	if { [IsVoid [DbGet $glBssapDb $glMsId StkId]] } {
		SendPagingToAllCells $tmsi
	} else {
		set lac [DbGet $glBssapDb $glMsId LAC]
		if { [IsVoid $lac] } {
			SendPagingToAllCells $tmsi
		} else {
			if { [info exist __use_CGI] && $__use_CGI } {
				SendPagingCGI $tmsi $lac
			} else {
				SendPagingByLac $tmsi $lac
			}
		}
	}
}

# BSSAP_AP_EST_REQ
# We received a call attempt from upper layers, 
# but we're not in the correct state to handle it.
# So we clear this transaction and we release 
# to the upper layers.
proc OutOfSync { } {

	global glBssapDb glMsId

	SendApRelInd "Protocol_Error"
	
	# Clear Transaction if present
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	if { ![IsVoid $spcstkidcid] } {
		set prot_disc 6; # RR protocol discriminator
		set trans_id 0
		set cause 60; # Cause "Protocol Error"

		# Clear Dedicated Connection
		SendClrCmd [list $prot_disc $trans_id $cause]

		nextstate WaitForClrCmplt
	}
}

# BSSAP_AP_EST_ACK
proc RcvApEstAck { } {

	global _sig glBssapDb glMsDb glMsId glMsDbOffset glPagAttempts gMMRemote glAoip

	LogInputMsg $_sig
	log "RcvApEstAck: glMsId=$glMsId"

	if { $glAoip } {
		if { [DbEntryExists $glBssapDb $glMsId] && \
			  ![IsEmpty [DbGet $glBssapDb $glMsId UpType]] && \
			  ![IsVoid [DbGet $glBssapDb $glMsId UpType]] } {
			# Carlo: workaround for TMA-437 and TMA-422 in case of real unknown mobile.
			set upType [DbGet $glBssapDb $glMsId UpType]
		} else {
			log "RcvApEstAck: case of 'UpType' field which is not set in the BssapDb"
			# --- case of Real Mobile (Carlo 12/10/11 TMA-340) ---
			if { [DbSize $glMsDb] < $glMsId } {
				log "RcvApEstAck: the mobile glMsId=$glMsId is a REAL MOBILE"
				set upType ?
				log "RcvApEstAck: WARNING: upType is void for the glMsId=$glMsId"
			} else {
				set upType ?
				log "RcvApEstAck: ********* WARNING --> upType is void for the glMsId=$glMsId *********"
			}
		}
	}

	# Retrieving parameters from BSSAP_AP_EST_ACK
	set spcstkidcid [rd _sig SpcStkIdCid]
	set lai [rd _sig LAI]
    set ci [rd _sig CellId]

	# Create Temp Entity if needed
	if { $glMsId >= $glMsDbOffset } {
		set nstate BssapIdle
		CreateNewBssapEntity $nstate $glMsId
		log "RcvApEstAck: new entity created"
		if { [isSplitted] } {
			set slaveId [rd _sig SlaveId]
			if { ![IsVoid $slaveId] } {
				log "RcvApEstAck: msId=$glMsId setting slave = $slaveId"
				DbSet $glBssapDb $glMsId SlaveId $slaveId	
			}
		}
	}

	# Start TMA-236
	# Stop Paging Timer (T_PAG) if it is active
	set tid [DbGet $glBssapDb $glMsId T_PAGid]
	if { ![IsVoid $tid] && [tmrrunning $tid] } {
		tmrstop $tid
		# Restore PagAttempts
		DbSet $glBssapDb $glMsId PagAttempts $glPagAttempts
	} elseif { [DbGet $glBssapDb $glMsId AbortReqFlag] } {
		# ABORT_REQ was received - Release Serving Connection
		log "RcvApEstAck: Disconnecting spcstkidcid=$spcstkidcid (AbortReqFlag=1)"
		SendSccpNDisconnectReq $spcstkidcid "?"
		DbSet $glBssapDb $glMsId AbortReqFlag 0
		# Reset Serving Connection
		BssapMovInst $glMsId
		# Release MM
		log "RcvApEstAck: Releasing MM"
		SendApRelInd "Normal_Event"	

		return
	} elseif { [DbGet $glBssapDb $glMsId AbortReqFlagGs] } {
		# ABORT_REQ was received - Release Serving Connection
		log "RcvApEstAck: Disconnecting spcstkidcid=$spcstkidcid (AbortReqFlagGs=1)"
		SendSccpNDisconnectReq $spcstkidcid "?"
		DbSet $glBssapDb $glMsId AbortReqFlagGs 0
		# Reset Serving Connection
		#BssapMovInst $glMsId
		# Release MM
		return
	}
	# End TMA-236

	# Check if the Cid is already assigned (temporary)
	if { [DbKeyExists $glBssapDb SpcStkIdCid $spcstkidcid] } {
		set idx [DbGetIdx $glBssapDb SpcStkIdCid $spcstkidcid]
		logscr ""	
		logscr "Warning: Connection ($spcstkidcid) already assigned for MS $idx"	
		logscr ""	
		exit
	}
	# Check if this is a remote command from MM
	if { ![isSplitted] } {
		log "RcvApEstAck: gMMRemote=$gMMRemote"
		if { $gMMRemote } {
			# Force the release on the old connection
			RcvApRelReq2
			# Reset flag
			set gMMRemote 0
		}
	}

	# setting parameters in database
	DbSet $glBssapDb $glMsId SpcStkIdCid $spcstkidcid
	log "RcvApEstAck: setting new spcstkidcid=$spcstkidcid"
	DbSet $glBssapDb $glMsId Spc [GetSpc $spcstkidcid]
	DbSet $glBssapDb $glMsId StkId [GetStkId $spcstkidcid]
	DbSet $glBssapDb $glMsId LAC [hocts $lai 3 4]
	DbSet $glBssapDb $glMsId CellId $ci

# Carlo 09/2011: modification for TMA-437 and TMA-422 in case of real unknown mobile
	if { !$glAoip || ![IsVoid $upType] && !$upType } {
		# Release Cic if it was set, it may happen when
	    # CLR_MPLT arrives late and a new mobile attempts to connect
		# TMA-240
		#ReleaseCic $glMsId $glBssapDb "Cic"
		ReleaseExtCic $glMsId "CicExt"
		# TMA-240
	    DisconnectResources $glMsId $glBssapDb
    }
	
	SendSccpNConnectRes $spcstkidcid "?"

	# Send "CommonId" if we know MS Identity
	if { $glMsId < $glMsDbOffset } {
		# Sending "CommonId"
		SendCommonId $glMsId
	
		set loc_needed [DbGet $glMsDb $glMsId LocationNeeded]
		if { $loc_needed == 2 } {
			# Trigger Location Acquisition
			SendPerfLocReq
		} elseif { $loc_needed == 4 } {
			SendPerfLocReq_LORE1301
		}
	}

	nextstate BssapConnectActive

}

# BSSAP_AP_EST_NACK
proc RcvApEstNack { } {

	global _sig

	LogInputMsg $_sig

	# Retrieving parameters from BSSAP_AP_EST_NACK
	set spcstkidcid [rd _sig SpcStkIdCid]

	SendSccpNDisconnectReq $spcstkidcid "?"
}

# BSSAP_AP_REL_REQ auxiliary function
proc RelParams { } {

	global _sig glMsDb 

	set relCause [rd _sig RelCause]
	set prot_disc [rd relCause ProtDisc]
	set trans_id [rd relCause TransId]

	if { $relCause == "User_Busy_MM" && [DbFieldExists $glMsDb Call_Forwarding] } {
		set cause "91"
	} else {
		# Cause "Call Control"
		set cause "09"
	}

	return "$prot_disc $trans_id $cause"
}

# BSSAP_AP_REL_REQ in state BssapConnectionActive
proc RcvApRelReq { } {

	global _sig glMsDb glMsId

	LogInputMsg $_sig

	# ----------------------------#
	#@Carlo - Call Hold management
	
	set releaseCause [rd _sig RelCause]
	set cause [rd releaseCause Cause]
	log "rcvApRelReq: releaseCause=$releaseCause --> cause=$cause"
	if { $cause == "9f" && [DbFieldExists $glMsDb CallHoldActivation] && [DbGet $glMsDb $glMsId CallHoldActivation] == "hold" } {
			global glBssapDb
			# DISCONNECT TRAFFIC RESOURCE (on LSU)
			DisconnectResources	$glMsId $glBssapDb

			# IT DOESN'T CHANGE CURRENT STATE
	# ----------------------------#
	} else {
		# "Release" procedure (downlink)
		SendClrCmd [RelParams]

		nextstate WaitForClrCmplt
	}
}

# Start TMA-237
# BSSAP_AP_REL_REQ received in state WaitCphrCmplt

proc RcvApRelReqCphrCmplt { } {

	global _sig glMsId glBssapDb

        LogInputMsg $_sig

	# Stop Timer T_CIPHR (if it's running)	
	set tid [DbGet $glBssapDb $glMsId T_CIPHRid]
        if { ![IsVoid $tid] && [tmrrunning $tid] } {
                tmrstop $tid
        }

	# Send the Clear Cmd	
	RcvApRelReq
}
# End TAM-237

proc RcvApRelReqLink { } {
	global _sig glMsId

	LogInputMsg $_sig

	set params [RelParams]
	set spcStkIdCid [rd _sig SpcStkIdCid]
	set prot_disc [lindex $params 0]
	set trans_id [lindex $params 1]
	set cause [lindex $params 2]

	set L3_Hdr_Info [uctoh $prot_disc]
	append L3_Hdr_Info [uctoh $trans_id]

	new CLR_CMD s
	wr s l3_hdr_info $L3_Hdr_Info
	wr s cause $cause
	
	LogOutputMsg $s

	log "RcvApRelReqLink: sending CLR_CMD for spcStkIdCid=$spcStkIdCid MSId=$glMsId"
	SendSccpNDataReq $spcStkIdCid $s

	StartClrCmplteTimer $spcStkIdCid
}

proc RcvCtlMscTracInvoke { } {
	global _sig

	new MSC_INVOKE_TRC s
	
	wr s trc_type	[rd _sig TrcType]
	wr s trig_id	[rd _sig TriggerId]
	wr s trc_ref	[rd _sig TraceReference]
	wr s trnctn_id	[rd _sig TransactionId]
	wr s mbl_idty	[rd _sig MobileIdentity]
	wr s omc_id		[rd _sig OMCId]

	SendSccpNUnitdataReq $s
}

proc RcvCtlSendOverload { } {
	global _sig

	set cause [rd _sig Cause]

	if { ![IsVoid $cause] } {
		SendOverload $cause	
	} else {
		SendOverload
	}

}

proc RcvApRelReq2 { } {

	global _sig glMsId glBssapDb

	LogInputMsg $_sig

	# "Release" procedure (downlink)
	# Check if the MS has already a connection

	log "RcvApRelReq2: MsId=$glMsId"

	# Start TMA-188
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	if { ![IsVoid $spcstkidcid] } {
 
		SendClrCmd [list 5 0 60]	
		log "RcvApRelReq2: Previous link to be released = $spcstkidcid"
	}

	set spcstkidcid_tgt [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
	if { ![IsVoid $spcstkidcid_tgt] } {
		SendClrCmdTarget [list 5 0 60]	
		log "RcvApRelReq2: Target link to be released = $spcstkidcid_tgt"
		# Reset Target Connection
		DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
	} 

	if { ![IsVoid $spcstkidcid] || ![IsVoid $spcstkidcid_tgt] } {
		nextstate WaitForClrCmplt	
	} else {
		log "RcvApRelReq2: link not available neither in target"
	}
	# End TMA-188
}


# BSSAP_AP_REL_REQ in state _c_WaitForClrCmpltHov
proc RcvApRelReqTgtOnly { } {

	global _sig glMsId

	LogInputMsg $_sig

	# "Release" procedure (downlink)
	SendClrCmdTarget [RelParams]

	nextstate DuringExternalHov
}

# BSSAP_AP_REL_REQ in state DuringExternalHov
proc RcvApRelReqTgt { } {

	global _sig glBssapDb glMsId 

	LogInputMsg $_sig

	# Flush the Queue
	DbSet $glBssapDb $glMsId ApDataReqBuf "?"

	# "Release" procedure (downlink)
	SendClrCmd [RelParams]

	# Release target connection also (by BSSAP proc)
	SendClrCmdTarget [RelParams]

	nextstate DuringExternalHov	
}

# BSSAP_AP_REL_REQ in state _c_WaitForIntHovProcCompleted
proc RcvApRelReqIntHovCpltd { } {

	global _sig glBssapDb glMsId 

	LogInputMsg $_sig

	# Flush the Queue
	DbSet $glBssapDb $glMsId ApDataReqBuf "?"

	SendClrCmd [RelParams]

	nextstate WaitForClrCmplt; #Carlo TODO TO BE TESTED
}

# BSSAP_AP_REL_REQ in state WaitForConnAckInHovReq
proc RcvEventHold { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig
	log "[lindex $_sig 0] Held"
	
	# Store AP_DATA_REQ_REQ in DataBase
	DbSet $glBssapDb $glMsId ApHeldEventBuf $_sig
}

# BSSAP_AP_REL_REQ in state WaitForConnCnfInHovReq
proc RcvApRelReqDisc { } {

	global _sig glMsId glBssapDb glAoip

	LogInputMsg $_sig

	# Release Serving Connection
	SendClrCmd [RelParams]

	# TMA-332
	# Release Target Connection
	#set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]
	#SendSccpNDisconnectReq $spcstkidcid "?"
	DbSet $glBssapDb $glMsId DoubleClear 1

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Reset Target Connection
	#DbSet $glBssapDb $glMsId SpcStkIdCidTarget "?"
	if { !$glAoip && 0 || $glAoip && $upType == 0 && 0 } {
		# Reset Target Traffic Resource
		set cic [DbGet $glBssapDb $glMsId CicTarget] 
		if { ![IsVoid $cic] } {
			# CICEXT
			set spc [DbGet $glBssapDb $glMsId Spc]			
			#cicRelease $cic
			CicReleaseExt $cic $spc
	
			DbSet $glBssapDb $glMsId CicTarget "?"
			log "BSSAP: Releasing Cic $cic"
		}
	}
	# Reset Target Cell Identification
	#DbSet $glBssapDb $glMsId LACTarget "?"
	#DbSet $glBssapDb $glMsId CellIdTarget "?"
	# TMA-332

	nextstate WaitForClrCmplt
}

# BSSAP_CTL_VGCS_DEDI_REL_REQ for VGCS Dedicated
proc RcvDedicatedRelReq { } {

	global _sig

	LogInputMsg $_sig

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	#set cause 0e; # Cause "Join Group Call"
	set cause [rd _sig Cause]

	SendApRelInd "Normal_Event"
	
	# Clear VGCS Dedicated Connection
	SendClrCmd [list $prot_disc $trans_id $cause]

	nextstate WaitForClrCmplt
}

# BSSAP_AP_DATA_REQ
proc RcvApDataReq { } {

	global _sig glBssapDb glMsId

	LogInputPrim $_sig

	# Dlci
	set dlci [rd _sig Sapi]

	# Spc Stkid Cid
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]

	# Retrieving "pdu" from BSSAP_AP_DATA_REQ
	set l3pdu [rd _sig Pdu]

	# Sending DIRECT_TRANSFER
	SendDirectTransfer $spcstkidcid $dlci $l3pdu
}

# BSSAP_AP_DATA_REQ
proc RcvApDataReqHov { } {

	global _sig glBssapDb glMsId

	LogInputPrim $_sig

	# Dlci
	set dlci [rd _sig Sapi]

	# Spc Stkid Cid
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCidTarget]

	# Retrieving "pdu" from BSSAP_AP_DATA_REQ
	set l3pdu [rd _sig Pdu]

	# Sending DIRECT_TRANSFER
	SendDirectTransfer $spcstkidcid $dlci $l3pdu
}

# BSSAP_AP_SET_INST
proc RcvApSetInst { } {

	global _sig glMsId glBssapDb 

	LogInputMsg $_sig

	# Get Parameters
	set dstid [rd _sig MsIdDst]
	set record [DbGetRecord $glBssapDb $glMsId]
	set record [lreplace $record 0 0 $dstid]
	set tPagid [DbGet $glBssapDb $dstid T_PAGid]
	set tCiphrid [DbGet $glBssapDb $dstid T_CIPHRid]
	set tRgTrr2id [DbGet $glBssapDb $dstid T_RG_TRR2id]
	set queudIdIndex [DbGet $glBssapDb $dstid QueueIdListIndex]
	log "RcvApSetInst: queudIdIndex=$queudIdIndex for dstid=$dstid"
	
	if { $::glAoip } {
		set upType [DbGet $glBssapDb $dstid UpType]
		set initMscUpType [DbGet $glBssapDb $dstid InitMscUpType]
	}	
	
	# Remove Old Db
	RemoveBssapEntity $glMsId

	# Update New Db
	DbRemEntry $glBssapDb $dstid
	DbCreateEntry $glBssapDb $record
	DbSet $glBssapDb $dstid T_PAGid $tPagid
	DbSet $glBssapDb $dstid T_CIPHRid $tCiphrid
	DbSet $glBssapDb $dstid T_RG_TRR2id $tRgTrr2id
	
	if { $::glAoip } {
		DbSet $glBssapDb $dstid UpType $upType
		DbSet $glBssapDb $dstid InitMscUpType $initMscUpType
	}

	# Stop Paging Timer 
	if { [tmrrunning $tPagid] } {
		tmrstop $tPagid
	}

	# Sending "CommonId"
	SendCommonId $dstid

	set glMsId $dstid

	if { [isSplitted]} {
		log "RcvApSetInst: msId=$glMsId SlaveId=[DbGet $glBssapDb $glMsId SlaveId]"
	}
}

proc SndConnectRes { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# retrieving "sapi" and "pdu" from BSSAP_AP_DATA_REQ
	set dlci [rd _sig Sapi]
	set l3pdu [rd _sig Pdu]

	# sending DIRECT TRANSFER in SCCP CONNECT RES
	new 	DTAP_DATA s
	## Dlci
	wr s Dlci $dlci
	## Data
	wr s Data $l3pdu

	LogOutputPrim $s

	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNConnectRes $spcstkidcid $s

	nextstate BssapConnectActive
}

proc GetTrfDbByMsId { msId } {
	global glBssapDb glBtsDb glBscDb
	set lac [DbGet $glBssapDb $msId LAC]
	set cellid [DbGet $glBssapDb $msId CellId]
	set bscid [GetBscIdByCellIdfr $lac $cellid glBtsDb]

	log "GetTrfDbByMsId: msId=$msId; lac=$lac; cellid=$cellid; bscid=$bscid; glBtsDb($bscid)=$glBtsDb($bscid)"; #cDEBUG

	if { $bscid >= 0 } {
		set trfDb [DbGetName [DbGet $glBscDb $bscid TrafficLinksDb]]
		log "GetTrfDbByMsId msId=$msId lac=$lac cellid=$cellid -- trfDb=$trfDb"
		return $trfDb	
	} else {
		abort "GetTrfDbByMsId: msId=$msId lac=$lac cellid=$cellid BSC not found!"
	}
}

proc CheckDstIdAFlex { dstId } {
	if { [llength [info commands saveprofilepid]] == 0 } {
		return $dstId
	}
	global glBssapDb
	
	if { ![DbEntryExists $glBssapDb $dstId] } {
		return "?"
	}
    
	set st [DbGet $glBssapDb $dstId State]
	log "CheckDstIdAFlex: dstId=$dstId st=$st"
	if { ![string compare $st "BssapConnectActive"] } {
		return $dstId
	} else {
		return "?"
	}
}

# BSSAP_AP_SYNC_REQ
proc RcvApSyncReq { } {

	global _sig glBssapDb glMsId glBscDb glBtsDb glAoip __tstm_db
	global __bssap_plmn

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# retrieving "cause_tag" from BSSAP_AP_SYNC_REQ
	set cause_val [rd _sig CauseVal]
	set cause_tag [lindex $cause_val 0]

	switch -exact -- $cause_tag {
		
		"SYNC_CPHR" {
		# ciphering
			set perm_alg [rd cause_val PermAlg]
			set key [rd cause_val Key]
			set cipher_rsp_mode [rd cause_val CiphrRespMode]

			# Store Encryption Info on local Db
			set encr_info [uctoh $perm_alg]
			if { $perm_alg != "1" } {

			# Start TMA-235
			#	append encr_info [uitoh $key]
				append encr_info $key
			# End TMA-235
			
			}
			DbSet $glBssapDb $glMsId Encryption $encr_info

			SendCphrModeCmd $encr_info $cipher_rsp_mode
		}\
		"SYNC_RES_ASS" {
		# resource assignment
			set calltype [rd cause_val CallType]
			switch -exact -- $calltype {
				"Speech" 	 {set spi 01}
				"UDI" 		 {set spi 02}
				"Signalling" {set spi 03}
				default	 {abort "Unexpected Call Type ($calltype)"}
			}
			set ch_rate [rd cause_val ChRate]
			set perm_speech [rd cause_val PermSpeech]
			set datarate [rd cause_val DataRate]
			set priority [rd cause_val Priority]
			set grCallRef [rd _sig GroupCallReference]
			if { [IsVoid $grCallRef] } {
				SendAssignmentReq $spi $ch_rate $perm_speech $datarate $priority
			} else {
				SendAssignmentReq $spi $ch_rate $perm_speech $datarate $priority $grCallRef
			}
			ForceReset "after_assignment_command"
		}\
		"SYNC_CONNECT" {
			if { !$glAoip || $upType == 0 } {
			# switch matrix connection
			set dstId [rd cause_val MsIdDst]
			set dphoneFlag [rd cause_val DPhone]

			log "RcvApSyncReq: dstId=$dstId; dphoneFlag=$dphoneFlag"; #cDEBUG

			if { ![IsVoid $dstId] && [IsVoid $dphoneFlag] && ![isSplitted] } {
				set lac [DbGet $glBssapDb $glMsId LAC]
				set cellid [DbGet $glBssapDb $glMsId CellId]
				set bsc1id [GetBscIdByCellIdfr $lac $cellid glBtsDb]
				if { $bsc1id == "-1" } {
					abort "BSC identity unknown (LAC=$lac, CellId=$cellid)"
				}
				DbSet $glBssapDb $glMsId BscId $bsc1id

				log "RcvApSyncReq: glMsId=$glMsId bsc1id=$bsc1id"

				set trfDb [DbGetName [DbGet $glBscDb $bsc1id TrafficLinksDb]]

				set trfDb1 [GetTrfDbByMsId $glMsId]

				log "RcvApSyncReq: trfDb1=$trfDb1"

				set cic1_ext [DbGet $glBssapDb $glMsId CicExt]
				set cic1 [GetCicByExtCic $cic1_ext]
		
				log "RcvApSyncReq: cic1=$cic1"
				if { [IsEmpty $cic1] || [IsVoid $cic1] } {
					log "RcvApSyncReq: ERROR: cic1 is void or empty"
				}

				set pcm1 [expr {$cic1 >> 5}]
				set ts1 [expr {$cic1 & 0x1f}]
				log "RcvApSyncReq: cic1_ext=$cic1_ext"
				if { [DbKeyExists $trfDb1 Pcm $pcm1] } {
					set lsuPcmIdx [DbGetIdx $trfDb1 Pcm $pcm1] 
					set lsuPcm1 [DbGet $trfDb1 $lsuPcmIdx LsuPcm]
				
					DbSet $glBssapDb $glMsId LsuPcm $lsuPcm1
					DbSet $glBssapDb $glMsId Ts	$ts1

					log "RcvApSyncReq: lsuPcm1=$lsuPcm1; ts1=$ts1"

					if { [DbFieldExists $trfDb1 PcmType] } {
						DbSet $glBssapDb $glMsId PcmType [DbGet $trfDb1 $lsuPcmIdx PcmType]
						if { [DbFieldExists $trfDb1 Stm1Line] } {
							DbSet $glBssapDb $glMsId Stm1Line [DbGet $trfDb1 $lsuPcmIdx Stm1Line]
						}
					}

				} else {
					abort "Error: PCM does not exist in Traffic Db"
				}

				log "RcvApSyncReq: glMsId=$glMsId; lsuPcm1=$lsuPcm1 - stm1Line1=[DbGet $glBssapDb $glMsId Stm1Line]; ts1=$ts1; pcmType1=[DbGet $glBssapDb $glMsId PcmType]"

				if { [IsVoid [CheckDstIdAFlex $dstId]] } {
					# A_Flex: Traffic Link Connection
					# ----------------------------------------------------- #
					set lsuPcm2		[DbGet $glBssapDb $dstId LsuPcm] 
					set ts2			[DbGet $glBssapDb $dstId Ts]
					set pcmType2	[DbGet $glBssapDb $dstId PcmType]
					set stm1Line2	[DbGet $glBssapDb $dstId Stm1Line]
					set tstmIndex2	[DbGet $glBssapDb $dstId TstmIndex]
					set bsc2id		[DbGet $glBssapDb $dstId BscId]

					log "dstId=$dstId; lsuPcm2=$lsuPcm2; ts2=$ts2; pcmType2=$pcmType2; stm1Line2=$stm1Line2; bsc2id=$bsc2id; (tstmIndex2=$tstmIndex2)"

					# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% #

					global glTrfDb
					log "#################"; #cDEBUG
					log "RcvApSyncReq: BSC1=$bsc1id --> trfDb1=$glTrfDb($bsc1id)"; #cDEBUG
					log "#################"; #cDEBUG
					LogDb $glTrfDb($bsc1id); #cDEBUG
					log "#################"; #cDEBUG
					
					log "RcvApSyncReq: OrigCicConn=[DbGet $glBssapDb $glMsId CicConnection] --> DestCicConn=[DbGet $glBssapDb $dstId CicConnection]"

					if { ![IsVoid $lsuPcm2] && ![IsVoid $ts2] && ![IsVoid $bsc2id] } {

						log "#################"; #cDEBUG
						#log "RcvApSyncReq: BSC2=$bsc2id --> trfDb2=$glTrfDb($bsc2id)"; #cDEBUG
						log "#################"; #cDEBUG
						#LogDb $glTrfDb($bsc2id); #cDEBUG
						log "#################"; #cDEBUG

						log "RcvApSyncReq: Traffic connection data is available"; #cDEBUG
						set spc [DbGet $glBssapDb $glMsId Spc]
						set stkid [DbGet $glBssapDb $glMsId StkId]

						if { ![IsVoid $lsuPcm1] && ![IsVoid $lsuPcm2] } {
							if { [IsVoid $pcmType2] && ![DbFieldExists $trfDb1 PcmType] || ![DbGet $glBssapDb $glMsId PcmType] && [IsVoid $pcmType2] || ![DbGet $glBssapDb $glMsId PcmType] && ![DbGet $glBssapDb $dstId PcmType] || ![DbFieldExists $trfDb1 PcmType] && ![DbGet $glBssapDb $dstId PcmType] } {
								# All Electrical PCMs
								set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
								log "RcvApSyncReq: -All Electrical PCMs- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2: connString=$connString"

								if { [DbKeyExists $glBssapDb CicConnection $connString] } {
									# TMA-342
							 		set idx [DbGetIdx $glBssapDb CicConnection $connString]
									logscr ""
					                logscr "Warning: CicConnection ($connString) already assigned for MS $idx"
					                logscr ""
									exit
								}

								DbSet $glBssapDb $glMsId CicConnection $connString
								# Connect Mono Direction (mode=0) 
								SendPcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0
							} elseif { [DbGet $glBssapDb $glMsId PcmType] == 1 && [DbGet $glBssapDb $dstId PcmType] == 1 } {
								# All STM-1 mapped PCMs 
								set stm1Pcm1Line [DbGet $glBssapDb $glMsId Stm1Line]
								set stm1Pcm2Line [DbGet $glBssapDb $dstId Stm1Line]
								append lsuPcm1 -
								append lsuPcm1 $stm1Pcm1Line
								append lsuPcm2 -
								append lsuPcm2 $stm1Pcm2Line
								set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
								log "RcvApSyncReq: -All STM-1 mapped PCMs- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2"
								
								# TMA-342
								if { [DbKeyExists $glBssapDb CicConnection $connString] } {
							 		set idx [DbGetIdx $glBssapDb CicConnection $connString]
									logscr ""
					                logscr "Warning: CicConnection ($connString) already assigned for MS $idx"
					                logscr ""
									exit
								}
								# End TMA-342

								DbSet $glBssapDb $glMsId CicConnection $connString
								# Connect Mono Direction (mode=0)
								SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 4
							} elseif { [DbGet $glBssapDb $glMsId PcmType] == 0 && [DbGet $glBssapDb $dstId PcmType] == 1 } {
								# PCM 1: Electrical;  PCM 2: STM-1 mapped
								set stm1Pcm2Line [DbGet $glBssapDb $dstId Stm1Line]
								append lsuPcm2 -
								append lsuPcm2 $stm1Pcm2Line
								set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
								log "RcvApSyncReq: -PCM 1: Electrical;  PCM 2: STM-1 mapped- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2"

								# TMA-342
								if { [DbKeyExists $glBssapDb CicConnection $connString] } {
							 		set idx [DbGetIdx $glBssapDb CicConnection $connString]
									logscr ""
					                logscr "Warning: CicConnection ($connString) already assigned for MS $idx"
					                logscr ""
									exit
								}
								# End TMA-342

								DbSet $glBssapDb $glMsId CicConnection $connString
								# Connect Mono Direction (mode=0)
								SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 5
							} elseif { [DbGet $glBssapDb $glMsId PcmType] == 1 && [DbGet $glBssapDb $dstId PcmType] == 0 } {
								# PCM 1: STM-1 mapped; PCM 2: Electrical
								set stm1Pcm1Line [DbGet $glBssapDb $glMsId Stm1Line]
								append lsuPcm1 -
								append lsuPcm1 $stm1Pcm1Line
								set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
								log "RcvApSyncReq: -PCM 1: STM-1 mapped; PCM 2: Electrical- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2"

								# TMA-342
								if { [DbKeyExists $glBssapDb CicConnection $connString] } {
							 		set idx [DbGetIdx $glBssapDb CicConnection $connString]
									logscr ""
					                logscr "Warning: CicConnection ($connString) already assigned for MS $idx"
					                logscr ""
									exit
								}
								# End TMA-342

								DbSet $glBssapDb $glMsId CicConnection $connString
								# Connect Mono Direction (mode=0)
								SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 6
							} else {
								logscr "RcvApSyncReq: WARNING: the Pcm2Type=[DbGet $glBssapDb $glMsId PcmType] and Pcm1Type=[DbGet $glBssapDb $dstId PcmType] fields must be equal to 0 or 1"
							}

							# ---------------- #
							# TMA-357
							# Carlo PATCH 17/02/2010 (nel caso Aflex occorre inserire nel Db
							# entrambe le connex diretta ed inversa nello stesso momento).
							# attenzione: gli indice dei BSC sono invertiti perche Ã¨ la connex inversa
							set connStringReverse "LsuPCM $lsuPcm1 $ts1 From LsuPCM $lsuPcm2 $ts2 BSC2 $bsc1id BSC1 $bsc2id"
							log "RcvApSyncReq: dstId=$dstId connStringReverse=$connStringReverse"; #cDEBUG

							# Carlo PATCH for Alcatel Shanghai 03/06/2010
							###
							if { [DbKeyExists $glBssapDb CicConnection $connStringReverse] } {
								set idx [DbGetIdx $glBssapDb CicConnection $connStringReverse]
								log ""
								log "RcvApSyncReq: WARNING: CicConnection ($connStringReverse) already assigned for MS $idx"
								log ""
								if { ![IsVoid $lsuPcm1] && ![IsVoid $lsuPcm2] } {
									log "RcvApSyncReq: ERROR! (idx=$idx)"
									exit
								} elseif { [IsVoid $lsuPcm1] && [IsVoid $lsuPcm2] } {
									log "RcvApSyncReq: OK --> case of NO Traffic Testing (idx=$idx)"
								} else {
									log "RcvApSyncReq: WARNING ... to check in the TrafficDb the field LsuPcm"
								}
								log "RcvApSyncReq: Any setting of the 'CicConnection' field done in the $glBssapDb"
							} else {
								DbSet $glBssapDb $dstId CicConnection $connStringReverse
							}
							###
							# ---------------- #

							#LogDb $glBssapDb; #cDEBUG

						} else {
							logscr "RcvApSyncReq: WARNING!: in the TrafficDb the field LsuPcm are void"
						}
						# ### #
						if { [info exists __tstm_db] } {
							set tstmIndexOwn [gettstmindex]
	
							set pcmType1	[DbGet $glBssapDb $glMsId PcmType] 
							set stm1Line1	[DbGet $glBssapDb $glMsId Stm1Line]
							set bscId1		[DbGet $glBssapDb $glMsId BscId]

							#Â§Â§Â§Â§Â§Â§ TMA-383 Â§Â§Â§Â§Â§#
							if { [IsVoid $lsuPcm1] && [IsVoid $lsuPcm2] } {
                    			log "RcvApSyncReq: case of NO TRAFFIC DATA Testing"
							} else { 
								# Signal Building
								set connect_sig [list BSSAP_TRAFFIC_DATA_IND $glMsId $lsuPcm1 $ts1 $pcmType1 $stm1Line1 $bscId1 $tstmIndexOwn "?"]

								if { [info exists __bssap_plmn]	&& $__bssap_plmn == "99f921" } {
									# only for Alcatel Velizy testbed where all2all userscripts use
									set protocolName "Fix2MCORE"
								} else {
									set protocolName "M2MCCORE"
								}

								log "RcvApSyncReq: glMsId=$glMsId tstmIndexOwn=$tstmIndexOwn protocolName=$protocolName"

								# Inform CORE Tstm the connected PCM for the mobile on this MSC
								sendtotstm 0 $protocolName $connect_sig

								log "$connect_sig --> MsId=[lindex $connect_sig 1]"; #cDEBUG
							}
							#Â§Â§Â§Â§Â§Â§#

						} else {
							log "RcvApSyncReq: __tstm_db doesn't exist"
						}
						# ### #
					} else {
						# Traffic connection data not available
						log "RcvApSyncReq: Traffic connection data not available"; #cDEBUG

						if { [info exists __tstm_db] } {
							set tstmIndexOwn [gettstmindex]
	
							set pcmType1	[DbGet $glBssapDb $glMsId PcmType] 
							set stm1Line1	[DbGet $glBssapDb $glMsId Stm1Line]
							set bscId1		[DbGet $glBssapDb $glMsId BscId]
		
							#Â§Â§Â§Â§Â§Â§ TMA-383 Â§Â§Â§Â§Â§#
							if { [IsVoid $lsuPcm1] && [IsVoid $lsuPcm2] } {
                    			log "RcvApSyncReq: case of No TRAFFIC DATA Testing"
							} else { 
								# Signal Building
								set connect_sig [list BSSAP_TRAFFIC_DATA_IND $glMsId $lsuPcm1 $ts1 $pcmType1 $stm1Line1 $bscId1 $tstmIndexOwn "?"]

								if { [info exists __bssap_plmn]	&& $__bssap_plmn == "99f921" } {
									# only for Alcatel Velizy testbed where all2all userscripts use
									set protocolName "Fix2MCORE"
								} else {
									set protocolName "M2MCCORE"
								}

								log "RcvApSyncReq: glMsId=$glMsId tstmIndexOwn=$tstmIndexOwn protocolName=$protocolName"

								# Inform CORE Tstm the connected PCM for the mobile on this MSC
								sendtotstm 0 $protocolName $connect_sig

								log "$connect_sig --> MsId=[lindex $connect_sig 1]"; #cDEBUG
							}
							#Â§Â§Â§Â§Â§Â§#

						} else {
							log "RcvApSyncReq: __tstm_db doesn't exist"
						}
					}
					# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% #
				} else {
					# No A_Flex case
					set lac2 [DbGet $glBssapDb $dstId LAC]
					set cell2id [DbGet $glBssapDb $dstId CellId]

					log "RcvApSyncReq: dstId=$dstId; lac2=$lac2; cell2id=$cell2id"; #cDEBUG

					set bsc2id [GetBscIdByCellIdfr $lac2 $cell2id glBtsDb]
					if { $bsc2id == "-1" } {
						abort "BSC2 identity unknown (LAC2=$lac2, Cell2Id=$cell2id)"
					}
					set trfDb2 [GetTrfDbByMsId $dstId]
					log "RcvApSyncReq: dstId=$dstId; trfDb2=$trfDb2; bsc2id=$bsc2id"

					set cic2_ext [DbGet $glBssapDb $dstId CicExt]
					set cic2 [GetCicByExtCic $cic2_ext]
					log "RcvApSyncReq: cic2_ext=$cic2_ext"
					if { [string is integer -strict $cic2] } {
						set pcm2 [expr {$cic2 >> 5}]
						set ts2 [expr {$cic2 & 0x1f}]
						if { [DbKeyExists $trfDb2 Pcm $pcm2] } {
							set lsuPcm2Idx [DbGetIdx $trfDb2 Pcm $pcm2] 
							set lsuPcm2 [DbGet $trfDb2 $lsuPcm2Idx LsuPcm]
							
							log "RcvApSyncReq: lsuPcm2Idx=$lsuPcm2Idx; lsuPcm2=$lsuPcm2"; #cDEBUG
							DbSet $glBssapDb $dstId LsuPcm $lsuPcm2

							if { [DbFieldExists $trfDb2 PcmType] } {
								DbSet $glBssapDb $dstId PcmType [DbGet $trfDb2 $lsuPcm2Idx PcmType]
								DbSet $glBssapDb $dstId Stm1Line [DbGet $trfDb2 $lsuPcm2Idx Stm1Line]

							}
						} else {
							abort "Error: PCM2 ($pcm2) does not exist in Traffic Db"
						}
						
						set spc [DbGet $glBssapDb $glMsId Spc]
						set stkid [DbGet $glBssapDb $glMsId StkId]

						if { ![IsVoid $lsuPcm1] && ![IsVoid $lsuPcm2] } {
							if { ![DbFieldExists $trfDb1 PcmType] || ![DbGet $glBssapDb $glMsId PcmType] } {
								if { ![DbFieldExists $trfDb2 PcmType] || ![DbGet $trfDb2 $lsuPcm2Idx PcmType] } {
									# All Electrical PCMs [PCM 1 (In): Electrical;  PCM 2 (Out): Electrical]
									set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
									log "RcvApSyncReq: -All Electrical PCMs- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2 connString=$connString"
									DbSet $glBssapDb $glMsId CicConnection $connString
									# Connect Mono Direction (mode=0)
									SendPcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0
								} elseif { [DbGet $trfDb2 $lsuPcm2Idx PcmType] == 1 } {
									# PCM 1 (In): Electrical;  PCM 2 (Out): STM-1 mapped
									set stm1Pcm2Line [DbGet $glBssapDb $dstId Stm1Line]
									append lsuPcm2 -
									append lsuPcm2 $stm1Pcm2Line
									set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
									log "RcvApSyncReq: -PCM 1: Electrical;  PCM 2: STM-1 mapped- connString=$connString"
									DbSet $glBssapDb $glMsId CicConnection $connString
									# Connect Mono Direction (mode=0)
									SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 5
								} else {
									log "ERRORE: non deve entrare mai qui! (lsuPcm2Idx=$lsuPcm2Idx)"; #cDEBUG
								}
							} elseif { [DbGet $glBssapDb $glMsId PcmType] == 1 && [DbGet $trfDb2 $lsuPcm2Idx PcmType] == 1 } {
								# All STM-1 mapped PCMs 
								set stm1Pcm1Line [DbGet $glBssapDb $glMsId Stm1Line]
								set stm1Pcm2Line [DbGet $glBssapDb $dstId Stm1Line]
								append lsuPcm1 -
								append lsuPcm1 $stm1Pcm1Line
								append lsuPcm2 -
								append lsuPcm2 $stm1Pcm2Line
								set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
								log "RcvApSyncReq: -All STM-1 mapped PCMs- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2 connString=$connString"
								DbSet $glBssapDb $glMsId CicConnection $connString
								# Connect Mono Direction (mode=0)
								SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 4
							} elseif { [DbGet $glBssapDb $glMsId PcmType] == 1 && ![DbGet $trfDb2 $lsuPcm2Idx PcmType] } {
								# PCM 1 (In): STM-1 mapped; PCM 2 (Out): Electrical
								set stm1Pcm1Line [DbGet $glBssapDb $glMsId Stm1Line]
								append lsuPcm1 -
								append lsuPcm1 $stm1Pcm1Line
								set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
								log "RcvApSyncReq: -PCM 1: STM-1 mapped; PCM 2: Electrical- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2 connString=$connString"
								DbSet $glBssapDb $glMsId CicConnection $connString
								# Connect Mono Direction (mode=0)
								SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 6
							} else {
								logscr "RcvApSyncReq: ERROR --> the Pcm2Type=[DbGet $glBssapDb $glMsId PcmType] and Pcm1Type=[DbGet $glBssapDb $dstId PcmType] fields must be equal to 0 or 1"
							}
						}
					} else {
						logscr "RcvApSyncReq: ERROR: invalid cic value! (cic2=$cic2)"
						log "WARNING: potrebbe essere un mobile con codec di tipo tdm ed il mobile connesso con codec di tipo ip"	
					}
					
					set pcm1	[GetPcmbyLsuPcm $lsuPcm1 $bsc1id $trfDb1]
					log "RcvApSyncReq: lsuPcm1=$lsuPcm1; pcm1=$pcm1; bsc1id=$bsc1id; trfDb1=$trfDb1"; #cDEBUG

					if { [info exists lsuPcm2] } {
						set pcm2	[GetPcmbyLsuPcm $lsuPcm2 $bsc2id $trfDb2]
						log "RcvApSyncReq: lsuPcm2=$lsuPcm2; pcm2=$pcm2; bsc2id=$bsc2id; trfDb2=$trfDb2"; #cDEBUG
					} else {
						abort "RcvApSyncReq: lsuPcm2 doesn't exist"
					}
				}
			} else {
				# Carlo 08/06/2010 debug start -- #
				if { [IsEmpty $dstId] || [IsVoid $dstId] } {
					log "dstId empty or void --> any PCM attendant"
				} elseif { [IsEmpty $dphoneFlag] || [IsVoid $dphoneFlag] } {
					log "dphoneFlag empty or void --> any codec attendant"
				} elseif { ![IsVoid $dphoneFlag] } {
					log "dphoneFlag=$dphoneFlag"
				} elseif { [isSplitted] } {
					log "Tstm is Splitted"
				}
				# -- debug end-- #
				log "RcvApSyncReq: dstmsid void, checking codec"
				set dphone [DbGet $glBssapDb $glMsId DPhone]
				if { ![IsVoid $dphone] } {
					logscr "RcvApSyncReq: found a dphone=$dphone"

					set lac [DbGet $glBssapDb $glMsId LAC]
					set cellid [DbGet $glBssapDb $glMsId CellId]
					set bscid [GetBscIdByCellIdfr $lac $cellid glBtsDb]
					if { $bscid == "-1" } {
						abort "BSC identity unknown (LAC=$lac, CellId=$cellid)"
					}
					log "RcvApSyncReq: glMsId=$glMsId dstId=$dstId  bscid=$bscid"
					set trfDb [DbGetName [DbGet $glBscDb $bscid TrafficLinksDb]]
					set trfDb1 [GetTrfDbByMsId $glMsId]
					log "RcvApSyncReq: trfDb1=$trfDb1"
					set cic1_ext [DbGet $glBssapDb $glMsId CicExt]
					set cic1 [GetCicByExtCic $cic1_ext]
					log "RcvApSyncReq: cic1_ext=$cic1_ext"
					set pcm1 [expr {$cic1 >> 5}]
					set ts1 [expr {$cic1 & 0x1f}]
					if { [DbKeyExists $trfDb1 Pcm $pcm1] } {
						set lsuPcmIdx [DbGetIdx $trfDb1 Pcm $pcm1]
						set lsuPcm1 [DbGet $trfDb1 $lsuPcmIdx LsuPcm]
					} else {
						abort "Error: PCM does not exist in Traffic Db"
					}

					set spc [DbGet $glBssapDb $glMsId Spc]
					set stkid [DbGet $glBssapDb $glMsId StkId]

					if { ![IsVoid $lsuPcm1] } {
						if { ![DbFieldExists $trfDb1 PcmType] || ![DbGet $trfDb1 $lsuPcmIdx PcmType] } {
							# case of ToFrom=3: to: codec from: pcm (see: ss7_om.h)
							set connString "LsuPCM DPHONE $dphone From LsuPCM $lsuPcm1 $ts1 FIX ? BSC1 $bscid"
							log "RcvApSyncReq: Electrical LsuPCM --> DPHONE: lsuPcm1=$lsuPcm1 --> dphone=$dphone"
							DbSet $glBssapDb $glMsId CicConnection $connString
							# Connect Mono Direction (mode=0) 
							SendPcmConnect $spc $stkid DPHONE $dphone $lsuPcm1 $ts1 0
							if { ![IsVoid $dphoneFlag] } {
								# case of ToFrom=1: to: pcm from: codec (see: ss7_om.h)
								log "RcvApSyncReq: sending second PcmConnect"
								SendPcmConnect $spc $stkid $lsuPcm1 $ts1 DPHONE $dphone 0
							}
						} elseif { [DbGet $trfDb1 $lsuPcmIdx PcmType] == 1 } {
							# case of ToFrom=8: to: codec from: stm (see: ss7_om.h)
							set stm1Pcm1Line [DbGet $trfDb1 $lsuPcmIdx Stm1Line]
							append lsuPcm1 -
							append lsuPcm1 $stm1Pcm1Line
							set connString "LsuPCM DPHONE $dphone From LsuPCM $lsuPcm1 $ts1 FIX ? BSC1 $bscid"
							log "RcvApSyncReq: STM-1 mapped LsuPCM --> DPHONE: (stm1Pcm1Line=$stm1Pcm1Line; lsuPcm1=$lsuPcm1) --> dphone=$dphone"
							DbSet $glBssapDb $glMsId CicConnection $connString
							# Connect Mono Direction (mode=0) 
							SendMixedStm1PcmConnect $spc $stkid DPHONE $dphone $lsuPcm1 $ts1 0 8
							if { ![IsVoid $dphoneFlag] } {
								# case of ToFrom=8: to: codec from: stm (see: ss7_om.h)
								log "RcvApSyncReq: sending second MixedStm1PcmConnect"
								SendMixedStm1PcmConnect $spc $stkid $lsuPcm1 $ts1 DPHONE $dphone 0 7
							}
						} else {
							logscr "RcvApSyncReq: ERROR --> the Pcm1Type=[DbGet $trfDb1 $lsuPcmIdx PcmType] field have to be equal to 0 or 1"
						}
	
					} else {
						abort "Error: PCM not found"
					}
				} elseif { ![IsVoid $dstId] } {
					log "RcvApSyncReq: dstId=$dstId"
				} else {
					logscr "RcvApSyncReq: WARNING: neither PCM nor DPHONE were found"
				}
			}
			if { [info exists ::__Dbssap_PerCircReset] } {
				set lac [DbGet $glBssapDb $glMsId LAC]
				set cellid [DbGet $glBssapDb $glMsId CellId]
				set bscid1 [GetBscIdByCellIdfr $lac $cellid glBtsDb]
				# PERIODIC TDM CIRCUIT RESET
				TriggerPeriodicReset TDMCIRCUIT $bscid1
			}
		} elseif { $glAoip && $upType } {
			# AUoIP with UP IP or MIXED
			set lac [DbGet $glBssapDb $glMsId LAC]
			set cellid [DbGet $glBssapDb $glMsId CellId]
			set bscid1 [GetBscIdByCellIdfr $lac $cellid glBtsDb]
			log "RcvApSyncReq: la=$lac; cellid=$cellid; bscid1=$bscid1; upType=$upType"; #cDEBUG
			if { $upType == 2 } {
				if { [info exists ::__Dbssap_PerIpReset] } {
					# PERIODIC IP RESET
					TriggerPeriodicReset IPRESOURCE $bscid1
				}
			} elseif { $upType == 1 } {
				if { [info exists ::__Dbssap_PerIpReset] } {
					# PERIODIC IP RESET
					TriggerPeriodicReset IPRESOURCE $bscid1
				}
				if { [info exists ::__Dbssap_PerCircReset] } {
					# PERIODIC TDM CIRCUIT RESET
					TriggerPeriodicReset TDMCIRCUIT $bscid1
				}
			}
		}
		}
		default { logscr "Unexpected Sync Req Cause ($cause_tag)" }
	}
}

# BSSAP_AP_SYNC_REQ
proc RcvApSyncReqIdle { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# retrieving "cause_tag" from BSSAP_AP_SYNC_REQ
	set cause_val [rd _sig CauseVal]
	set cause_tag [lindex $cause_val 0]

	switch -exact -- $cause_tag {
		"SYNC_RES_ASS" {
		# resource assignment
			set calltype [rd cause_val CallType]
			switch -exact -- $calltype {
				"Speech" 	 {set spi 01}
				"UDI" 		 {set spi 02}
				"Signalling" {set spi 03}
				default	 {abort "Unexpected Call Type ($calltype)"}
			}
			set ch_rate [rd cause_val ChRate]
			set perm_speech [rd cause_val PermSpeech]
			set datarate [rd cause_val DataRate]
			set priority [rd cause_val Priority]
			set grCallRef [rd _sig GroupCallReference]
			if { [IsVoid $grCallRef] } {
				SendDediAssignmentReq $spi $ch_rate $perm_speech $datarate $priority	
			} else {
				SendDediAssignmentReq $spi $ch_rate $perm_speech $datarate $priority $grCallRef
			}
			ForceReset "after_assignment_command"
		}\
		default { logscr "Unexpected Sync Req Cause ($cause_tag)" }
	}
}

# BSSAP_AP_ABORT_REQ
proc RcvApAbortReq { } {

	global _sig glMsId glBssapDb glPagAttempts

	LogInputMsg $_sig

	# Stop Timer Paging (T_PAG) if it is active
	set tid [DbGet $glBssapDb $glMsId T_PAGid]
	if { [tmrrunning $tid] != 0 } {
		tmrstop $tid
		DbSet $glBssapDb $glMsId AbortReqFlag 1
		log "RcvApAbortReq: setting AbortReqFlag for MS=$glMsId"
	}

	# Restore PagAttempts
	DbSet $glBssapDb $glMsId PagAttempts $glPagAttempts
}

# Start TMA-236
# BSSAPGs_AP_ABORT_REQ
proc RcvApAbortGsReq { } {

	global _sig glMsId glBssapDb glPagAttempts

	LogInputMsg $_sig

	DbSet $glBssapDb $glMsId AbortReqFlagGs 1
	log "RcvApAbortGsReq: setting AbortReqFlagGs for MS=$glMsId"
}

# End TMA-236

# BSSAP_AP_ABORT_REQ
proc RcvApAbortReqRelease { } {

	global _sig glMsId glBssapDb 

	LogInputMsg $_sig

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause 09; # Cause "Call Control"

	# Clear Serving
	SendClrCmd [list $prot_disc $trans_id $cause]

	nextstate WaitForClrCmplt
}

# BSSAP_AP_CLSMK1_UPDATE
proc RcvApClsmk1Update { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	if { [DbEntryExists $glBssapDb $glMsId] } {
		# updating ClassMark1
		DbSet $glBssapDb $glMsId ClassMark1 [rd _sig ClassMark1]
	} else {
		logscr "RcvApClsmk1Update: unknown MsId=$glMsId"
		skipMsg
	}
}

# BSSAP_AP_CLSMK2_UPDATE
proc RcvApClsmk2Update { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# updating ClassMark2
	DbSet $glBssapDb $glMsId ClassMark2 [rd _sig ClassMark2]
}

# BSSAP_AP_CLSMK3_UPDATE
proc RcvApClsmk3Update { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# updating ClassMark3
	DbSet $glBssapDb $glMsId ClassMark3 [rd _sig ClassMark3]
}

#------------------------------------------------------------#
# sending primitives to upper level
#------------------------------------------------------------#

# BSSAP_CTL_RESET_ACK
proc SendBssapCtlResetAck { } {

	new 	BSSAP_CTL_RESET_ACK r

	send r
	LogOutputMsg $r
}

# BSSAP_AP_EST_IND
proc SendApEstInd { lai ci l3pdu } {

	global glSpcStkIdCid

	new 	BSSAP_AP_EST_IND r
	wr 		r SpcStkIdCid $glSpcStkIdCid
	wr      r LAI $lai
	wr      r CellId $ci
	wr      r Pdu $l3pdu

	send r
	LogOutputPrim $r
}

# BSSAP_AP_EST_CNF
proc SendApEstCnf { lai ci l3pdu } {

	global glSpcStkIdCid

	new BSSAP_AP_EST_CNF r
	wr 		r SpcStkIdCid $glSpcStkIdCid
	wr      r LAI $lai
	wr      r CellId $ci
	wr      r Pdu $l3pdu

	send r
	LogOutputPrim $r
}

# BSSAP_AP_REL_IND
proc SendApRelInd { cause } {

	global glMsId

	new BSSAP_AP_REL_IND r
	wr r MsId $glMsId
	wr r RelCause $cause

	LogOutputMsg $r
	send r
}

# BSSAP_AP_DATA_IND
proc SendApDataInd { l3pdu } {

	global glMsId
	
	new  BSSAP_AP_DATA_IND r 
	wr r MsId $glMsId
	wr r Pdu $l3pdu

	send r
	LogOutputPrim $r
}

# BSSAP_AP_SYNC_CNF
proc SendApSyncCnf { res cause } {

	global glMsId 

	new BSSAP_AP_SYNC_CNF r
	wr r MsId $glMsId
	wr r Res $res
	wr r Cause $cause

	send r
	LogOutputMsgv0 $r
}

proc EnqueueApDataReq { } {

	global _sig glBssapDb glMsId

	LogInputMsg $_sig
	log "[lindex $_sig 0] Enqueued"
	
	# Store AP_DATA_REQ_REQ in DataBase
	DbSet $glBssapDb $glMsId ApDataReqBuf $_sig
}

# Start TMA-186
proc EnqueueApSyncReq { } {

	 global _sig glBssapDb glMsId
	 
	 LogInputMsg $_sig
	 log "[lindex $_sig 0] Enqueued"

         # Store AP_SYNC_REQ_REQ in DataBase
         DbSet $glBssapDb $glMsId ApSyncReqBuf $_sig

}
# End TMA-186


proc DequeueApDataReq { } {

	global _sig _state glBssapDb glMsId

	# Reschedule
	set msg [DbGet $glBssapDb $glMsId ApDataReqBuf]
	if { ![IsVoid $msg] } {
		set _sig $msg
		log "[lindex $_sig 0] Dequeued"
		DbSet $glBssapDb $glMsId ApDataReqBuf "?"
		eval $_state
	}

	# Start TMA-186
	set msg1 [DbGet $glBssapDb $glMsId ApSyncReqBuf]
        if { ![IsVoid $msg1] } {
                set _sig $msg1
                log "[lindex $_sig 0] Dequeued"
                DbSet $glBssapDb $glMsId ApSyncReqBuf "?"
                eval $_state
        }

	# End TMA-186
}

proc RestoreEvent { } {

	global _sig _state glBssapDb glMsId

	set retVal 0

	# Reschedule
	set msg [DbGet $glBssapDb $glMsId ApHeldEventBuf]
	if { ![IsVoid $msg] } {
		set _sig $msg
		log "[lindex $_sig 0] Restored"
		DbSet $glBssapDb $glMsId ApHeldEventBuf "?"
		eval $_state
		set retVal 1
	}
	
	return $retVal
}

proc RecvConnAckDediReq { } {
	global _sig glBssapDb glMsId

	LogInputMsg $_sig

	# Store SpcStkIdCidTarget
	DbSet $glBssapDb $glMsId SpcStkIdCid [rd _sig SpcStkIdCid]

	nextstate WaitForDediConnectCnf
}

proc RecvConnCnfDediReq { } {
	nextstate WaitForDediAsgCmplte
}

proc RecvAsgCmplteDediReq { } {

	global _sig glAoip glBssapDb glMsId
	
	LogInputMsgv0 $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	if { $glAoip && $upType } {
		set spch_ver [rd _sig speech_ver]
		DbSet $glBssapDb $glMsId SpeechVer $spch_ver
		DbSet $glBssapDb $glMsId SpeechCodec [rd _sig speech_codec]

		if { [ForceReset "after_assignment_complete"] } {
			return
		}
		set aupoip_container [rd _sig aoip_tla]

		if { ![IsEmpty $aupoip_container] && ![IsVoid $aupoip_container] } {
			# in the IP or MIXED case the TLA isn't void
			UPoIPcnGet $aupoip_container ip_add port

			DbSet $glBssapDb $glMsId DestIp $ip_add
			DbSet $glBssapDb $glMsId DestPort $port
			log "RecvAsgCmplteDediReq: spch_ver = $spch_ver; ip_add = $ip_add; port = $port"
		}

		if { [IpUpSupported] } {
			set localIp 	[DbGet $glBssapDb $glMsId LocalIp]
			set localPort 	[DbGet $glBssapDb $glMsId LocalPort]
			if { [DbKeyExists $glBssapDb IpAddPort $localIp-$localPort] } {
				log "RecvAsgCmplteDediReq: idx=[DbGetIdx $glBssapDb IpAddPort $localIp-$localPort] --> IpAddPort_db=[DbGet $glBssapDb $glMsId IpAddPort]"
			} else {
				log "RecvAsgCmplteDediReq: ERROR: IpAddPort doesn't exist in the BssapDb"
				DbSet $glBssapDb $glMsId IpAddPort $localIp-$localPort
			}

			ActivateAoipResources $localIp $localPort $ip_add $port
			nextstate WaitRtpOpenAck
		} else {
			logv4 "RecvAsgCmplteDediReq: UserPlane over IP isn't supported: just signalling over IP"
			SendSyncCnf
		}
	} elseif { !$glAoip || $upType == 0 } {
		logv4 "RecvAsgCmplteDediReq: case glAoip=0 or upType=0"
		SendSyncCnf
	} else {
		logscr "RecvAsgCmplteDediReq: ERROR: glAoip=$glAoip; upType=$upType"
	}
}

proc RecvAsgFailDediReq { } {
	
	global _sig glBssapDb glMsId glAoip

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Sending BSSAP_AP_SYNC_CNF (cause: -1 = Resource Assignment Failed)
	set res "-1"
	set cause [rd _sig cause]
	SendApSyncCnf $res $cause

	if { !$glAoip || $upType == 0 } {
		# Traffic Resource
		set cic [DbGet $glBssapDb $glMsId Cic] 
		if { ![IsVoid $cic] } {
			# CICEXT
			set spc [DbGet $glBssapDb $glMsId Spc]
			#cicRelease $cic
			CicReleaseExt $cic $spc
	
			DbSet $glBssapDb $glMsId Cic "?"
			log "BSSAP: Releasing Cic $cic"
			DbSet $glBssapDb $glMsId CicExt "?"
		}
		DisconnectResources	$glMsId $glBssapDb
	}
	nextstate BssapConnectActive
}

proc RecvDediRelReqAsgCmplte { } {
	
	global _sig glBssapDb glMsId glAoip

	LogInputMsg $_sig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	# Sending BSSAP_AP_SYNC_CNF (cause: -1 = Resource Assignment Failed)
	set res "-1"
	set cause [rd _sig cause]
	SendApSyncCnf $res $cause

	if { !$glAoip || $upType == 0 } {
		# Traffic Resource
		set cic [DbGet $glBssapDb $glMsId Cic] 
		if { ![IsVoid $cic] } {
			# CICEXT
			set spc [DbGet $glBssapDb $glMsId Spc]
			#cicRelease $cic
			CicReleaseExt $cic $spc
	
			DbSet $glBssapDb $glMsId Cic "?"
			log "BSSAP: Releasing Cic $cic"
			DbSet $glBssapDb $glMsId CicExt "?"
		}
		DisconnectResources	$glMsId $glBssapDb
	}
	nextstate BssapConnectActive
}

#------------------------------------------------------------#
# primitives from RTP (used just in AUoIP)
#------------------------------------------------------------#

proc RecvRtpOpenAck { } {

	if { [info exists ::__aoip_rtp_ssrc] && $::__aoip_rtp_ssrc != 0 } {
		SyncronizationSourceSetting
	}

	if { [ConfigureAoipResources] == 0 } {
		SendSyncCnf
	}
}

proc RecvRtpOpenAckHo { } {

	ConfigureAoipResources

	set prot_disc 6; # RR protocol discriminator
	set trans_id 0
	set cause 0b; # Cause "Handover Successfull"
	SendClrCmd [list $prot_disc $trans_id $cause]

	nextstate _c_WaitForClrCmpltHov
	
	DequeueApDataReq
}

proc RecvRtpOpenAckIntHo { } {

	global glBssapDb glMsId

	ConfigureAoipResources

	# Cell Identification: Target --> Serving
	DbSet $glBssapDb $glMsId LAC [DbGet $glBssapDb $glMsId LACTarget]
	DbSet $glBssapDb $glMsId CellId [DbGet $glBssapDb $glMsId CellIdTarget]
	DbSet $glBssapDb $glMsId LACTarget "?"
	DbSet $glBssapDb $glMsId CellIdTarget "?"

	nextstate BssapConnectActive	
	
	DequeueApDataReq
}

proc RecvRtpOpenNak { } {

	global _sig

	LogInputSig

	if { [rd _sig Res] == -16 } {
		log "RecvRtpOpenNak: ERROR in the Bind: (Address already in use)"
		log "RecvRtpOpenNak: Inst=[rd _sig Inst]; RtpId=[rd _sig RtpId]; LocalAdd=[rd _sig LocalAdd]; LocalPort=[rd _sig LocalPort]"
	} else {
		exit
	}
}

proc SLAVE_RecvCicAsgRes_HovReq { } {

	global _sig glBscDb glBssapDb glMsId glMsDb glAoip
	
	LogInputSig

	if { $glAoip } {
		set upType [DbGet $glBssapDb $glMsId UpType]
	}

	set fail			[rd _sig Fail]
	set msId			[rd _sig MsId]
	#set cic				[rd _sig Cic]
	set cic_tgt			[rd _sig Cic]
	set cic_ext			[rd _sig CicExt]
	set permSpeechIndex	[rd _sig PermSpeechIndex]

	log "SLAVE_RecvCicAsgRes_HovReq msId=$msId glMsId=$glMsId"

	set buffer [DbGet $glBssapDb $msId AsgReqBuffer]
	set ch_type [lindex $buffer 0]
	set perm_speech [lindex $buffer 1]
	set spi [lindex $buffer 2]
	set ch_rate [lindex $buffer 3]

	#set grCallRef [lindex $buffer 4]
	#set priority [lindex $buffer 5]
	#set bscid [lindex $buffer 6]

	set bsc_tgt [lindex $buffer 4]
	set datarate [lindex $buffer 5]
	set cause [lindex $buffer 6]
	set curr_ch_type_1 [lindex $buffer 7]
	set spch_ver [lindex $buffer 8]
	set encr_info [lindex $buffer 9]
	set clmark2 [lindex $buffer 10]
	set cell_idfr_srvng [lindex $buffer 11]
	set cell_idfr_tgt [lindex $buffer 12] 

	if { $fail } {
		logscr "External Handover procedure failed \
			([BssapGetProtocolCause $protName $fail])"
		set rqrd [DbGet $glBssapDb $msId ResponseForHORequired]
		if { ![IsVoid $rqrd] } {
			# Send HO failure
			set spcstkidcid [DbGet $glBssapDb $msId SpcStkIdCid]
			new HOV_RQRD_REJ s
			wr	s	cause	22 
			SendSccpNDataReq $spcstkidcid $s
		}
		
		nextstate BssapIdle
		#return -2
	} else {
		#DbSet $glBssapDb $glMsId CicTarget $cic_tgt
		#DbSet $glBssapDb $glMsId CicExt $cicExt
		set cic_ext [GetExtCic $bsc_tgt $cic_tgt]
		log "SLAVE_RecvCicAsgRes_HovReq: writing cics: cic_tgt=$cic_tgt bsc_tgt=$bsc_tgt cic_ext=$cic_ext"
		DbSet $glBssapDb $glMsId CicExtTarget $cic_ext
		set circ_idty_code [ustoh $cic_tgt B]
	}

	# DTX Flag
	set dtx_flag [DbGet $glBscDb $bsc_tgt DTXflag]
	if { [string match {[01]} $dtx_flag] } {
		set dtx_flag [uctoh $dtx_flag]
	} else {
		set dtx_flag "?"
	}

	# Cause 
	#set cause [rd hov_req cause]

	# Current Channel Type 1
	#set curr_ch_type_1 [rd hov_req curr_ch_type_1]

	# Speech Version (Used)
	#set spch_ver [rd hov_req spch_ver]

	new HOV_REQ s

	set override 0
	# When the QueueIdList Db field is used, the correction is not done
	if { [DbFieldExists $glMsDb QueueIdList] } {
		if { ![IsVoid [DbGet $glMsDb $glMsId QueueIdList]] } {
			set override 1
		}
	}

	if { $permSpeechIndex != 0 && !$override } {
		set len [string length $perm_speech]
		set chType [string range $perm_speech [expr $permSpeechIndex * 2] end]
	} else {
		set chType $perm_speech
	} 

	log "SLAVE_RecvCicAsgRes_HovReq: chType=$chType"

	wr 	s ch_type [GetChannelType $spi $ch_rate $chType $datarate]
	wr 	s encr_info $encr_info
	wr 	s clsmk_info_2 $clmark2
	wr 	s cell_idfr_srvng $cell_idfr_srvng
	wr 	s prio [DbGet $glBssapDb $glMsId Priority]
	wr 	s dwl_dtx_flag $dtx_flag
	wr 	s cell_idfr_tgt $cell_idfr_tgt
	wr 	s cause $cause
	wr 	s clsmk_info_3 [DbGet $glBssapDb $glMsId ClassMark3]
	wr 	s curr_ch_type_1 $curr_ch_type_1
	wr 	s spch_ver $spch_ver

	if { $glAoip && $upType } {

		UPoIPcnSet aoipMgwAddr port callid
	
		DbSet $glBssapDb $glMsId HoLocalIp $aoipMgwAddr
		DbSet $glBssapDb $glMsId HoLocalPort $port

		wr s aoip_tla [GetAUPoIPContainer $aoipMgwAddr $port]
		wr s codec_list [DbGet $glMsDb $glMsId AoipMscPcl]
		wr s call_id [DbGet $glBssapDb $glMsId CallId]
	} elseif { !$glAoip || $upType == 0 } {
		wr  s circ_idty_code $circ_idty_code
	} else {
		logscr "SLAVE_RecvCicAsgRes_HovReq: ERROR: glAoip=$glAoip; upType=$upType"
	}

	# Get info to pass to the new Bss
	set oldToNewBssInfo [DbGet $glBssapDb $glMsId OldToNewBssInfo]
	if { ![IsVoid $oldToNewBssInfo] } {
		log "SLAVE_RecvCicAsgRes_HovReq: oldToNewBssInfo=$oldToNewBssInfo"
		wr s	old_bss_to_new_bss_info	$oldToNewBssInfo
		# TMA-262
		# check if the Ms is DTM and sends the IMSI
        if { [hgetb $oldToNewBssInfo 0] == 6} {
			global glMsDb
           	set Imsi [DbGet $glMsDb $glMsId IMSI]
			wr s imsi $Imsi
		}
		# TMA-262 
		# Clear the field
		DbSet $glBssapDb $glMsId OldToNewBssInfo "?"
	}

	LogOutputMsg $s

	SendSccpNConnectReq $glBscDb $msId $bsc_tgt $s

	nextstate WaitForConnAckInHovReq

	return 0
}

proc SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd { } {

	global _sig glMsId glBssapDb

	LogInputSig

	set name "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd"

	if { $::glAoip } {
		# Serving UserPlane Type (Ã¨ quello reale dato dalla ASG_CMPL)
		set serving_UpType [DbGet $glBssapDb $glMsId ServingUpType]
		Trace "log" $::__trace_AUoIP $name "serving_UpType=$serving_UpType"
	}

	set targetMscCodec  [DbGet $glBssapDb $glMsId HoSpeechCodec]
	
	# Target UserPlane Type
	set target_UpType [DbGet $glBssapDb $glMsId TargetUpType]

	log "DEBUGGING INT_HOV (Multiprocess): (glMsId=$glMsId): serving_UpType=$serving_UpType --> target_UpType=$target_UpType"

	if { $target_UpType == "MIXED" || [CodecSelectionByBsc] } {
		# --> MIXED or case of codec selected by BSC
		if { ![string compare [lindex $_sig 0] "BSSAP_CIC_ASG_RES"] } {
			#set circ_idty_code [ustoh [DbGet $glBssapDb $glMsId Cic] B]
			set cic			[rd _sig Cic]
			log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: cic=$cic for glMsId=$glMsId"
			if { ![IsVoid $cic] } { 
				DbSet $glBssapDb $glMsId Cic $cic; #messo anche nel master (slave e master hanno due BssapDb distinti)
				set bscid [GetBscIdByLacCellId]
				set cic_ext [GetExtCic $bscid $cic]
				log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: cic=$cic bscid=$bscid --> cic_ext=$cic_ext"	
				DbSet $glBssapDb $glMsId CicExt $cic_ext
				set circ_idty_code [ustoh $cic B]
				log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: glMsId=$glMsId; circ_idty_code=$circ_idty_code"
			} else {
				set circ_idty_code ?
				log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: WARNING: cic is void !!!"
			}
		} elseif { ![string compare [lindex $_sig 0] "BSSAP_TLA_ASG_RES"] } {
			set tla_container	[rd _sig Aoip_Tla]
			set callid			[rd _sig CallId]
			log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: callid=$callid; tla_container=$tla_container"

			# patch for TMA-484 01/07/2012
			set ip_value [GetIpAddressFromContainer $tla_container]
			set port_value [GetUdpPortFromContainer $tla_container]

			if { ![DbKeyExists $glBssapDb IpAddPort $ip_value-$port_value] } {
				DbSet $glBssapDb $glMsId IpAddPort $ip_value-$port_value
			} else {
				logv1 "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: ERROR: IpAddPort=$ip_value-$port_value already exists in BssapDb (msid:$glMsId)"
			}
			# end patch

			##############
			# Carlo 11/01/2012 ATTENZIONE FIX (in Milan is OK; TO BE TESTED IN ASB)
			set oldCallId [DbGet $glBssapDb $glMsId CallId]
			log "ATTENTION: change value of the CallId after INT_HOV preocedure: oldCallId=$oldCallId --> newCallId=$callid"
			DbSet $glBssapDb $glMsId CallId $callid
			############

			# TMA-447 Carlo workaround 06/02/2012 --
			set sendResetIpForCallId	[DbGet $glBssapDb $glMsId SendResetIpForCallId]
			if { $sendResetIpForCallId } {
				logv4 "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: --> ERROR: sendResetIpForCallId=$sendResetIpForCallId"
				DbSet $glBssapDb $glMsId SendResetIpForCallId 0; #Carlo temporary workaround
			}
			logv4 "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: SendResetIpForCallId=[DbGet $glBssapDb $glMsId SendResetIpForCallId]"
			# --
		} else {
			log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: ERROR: unexpected message"
		}
	} elseif { !$::glAoip || $target_UpType == "TDM" } {
		# --> TDM
		set circ_idty_code [ustoh [DbGet $glBssapDb $glMsId Cic] B]
	} elseif { $target_UpType == "IP" } {
		# --> IP
		set ppuId			[rd _sig PpuId]
		set tla_container	[rd _sig Aoip_Tla]
		set callid			[rd _sig CallId]
		set ip 				[GetIpAddressFromContainer $tla_container]
		set port 			[GetUdpPortFromContainer   $tla_container]

		log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: ppuId=$ppuId; callid=$callid; tla=$tla_container --> ip=$ip; port=$port"
		
		# TMA-447 Carlo workaround 06/02/2012 --
		set sendResetIpForCallId	[DbGet $glBssapDb $glMsId SendResetIpForCallId]
		if { $sendResetIpForCallId } {
			logv4 "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: ----> ERROR: SendResetIpForCallId=$sendResetIpForCallId"
			DbSet $glBssapDb $glMsId SendResetIpForCallId 0; #Carlo temporary workaround
		}
		logv4 "SendResetIpForCallId=[DbGet $glBssapDb $glMsId SendResetIpForCallId]"
		# --
	}

	new INTERNAL_HO_CMD r

	if { ![string equal $target_UpType $serving_UpType] && [string equal $serving_UpType "TDM"] } {
		log "TDM --> IP/MIXED (only in this case is present the 'Call identifier' IE)"
		wr r call_id $callid
	} else {
		# All other cases
		# in case IP --> IP the 'Call identifier' IE isn't present in the INTERNAL_HO_CMD
	}

	if { $serving_UpType == "TDM" && $target_UpType == "TDM" } {
		log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: case (TDM --> TDM) forbidden: nothing action done for glMsId=$glMsId"
		return
	}

    wr r speech_codec $targetMscCodec

	if { $target_UpType == "MIXED" || [CodecSelectionByBsc] } {
	# target = MIXED or case of codec selected by BSC
		log "entro qui (CodecSelectionByBsc=[CodecSelectionByBsc])"; #cDEBUG
		if { ![string compare [lindex $_sig 0] "BSSAP_CIC_ASG_RES"] } {
			if { ![IsVoid $circ_idty_code] && ![IsEmpty $circ_idty_code] } {
				wr r cic $circ_idty_code
			} elseif { [IsVoid $circ_idty_code] && $target_UpType == "MIXED" || [IsVoid $circ_idty_code] && [DbGet $glBssapDb $glMsId UpType] == "MIXED" } {
				log "no TDM resources availables --> MSC continues with 'INTERNAL_HO_CMD' done only over IP"
				return
			} else {
				log "target_UpType=$target_UpType; MscUpType=[DbGet $glBssapDb $glMsId UpType]"
				log "SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd: circ_idty_code is void --> skip the 'INTERNAL_HO' procedure"
				return
			}
		} elseif { ![string compare [lindex $_sig 0] "BSSAP_TLA_ASG_RES"] } {
			wr r aoip_tla $tla_container
		}
	} elseif { !$::glAoip || $target_UpType == "TDM" && $serving_UpType != "TDM" } {
	# IP --> TDM
		if { ![IsVoid $circ_idty_code] } {
			wr r cic $circ_idty_code
		} else {
			# skip the internal ho procedure because no tdm resource available
			return
		}
	} elseif { $target_UpType == "IP" } {
	# xxx --> IP
		wr r aoip_tla $tla_container
	}
	
	LogOutputMsg $r
	set spcstkidcid [DbGet $glBssapDb $glMsId SpcStkIdCid]
	SendSccpNDataReq $spcstkidcid $r

	nextstate _c_WaitForIntHovProcCompleted
}

proc RcvApNewTmsiAlloc { } {

	global _sig

	LogInputSig

	new BSSAP_NEW_TMSI_ALLOC s
	wr	s	MsId	[rd _sig MsId]
	wr	s	TMSI	[rd _sig TMSI]

	send s
}

proc RcvNewTmsiAlloc { } {

	global _sig glBssapDb

	LogInputSig

	set msId [rd _sig MsId]
	set tmsi [rd _sig TMSI]
	set tmsi [string range $tmsi 2 9]

	log "RcvNewTmsiAlloc: msId=$msId TMSI=$tmsi"

	DbSet $glBssapDb $msId TMSI $tmsi
}

######################################
# A-FLEX: Traffic Resources Management
######################################

proc RcvTrafficDataInd { } {

	global _sig glBssapDb glMsId glBtsDb

	LogInputSig

	set msId 		[rd _sig MsId]
	set lsuPcm2		[rd _sig LsuPcm]
	set ts2			[rd _sig Ts]
	set pcmType2	[rd _sig PcmType]
	set stm1Line2	[rd _sig Stm1Line]
	set tstmIndex2	[rd _sig TstmIndex]
	set dstId		[rd _sig DestMsId]
	set bsc2id		[rd _sig BscId]

	log "RcvTrafficDataInd: glMsId=$glMsId --> msId=$msId; lsuPcm2=$lsuPcm2; ts2=$ts2; pcmType2=$pcmType2; stm1Line2=$stm1Line2; tstmIndex2=$tstmIndex2; bsc2id=$bsc2id               dstId=$dstId"; #cDEBUG

	# Save Traffic Served Instance in Db
	DbSet $glBssapDb $msId LsuPcm $lsuPcm2
	DbSet $glBssapDb $msId Ts $ts2
	DbSet $glBssapDb $msId PcmType $pcmType2
	DbSet $glBssapDb $msId Stm1Line $stm1Line2
	DbSet $glBssapDb $msId TstmIndex $tstmIndex2
	DbSet $glBssapDb $msId BscId $bsc2id

	# Save served instance value in the serving instance
	DbSet $glBssapDb $glMsId DestId $msId

	#LogDb $glBssapDb; #cDEBUG

	log "RcvTrafficDataInd: OrigCicConn=[DbGet $glBssapDb $glMsId CicConnection] --> DestCicConn=[DbGet $glBssapDb $msId CicConnection]"

	set spc [DbGet $glBssapDb $glMsId Spc]
	set stkid [DbGet $glBssapDb $glMsId StkId]

	set pcmType1 	[DbGet $glBssapDb $glMsId PcmType]
	set stm1Line1	[DbGet $glBssapDb $glMsId Stm1Line]
	set lsuPcm1		[DbGet $glBssapDb $glMsId LsuPcm]
	set ts1			[DbGet $glBssapDb $glMsId Ts]

	log "RcvTrafficDataInd: spc=$spc; stkid=$stkid; pcmType1=$pcmType1; stm1Line1=$stm1Line1; lsuPcm1=$lsuPcm1; ts1=$ts1"; #cDEBUG

	# Find Bsc
	set lac1 [DbGet $glBssapDb $glMsId LAC]
	set cell1id [DbGet $glBssapDb $glMsId CellId]
	set bsc1id [GetBscIdByCellIdfr $lac1 $cell1id glBtsDb]
	if { $bsc1id == "-1" } {
		abort "BSC1 identity unknown (LAC1=$lac1, Cell1Id=$cell1id)"
	}
	log "RcvTrafficDataInd: bsc1id=$bsc1id"; #cDEBUG

	# Check if Connect it was done
	if { ![IsVoid [DbGet $glBssapDb $msId CicConnection]] || ![IsVoid [DbGet $glBssapDb $glMsId CicConnection]] } {
		# Connect Mono-directional already done in the other direction --> any action does now
		log "RcvTrafficDataInd: Connect Mono-directional already done in the other direction --> any action does now"; #cDEBUG
	} else {
		# Connect Mono-directional not still done in the other direction --> Connect does now
		if { ![IsVoid $lsuPcm1] && ![IsVoid $lsuPcm2] } {
			if { [IsVoid $pcmType2] && !$pcmType1 || !$pcmType2 && [IsVoid $pcmType1] || !$pcmType1 && !$pcmType2 || [IsVoid $pcmType1] && [IsVoid $pcmType2] } {
				# All Electrical PCMs
				set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
				log "RcvTrafficDataInd: -All Electrical PCMs- connString=$connString"
				DbSet $glBssapDb $glMsId CicConnection $connString
				# Connect Mono Direction (mode=0) 
				SendPcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0
			} elseif { $pcmType1 == 1 && $pcmType2 == 1 } {
				# All STM-1 mapped PCMs 
				set stm1Pcm1Line [DbGet $glBssapDb $glMsId Stm1Line]
				set stm1Pcm2Line [DbGet $glBssapDb $msId Stm1Line]
				append lsuPcm1 -
				append lsuPcm1 $stm1Pcm1Line
				append lsuPcm2 -
				append lsuPcm2 $stm1Pcm2Line
				set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
				log "RcvTrafficDataInd: -All STM-1 mapped PCMs- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2"
				DbSet $glBssapDb $glMsId CicConnection $connString
				# Connect Mono Direction (mode=0)
				SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 4
			} elseif { !$pcmType1 && $pcmType2 == 1 } {
				# PCM 1: Electrical;  PCM 2: STM-1 mapped
				set stm1Pcm2Line [DbGet $glBssapDb $msId Stm1Line]
				append lsuPcm2 -
				append lsuPcm2 $stm1Pcm2Line
				set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
				log "RcvTrafficDataInd: -PCM 1: Electrical;  PCM 2: STM-1 mapped- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2"
				DbSet $glBssapDb $glMsId CicConnection $connString
				# Connect Mono Direction (mode=0)
				SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 5
			} elseif { $pcmType1 == 1 && !$pcmType2 } {
				# PCM 1: STM-1 mapped; PCM 2: Electrical
				set stm1Pcm1Line [DbGet $glBssapDb $glMsId Stm1Line]
				append lsuPcm1 -
				append lsuPcm1 $stm1Pcm1Line
				set connString "LsuPCM $lsuPcm2 $ts2 From LsuPCM $lsuPcm1 $ts1 BSC2 $bsc2id BSC1 $bsc1id"
				log "RcvTrafficDataInd: -PCM 1: STM-1 mapped; PCM 2: Electrical- lsuPcm1=$lsuPcm1 lsuPcm2=$lsuPcm2 ts1=$ts1 ts2=$ts2"
				DbSet $glBssapDb $glMsId CicConnection $connString
				# Connect Mono Direction (mode=0)
				SendMixedStm1PcmConnect $spc $stkid $lsuPcm2 $ts2 $lsuPcm1 $ts1 0 6
			} else {
				logscr "RcvTrafficDataInd: WARNING: the Pcm2Type=[DbGet $glBssapDb $glMsId PcmType] and Pcm1Type=[DbGet $glBssapDb $msId PcmType] fields must be equal to 0 or 1"
			}
		} else {
			log "RcvTrafficDataInd: WARNING: glMsId=$glMsId <--> lsuPcm1=$lsuPcm1; msId=$msId <--> lsuPcm2=$lsuPcm2"
		}
	}

	# ---------------- #
	# TMA-357
	# PATCH Carlo 17/02/2010
	# setto anche la connString inversa e poi la memorizzaro nel BssapDb
	# attenzione: gli indice dei BSC sono invertiti perche Ã¨ la connex inversa
	set connStringReverse "LsuPCM $lsuPcm1 $ts1 From LsuPCM $lsuPcm2 $ts2 BSC2 $bsc1id BSC1 $bsc2id"
	log "RcvTrafficDataInd: msId=$msId connStringReverse=$connStringReverse"; #cDEBUG

	# Carlo PATCH for Alcatel Shanghai 03/06/2010
	###
	if { [DbKeyExists $glBssapDb CicConnection $connStringReverse] } {
		set idx [DbGetIdx $glBssapDb CicConnection $connStringReverse]
		log ""
		log "WARNING: CicConnection ($connStringReverse) already assigned for MS $idx"
		log ""
		#LogDb $glBssapDb; #cDEBUG
		if { ![IsVoid $lsuPcm1] && ![IsVoid $lsuPcm2] } {
			log "RcvTrafficDataInd: ERROR! (idx=$idx)"
			exit
		} elseif { [IsVoid $lsuPcm1] && [IsVoid $lsuPcm2] } {
			log "RcvTrafficDataInd: OK --> case of NO Traffic Testing (idx=$idx)"
		} else {
			log "RcvTrafficDataInd: WARNING --> to check in the TrafficDb the field LsuPcm"
		}
		log "RcvTrafficDataInd: Any setting of the 'CicConnection' field done in the $glBssapDb"
	} else {
		DbSet $glBssapDb $msId CicConnection $connStringReverse
	}
	###
	# ---------------- #

	#LogDb $glBssapDb; #cDEBUG
}

########################################################
# 0: Disconnection; 1: Reconnection
proc AflexHovManagement { Type ConnString Spc StkId } {

	global glBssapDb glMsId

	set lsuPcm2 	[lindex $ConnString 1]; #Output
	set ts2 		[lindex $ConnString 2]
	set bsc2id  	[lindex $ConnString 8]

	set lsuPcm2_0 	[lindex [split $lsuPcm2 -] 0]
	set lsuPcm2_1 	[lindex [split $lsuPcm2 -] 1]

	if { !$Type } {
		# Disconnection phase
		log "AflexHovManagement: #DISCONNECTION PHASE#  ConnString=$ConnString"
		set lsuPcm1 	[lindex $ConnString 5]; #Input
		set ts1  		[lindex $ConnString 6]

		set lsuPcm1_0 	[lindex [split $lsuPcm1 -] 0]
		set lsuPcm1_1 	[lindex [split $lsuPcm1 -] 1]

		if { [IsVoid [DbGet $glBssapDb $glMsId PcmType]] && [IsEmpty $lsuPcm2_1] && [IsEmpty $lsuPcm1_1] || [IsEmpty [DbGet $glBssapDb $glMsId PcmType]] && [IsEmpty $lsuPcm2_1] && [IsEmpty $lsuPcm1_1] || ![DbGet $glBssapDb $glMsId PcmType] && [IsEmpty $lsuPcm2_1] && [IsEmpty $lsuPcm1_1] } {
			# All Electrical PCMs
			log "All Electrical PCMs"
			log "AflexHovManagement: Disconnection $lsuPcm1 --> $lsuPcm2 "
			SendPcmDisconnect $Spc $StkId $lsuPcm2 $ts2 $lsuPcm1 $ts1 2
		
			log "AflexHovManagement: Disconnection $lsuPcm2 --> $lsuPcm1"
			SendPcmDisconnect $Spc $StkId $lsuPcm1 $ts1 $lsuPcm2 $ts2 2

		} elseif { ![IsEmpty $lsuPcm1_1] && ![IsEmpty $lsuPcm2_1] && ![IsVoid $lsuPcm1_1] && ![IsVoid $lsuPcm2_1] } {
			# All STM-1 mapped PCMs
			log "All STM-1 mapped PCMs"
			log "AflexHovManagement: Disconnection $lsuPcm1 <--> $lsuPcm2 "
			SendMixedStm1PcmDisconnect $Spc $StkId $lsuPcm2 $ts2 $lsuPcm1 $ts1 3 4
		} elseif { [IsEmpty $lsuPcm1_1] && ![IsEmpty $lsuPcm2_1] && ![IsVoid $lsuPcm2_1] || [IsVoid $lsuPcm1_1] && ![IsEmpty $lsuPcm2_1] && ![IsVoid $lsuPcm2_1] } {
			# PCM 1 (In): Electrical;  PCM 2 (Out): STM-1 mapped
			log "PCM 1 (In): Electrical;  PCM 2 (Out): STM-1 mapped"
			log "AflexHovManagement: Disconnection $lsuPcm1 <--> $lsuPcm2 "
			SendMixedStm1PcmDisconnect $Spc $StkId $lsuPcm2 $ts2 $lsuPcm1 $ts1 3 5
		} elseif { ![IsEmpty $lsuPcm1_1] && ![IsVoid $lsuPcm1_1] && [IsEmpty $lsuPcm2_1] || ![IsEmpty $lsuPcm1_1] && ![IsVoid $lsuPcm1_1] && [IsVoid $lsuPcm2_1] } {
			# PCM 1 (In): STM-1 mapped; PCM 2 (Out): Electrical
			log "PCM 1 (In): STM-1 mapped; PCM 2 (Out): Electrical"
			log "AflexHovManagement: Disconnection $lsuPcm1 <--> $lsuPcm2 "
			SendMixedStm1PcmDisconnect $Spc $StkId $lsuPcm2 $ts2 $lsuPcm1 $ts1 3 6
		} else {
			logscr "AflexHovManagement: ERROR --> the Pcm1Type=[DbGet $trfDb1 $pcm1Idx PcmType] and Pcm2Type=[DbGet $trfDb2 $pcm2Idx PcmType]                                                            must be equal to 0 or 1 if 'PcmType' field exists in the trfDb1=$trfDb1 and in the trfDb2=$trfDb2"
		}
	} elseif { $Type } {
		# Reconnection phase
		log "AflexHovManagement: #RECONNECTION PHASE#  TargetConnString=$ConnString"
		set lsuTgtPcm1 		[lindex $ConnString 5];  # new Pcm target
		set tgtTs1  		[lindex $ConnString 6];  # new Ts  target
		set tgtBscId 		[lindex $ConnString 10]; # new Bsc target

		set lsuTgtPcm1_0 	[lindex [split $lsuTgtPcm1 -] 0]
		set lsuTgtPcm1_1 	[lindex [split $lsuTgtPcm1 -] 1]

		log "AflexHovManagement: lsuPcm2_1=$lsuPcm2_1; lsuTgtPcm1_1=$lsuTgtPcm1_1"; #cDEBUG
		
		if { [IsEmpty $lsuPcm2_1] && [IsEmpty $lsuTgtPcm1_1] || [IsEmpty $lsuPcm2_1] && [IsVoid $lsuTgtPcm1_1] || [IsVoid $lsuPcm2_1] && [IsEmpty $lsuTgtPcm1_1] || [IsVoid $lsuPcm2_1] && [IsVoid $lsuTgtPcm1_1] } {
			# All Electrical PCMs
			log "AflexHovManagement: All Electrical PCMs; lsuPcm2=$lsuPcm2 ts2=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
			# Connect BiDirectional
			SendPcmConnect $Spc $StkId $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1
		} elseif { ![IsEmpty $lsuTgtPcm1_1] && ![IsEmpty $lsuPcm2_1] && ![IsVoid $lsuTgtPcm1_1] && ![IsVoid $lsuPcm2_1] } {
			# All STM-1 mapped PCMs
			log "AflexHovManagement: All STM-1 mapped PCMs; lsuPcm2=$lsuPcm2 ts2=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
			# Connect BiDirectional
			SendMixedStm1PcmConnect $Spc $StkId $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1 4
		} elseif { [IsEmpty $lsuTgtPcm1_1] && ![IsEmpty $lsuPcm2_1] && ![IsVoid $lsuPcm2_1] || [IsVoid $lsuTgtPcm1_1] && ![IsEmpty $lsuPcm2_1] && ![IsVoid $lsuPcm2_1] } {
			# PCM 1: Electrical;  PCM 2: STM-1 mapped
			log "AflexHovManagement: Pcm 1: Electrical --> PCM 2: STM-1 mapped PCM; lsuPcm2=$lsuPcm2 ts2=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
			# Connect BiDirectional
			SendMixedStm1PcmConnect $Spc $StkId $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1 5
		} elseif { ![IsEmpty $lsuTgtPcm1_1] && ![IsVoid $lsuTgtPcm1_1] && [IsEmpty $lsuPcm2_1] || ![IsEmpty $lsuTgtPcm1_1] && ![IsVoid $lsuTgtPcm1_1] && [IsVoid $lsuPcm2_1] } {
			# PCM 1: STM-1 mapped; PCM 2: Electrical
			log "AflexHovManagement: PCM 1: STM-1 mapped PCM --> Pcm 2: Electrical; lsuPcm2=$lsuPcm2 ts2=$ts2 lsuTgtPcm1=$lsuTgtPcm1 tgtTs1=$tgtTs1"
			# Connect BiDirectional
			SendMixedStm1PcmConnect $Spc $StkId $lsuPcm2 $ts2 $lsuTgtPcm1 $tgtTs1 1 6
		} else {
			logscr "AflexHovManagement: ERROR --> the Pcm1Type and Pcm2Type have to be equal to 0 or 1"
		}
		log "AflexHovManagement: Handover Terminated: Old_CicConnection=[DbGet $glBssapDb $glMsId CicConnection]"
	} else {
		log "AflexHovManagement: ERROR: Type=$Type must be equal to 0 (Disconnection) or 1 (Reconnection)"
	}
}

######################################################
proc RcvHovDataInd { } {

	global _sig glBssapDb glMsId

	LogInputSig

	set msId 		[rd _sig MsId]
	set connString	[rd _sig ConnectString]
	set tstmIndex2	[rd _sig TstmIndex]
	set dstId		[rd _sig DestMsId]

	log "RcvHovDataInd: (msId=$msId = glMsId=$glMsId) --> (dstId=$dstId); dstTstmIndex=$tstmIndex2"; #cDEBUG
	log "connString=$connString"
	
	# Retrieve connection data from the ConnString
	if { ![IsVoid $connString] } {
		set lsuPcm2 	[lindex $connString 1]
		set ts2 		[lindex $connString 2]
		set stm1Line2	[lindex [split $lsuPcm2 -] 1]
		set bsc2id 		[lindex $connString 8]

		if { ![IsEmpty $stm1Line2] && ![IsVoid $stm1Line2] } {
			set pcmType2	1	
		} elseif { [IsEmpty $stm1Line2] || [IsVoid $stm1Line2] } {
			set pcmType2	0
		} else {
			log "RcvHovDataInd: WARNING!"
		}
		log "RcvHovDataInd: lsuPcm2=$lsuPcm2; ts2=$ts2; stm1Line2=$stm1Line2; pcmType2=$pcmType2; bsc2id=$bsc2id"
	} else {
		abort "RcvHovDataInd: WARNING: connString is void"
	}

	# Save Traffic Data about the Served Instance (msId=glMsId) in the Db
	DbSet $glBssapDb $msId LsuPcm $lsuPcm2
	DbSet $glBssapDb $msId Ts $ts2
	DbSet $glBssapDb $msId PcmType $pcmType2
	DbSet $glBssapDb $msId Stm1Line $stm1Line2
	DbSet $glBssapDb $msId TstmIndex $tstmIndex2
	DbSet $glBssapDb $msId BscId $bsc2id

	###
	# Carlo PATCH for Alcatel Shanghai 03/06/2010
	if { [DbKeyExists $glBssapDb CicConnection $connString] } {
		set idx [DbGetIdx $glBssapDb CicConnection $connString]
		log ""
		log "WARNING: CicConnection ($connString) already assigned for MS $idx"
		log ""
		#LogDb $glBssapDb; #cDEBUG
		set lsu_Pcm1 	[lindex $connString 5]
		if { ![IsVoid $lsu_Pcm1] && ![IsVoid $lsuPcm2] } {
			log "RcvHovDataInd: ERROR! (idx=$idx)"
			exit
		} elseif { [IsVoid $lsu_Pcm1] && [IsVoid $lsuPcm2] } {
			log "RcvHovDataInd: OK --> case of NO Traffic Testing (idx=$idx)"
		} else {
			log "RcvHovDataInd: WARNING --> to check in the TrafficDb the field LsuPcm"
		}
		log "RcvHovDataInd: Any setting of the 'CicConnection' field done in the $glBssapDb"
	} else {
		# save new Reverse Connection Data
		DbSet $glBssapDb $dstId CicConnection $connString
	}
	###

	# ----- #
	set lsuPcm1 	[lindex $connString 5]
	set ts1 		[lindex $connString 6]
	set bsc1id 		[lindex $connString 10]

	set stm1Line1	[lindex [split $lsuPcm1 -] 1]
	if { ![IsEmpty $stm1Line1] && ![IsVoid $stm1Line1] } {
		set pcmType1	1	
	} elseif { [IsEmpty $stm1Line1] || [IsVoid $stm1Line1] } {
		set pcmType1	0
	} else {
		log "RcvHovDataInd: --WARNING-- !"
	}
	log "RcvHovDataInd: lsuPcm1=$lsuPcm1; ts1=$ts1; stm1Line1=$stm1Line1; pcmType1=$pcmType1; bsc1id=$bsc1id"

	# Save Traffic Data about the Serving Instance (dstId) in the Db
	DbSet $glBssapDb $dstId LsuPcm $lsuPcm1
	DbSet $glBssapDb $dstId Ts $ts1
	DbSet $glBssapDb $dstId PcmType $pcmType1
	DbSet $glBssapDb $dstId Stm1Line $stm1Line1
	DbSet $glBssapDb $dstId BscId $bsc1id

	set directConnString "LsuPCM $lsuPcm1 $ts1 From LsuPCM $lsuPcm2 $ts2 BSC2 $bsc1id BSC1 $bsc2id"

	log "RcvHovDataInd: dstId=$dstId -> reverseConnString=$connString; glMsId=$glMsId --> directConnString=$directConnString"; #cDEBUG

	###
	# Carlo PATCH for Alcatel Shanghai 03/06/2010
	if { [DbKeyExists $glBssapDb CicConnection $directConnString] } {
		set idx [DbGetIdx $glBssapDb CicConnection $directConnString]
		log ""
		log "WARNING: CicConnection ($directConnString) already assigned for MS $idx"
		log ""
		#LogDb $glBssapDb; #cDEBUG
		if { ![IsVoid $lsuPcm1] && ![IsVoid $lsuPcm2] } {
			log "RcvHovDataInd: ERROR! (idx=$idx)"
			exit
		} elseif { [IsVoid $lsuPcm1] && [IsVoid $lsuPcm2] } {
			log "RcvHovDataInd: OK --> case of NO Traffic Testing (idx=$idx)"
		} else {
			log "RcvHovDataInd: WARNING --> to check in the TrafficDb the field LsuPcm"
		}
		log "RcvHovDataInd: Any setting of the 'CicConnection' field done in the $glBssapDb"
	} else {
		# save new Direct Connection Data
		DbSet $glBssapDb $msId CicConnection $directConnString
	}
	###
	log "RcvHovDataInd: OrigCicConn=[DbGet $glBssapDb $dstId CicConnection] --> DestCicConn=[DbGet $glBssapDb $glMsId CicConnection]"
}

##############################################################
# FSM
##############################################################

state BssapWaitConfig {
	BSSAP_OM_CFG 				BssapConfig
	default 					Unexpected
}

state WaitForBssapPlusConfig {
	BSSAPPLUS_OM_CFG_ACK		BssapPlusCfgAck	
	default 					Unexpected
}

state BssapWaitForResetAck {
	RST_ACK 					RcvResetAck
	RST_CIRC					RcvMsgDiscard
   	RST 						RcvReset
	CIRC_GROUP_BLK				RcvCircGroupBlk
	CIRC_GROUP_UBLK				RcvCircGroupUnblk
	BLK							RcvBlk
	UBLK						RcvUblk
   	T_RST 						RcvTReset
	LE_RST						RcvLeReset
	BSSAP_OM_PCSTATE_IND		OmPcStateIndHnd
	T_16						T_16Expired
	T_RESET_GLOBAL				T_GlobalReset
	default						Unexpected
}

state WaitResetResAck {
	T_RESET_GLOBAL				T_GlobalReset
	RESET_RESOURCE				RcvResetResource
	RESET_RESOURCE_ACK 			RcvResetResourceAck
	T_RESET_IPRESOURCE			T_ResetIpResource
	T_RMSC						T_RmscExpired
	RST_ACK						LogInputSig
	default						Unexpected
}

state WaitRstCircAck {
	T_RESET_GLOBAL				T_GlobalReset
	RST_CIRC_ACK				RcvResetCircuitAck
	T_RESET_TDMCIRCUIT			T_ResetTdmCircuit
	UQPPD_CIRC					RcvUnequippedCirc
	RST_ACK						LogInputSig
	default 					Unexpected
}

state BssapIdle {
	CONNECT_IND 				RcvConnectInd
	CMPLT_L3_INFO       		RcvInitialMsMsg
	BSSAP_AP_EST_REQ 			RcvApEstReq
	BSSAP_AP_EST_ACK 			RcvApEstAck
	BSSAP_AP_ABORT_REQ 			RcvApAbortReq
	BSSAPGS_AP_ABORT_REQ		RcvApAbortGsReq
	T_PAG						T_PagExpired
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	BSSAP_AP_SYNC_REQ			RcvApSyncReqIdle
	RST_CIRC					RcvMsgDiscard
	RST_ACK						LogInputSig
	RESET_RESOURCE_ACK 			RcvResetResourceAck
	RST_CIRC_ACK				RcvResetCircuitAck
	T_RMSC						T_RmscExpired
	UQPPD_CIRC					RcvUnequippedCirc
	RTP_CLOSE_ACK               RcvRtpCloseAckIdle
	default 					Any
}

state BssapConnectActive {
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_DATA_REQ 			RcvApDataReq
	BSSAP_AP_REL_REQ 			RcvApRelReq
	BSSAP_AP_ABORT_REQ 			RcvApAbortReqRelease
	BSSAP_AP_SYNC_REQ 			RcvApSyncReq
	BSSAP_AP_SET_INST       	RcvApSetInst
	BSSAP_CTL_VGCS_DEDI_REL_REQ RcvDedicatedRelReq
	HOV_PERFD					RcvHovPerformed
	HOV_RQRD					RcvHovRequired
	INTERNAL_HO_RQD             RcvInternalHovRequired
	PERF_LOC_RSP				RcvPerfLocRsp
	CLR_REQ						RcvClrReqServing
	RST_CIRC					RcvClrReqServing
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	BSSAP_CTL_INT_HOV_ENQUIRY   RcvCtlIntHovEnquiry
	HOV_FAIL					RcvRejectIntHovEnquiry
	RAB_OPEN_ACK                LogInputSig
	default 					Any
}

state WaitCphrCmplt {
	DTAP_DATA 					RcvDirTransfInCphrCmplt
	BSSAP_AP_REL_REQ			RcvApRelReqCphrCmplt	
	BSSAP_AP_ABORT_REQ 			RcvApAbortReqRelease
	CPHR_MODE_CMPLT				RcvCphrModeCmpl	
	HOV_RQRD                	RcvMsgDiscard
	CLR_REQ						RcvClrReqServing
	RST_CIRC					RcvClrReqServing
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	T_CIPHR						T_CiphrExpired
	default 					Any
}

state WaitForClrCmplt {
	BSSAP_AP_EST_REQ 			RcvApEstReq
	BSSAP_AP_SYNC_REQ			RcvApSyncReqIdle
	BSSAP_AP_EST_ACK 			RcvApEstAck
	BSSAP_AP_ABORT_REQ 			RcvApAbortReq
	DTAP_DATA 					RcvDirectTransfer
	CLR_CMPLT					RcvClrCmplt
	HOV_RQRD                	RcvMsgDiscard
	HOV_REQ_ACK 				RcvMsgDiscard
	CLR_REQ						RcvClrReqClrCmplt
	T_PAG						T_PagExpired
	RST_CIRC					RcvMsgDiscard
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	default						Any
}

state WaitForAssignRes {
	BSSAP_AP_DATA_REQ 			RcvApDataReq
	BSSAP_AP_REL_REQ 			RcvApRelReq
	DTAP_DATA 					RcvDirectTransfer
	ASG_CMPLT					RcvAssignCmplt
	ASG_FAIL					RcvAssignFail
	QUENG_IND					RcvQueuingInd
	PERF_LOC_RSP				RcvPerfLocRsp
	CLR_REQ						RcvClrReqServing
	RST_CIRC					RcvClrReqServing
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	HOV_RQRD                	RcvMsgDiscard
	default						Any
}

state DuringExternalHov {
	HOV_REQ_ACK 				RcvMsgDiscard
	HOV_DET						RcvHovDetect
	CLSMK_UPD					RcvClsmkUpdExtHov
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_REL_REQ 			RcvApRelReqTgt
	CLR_CMPLT					RcvClrCmpltDuringHov
	CLR_REQ						RcvMsgDiscard
	RST_CIRC					RcvMsgDiscard
	DISCONNECT_IND 				RcvDisconnectIndDuringHov
	T_CLEARCOMPLETE				RcvTClrCmplteDuringHov
	default						Any
}

state WaitForConnAckInHovReq {
	BSSAP_AP_DATA_REQ 			RcvApDataReq
	BSSAP_AP_SYNC_REQ			RcvMsgDiscard
	DTAP_DATA 					RcvDirectTransfer
	CONNECT_ACK 				RcvConnAckInHovReq
	BSSAP_AP_REL_REQ 			RcvEventHold
	CLR_REQ						RcvEventHold
	RST_CIRC					RcvEventHold
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	T_RG_TRR2					T_HoReqNotAnswerExpired
	default						Any
}

state WaitForConnCnfInHovReq {
	CONNECT_CNF 				RcvConnCnfInHovReq
	BSSAP_AP_DATA_REQ 			RcvApDataReq
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_REL_REQ 			RcvApRelReqDisc
	CLR_REQ						RcvEventHold
	RST_CIRC					RcvEventHold
	DISCONNECT_IND 				RcvDisconnectIndInHovReqNotCompleted
	T_CLEARCOMPLETE				RcvTClrCmplte
	T_RG_TRR2					T_HoReqNotAnswerExpired
	default						Any
}
	#Carlo TMA-358 changed the signal under in the previous state
	#DISCONNECT_IND 				RcvDisconnectInd

state WaitForHovReqAck {
	HOV_REQ_ACK 				RcvHovReqAck
	HOV_FAIL					RcvHovFail
	HOV_RQRD                	RcvMsgDiscard
	BSSAP_AP_DATA_REQ 			RcvApDataReq
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_REL_REQ 			RcvApRelReqTgt
	CLR_CMPLT					RcvClrCmpltHovFailed
	QUENG_IND					RcvQueuingInd
	CLR_REQ						RcvClrReqHovFailed
	RST_CIRC					RcvClrReqHovFailed
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	T_RG_TRR2					T_HoReqNotAnswerExpired
	default						Any
}

state _c_WaitForHovProcCompleted {
	HOV_FAIL					RcvHovFail
	HOV_DET						RcvHovDetect
	HOV_CMPLT					RcvHovCmplt
	HOV_RQRD                	RcvMsgDiscard
	BSSAP_AP_DATA_REQ 			EnqueueApDataReq
	BSSAP_AP_SYNC_REQ 			EnqueueApSyncReq
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_REL_REQ 			RcvApRelReqTgt
	CLR_CMPLT					RcvClrCmpltHovFailed
	QUENG_IND					RcvQueuingInd
	CLR_REQ						RcvClrReq
	RST_CIRC					RcvClrReq
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	RTP_CLOSE_ACK               SwitchAoipResourcesAfterRtpCloseAck
	default						Any
}

state _c_WaitForIntHovProcCompleted {
	HOV_FAIL					RcvIntHovFail
	HOV_DET						RcvHovDetect
	HOV_CMPLT					RcvIntHovCmplt
	HOV_RQRD                	RcvMsgDiscard
	BSSAP_AP_DATA_REQ 			EnqueueApDataReq
	BSSAP_AP_SYNC_REQ 			EnqueueApSyncReq
	DTAP_DATA 					RcvDirectTransfer
	QUENG_IND					RcvQueuingInd
	CLR_REQ						RcvClrReq
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	INTERNAL_HO_RQD             RcvMsgDiscard
	BSSAP_AP_REL_REQ 			RcvApRelReqIntHovCpltd
	PERF_LOC_RSP				RcvPerfLocRsp
	default						Any
}

state WaitForHovProcFailed {
	HOV_RQRD                	RcvMsgDiscard
	BSSAP_AP_DATA_REQ 			RcvApDataReq
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_REL_REQ 			RcvApRelReqTgt
	CLR_CMPLT					RcvClrCmpltHovFailed
	QUENG_IND					RcvQueuingInd
	CLR_REQ						RcvClrReqHovFailed
	RST_CIRC					RcvClrReqHovFailed
	DISCONNECT_IND 				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	default						Any
}

state _c_WaitForHovProcComplTgtOnly {
	HOV_FAIL					RcvHovFailTgtOnly
	HOV_DET						RcvHovDetect
	HOV_CMPLT					RcvHovCmpltTarget
	CLR_CMPLT					RcvClrCmpltTgtOnly
	BSSAP_AP_DATA_REQ 			EnqueueApDataReq
	DTAP_DATA 					RcvDirectTransfer
	QUENG_IND					RcvQueuingInd
	BSSAP_AP_REL_REQ 			RcvApRelReqTgtOnly
	CLR_REQ						RcvClrReqHovCompleted
	RST_CIRC					RcvClrReqHovCompleted
	DISCONNECT_IND 				RcvDisconnectIndTgtOnly
	T_CLEARCOMPLETE				RcvTClrCmpltTgtOnly
	default						Any
}

state _c_WaitForClrCmpltHov {
	BSSAP_AP_DATA_REQ 			RcvApDataReqHov
	BSSAP_AP_SYNC_REQ           RcvApSyncReq
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_REL_REQ 			RcvApRelReqTgtOnly
	CLR_CMPLT					RcvClrCmpltHovCompleted
	CLR_REQ						RcvClrReqHovCompleted
	RST_CIRC                	RcvClrReqHovCompleted
	DISCONNECT_IND 				RcvDisconnectIndHovCompleted
	T_CLEARCOMPLETE				RcvTClrCmplteHovCompleted
	default						Any
}

state WaitForDediConnectAck {
	CONNECT_ACK					RecvConnAckDediReq
	DISCONNECT_IND				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	default 					Any
}

state WaitForDediConnectCnf {
	DISCONNECT_IND				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	CONNECT_CNF					RecvConnCnfDediReq
	default 					Any
}

state WaitForDediAsgCmplte {
	BSSAP_CTL_VGCS_DEDI_REL_REQ RecvDediRelReqAsgCmplte
	ASG_CMPLT					RecvAsgCmplteDediReq
	ASG_FAIL					RecvAsgFailDediReq
	DISCONNECT_IND				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	default 					Any
}

state WaitRtpOpenAck {
	RTP_OPEN_ACK                RecvRtpOpenAck
	RAB_OPEN_ACK                SendSyncCnf
	PLAY_OPEN_ACK              	SendSyncCnf
	START_ACK                  	SendSyncCnf
	RTP_OPEN_NAK               	RecvRtpOpenNak
	RAB_OPEN_NAK               	{ LogInputSig ; exit }
	PLAY_OPEN_NAK               { LogInputSig ; exit }
	START_NAK                   { LogInputSig ; exit }
	PERF_LOC_RSP				RcvPerfLocRsp
	DTAP_DATA					save	
	CLR_REQ						RcvClrReqServing
	BSSAP_AP_REL_REQ			RcvApRelReq
	INTERNAL_HO_RQD				RcvIntHoRqdWaitRtpOpenAck
	default						DuringRtpOpenAck
}

state WaitRtpOpenAckHo {
	RTP_OPEN_ACK                RecvRtpOpenAckHo
	RAB_OPEN_ACK                LogInputSig
	PLAY_OPEN_ACK               LogInputSig
	START_ACK                   LogInputSig
	RTP_OPEN_NAK               	RecvRtpOpenNak
	RAB_OPEN_NAK               	{ LogInputSig ; exit }
	PLAY_OPEN_NAK               { LogInputSig ; exit }
	START_NAK                   { LogInputSig ; exit }
	default 					Any
}

state WaitRtpOpenAckIntHo {
	RTP_OPEN_ACK                RecvRtpOpenAckIntHo
	RAB_OPEN_ACK                LogInputSig
	PLAY_OPEN_ACK               LogInputSig
	START_ACK                   LogInputSig
	RTP_OPEN_NAK               	RecvRtpOpenNak
	RAB_OPEN_NAK                { LogInputSig ; exit }
	PLAY_OPEN_NAK               { LogInputSig ; exit }
	START_NAK                   { LogInputSig ; exit }
	RAB_CLOSE_ACK				LogInputSig
	RTP_CLOSE_ACK				LogInputSig
	default 					DuringRtpOpenAckIntHo
}

state DuringRtpOpenAckIntHo {
	CLR_REQ						RcvClrReqServing
	DISCONNECT_IND 				RcvDisconnectInd
	INTERNAL_HO_RQD             LogInputSig
	BSSAP_AP_REL_REQ 			RcvApRelReq
	HOV_PERFD					RcvHovPerformed
	default 					Any
}

state DuringRtpOpenAck {
	CLR_REQ						RcvClrReqServing
	HOV_PERFD					RcvHovPerformed
	BSSAP_AP_SYNC_REQ			skipMsg
	DISCONNECT_IND 				RcvDisconnectInd
	default 					Any
}

state WaitForCicAsgRes_HovReq {
	BSSAP_CIC_ASG_RES			SLAVE_RecvCicAsgRes_HovReq
	DTAP_DATA 					RcvDirectTransfer
	default 					Any
}

state WaitForIpTdmAsgRes_AsgReq {
	BSSAP_CIC_ASG_RES			SLAVE_RcvCommonIpTdmResourcesAsgRes_AsgReq
	BSSAP_TLA_ASG_RES			SLAVE_RcvCommonIpTdmResourcesAsgRes_AsgReq
	DTAP_DATA 					RcvDirectTransfer
	CLR_REQ						RcvClrReqServing
	default 					Any
}
# 12/03/2012 aggiunto nello stato sopra
#CLR_REQ						RcvClrReqServing

state WaitForIpTdmAsgRes_IntHovCmd {
	BSSAP_CIC_ASG_RES			SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd
	BSSAP_TLA_ASG_RES			SLAVE_RcvCommonIpTdmResourcesAsgRes_IntHovCmd
	DTAP_DATA 					RcvDirectTransfer
	BSSAP_AP_REL_REQ 			RcvApRelReq
	default 					Any
}

state WaitForConnectAck_PerfLoc {
	CONNECT_ACK					RecvConnAck_PerfLoc	
	DISCONNECT_IND				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	default 					Any
}

state WaitForConnectCnf_PerfLoc {
	CONNECT_CNF					RecvConnCnf_PerfLoc	
	DISCONNECT_IND				RcvDisconnectInd
	T_CLEARCOMPLETE				RcvTClrCmplte
	default 					Any
}
	
state Any {
   	RST 						RcvReset
   	T_RST 						RcvTReset
	BSSAP_OM_PCSTATE_IND		OmPcStateIndHnd
	BSSAP_CTL_RESET_CIRC   		RcvCtlResetTdmCircuit
	T_RESET_TDMCIRCUIT			T_ResetTdmCircuit
	BSSAP_CTL_RESET_RESOURCES   RcvCtlResetResources
	T_RESET_IPRESOURCE			T_ResetIpResource
	BSSAP_CTL_RESET				RcvCtlReset
	T_RESET_GLOBAL				T_GlobalReset
	BSSAP_AP_CLSMK1_UPDATE		RcvApClsmk1Update
	BSSAP_AP_CLSMK2_UPDATE		RcvApClsmk2Update
	BSSAP_AP_CLSMK3_UPDATE		RcvApClsmk3Update
	BSSAP_EST_NACK				RcvEstNack
	BSSAP_AP_EST_REQ 			OutOfSync
	BLK							RcvBlk
	UBLK						RcvUblk
	CIRC_GROUP_BLK				RcvCircGroupBlk
	CIRC_GROUP_UBLK				RcvCircGroupUnblk
	CLSMK_UPD					RcvClsmkUpd
	RST_CIRC					RcvResetCircuit
	RESET_RESOURCE              RcvResetResource
	T_PAG						T_RestartTPAG
	BSSAP_AP_REL_REQ_LINK		RcvApRelReqLink
	TERMINATE_ACK               LogInputSig
	PLAY_CLOSE_ACK              LogInputSig
	RAB_CLOSE_NAK               LogInputSig
	RTP_CLOSE_NAK               LogInputSig
	RAB_CLOSE_ACK               RcvRabCloseAck
	RTP_CLOSE_ACK               RcvRtpCloseAck
	BSSAP_CIC_ASG_REQ			MASTER_RcvCicAsgReq
	BSSAP_CIC_REL_REQ			MASTER_RcvCicRelReq
	BSSAP_TLA_ASG_REQ			MASTER_RcvTlaAsgReq
	BSSAP_TLA_REL_REQ			MASTER_RcvTlaRelReq
	BSSAP_RESET_TDMCIRCUIT_REQ	MASTER_RcvResetTdmCircuitReq
	BSSAP_RESET_TDMCIRCUIT_RES	SLAVE_RcvResetTdmCircuitRes
	BSSAP_UQPPD_CIRC_IND		SLAVE_RcvUnequippedCircuitInd
	BSSAP_RESET_RESOURCE_REQ	MASTER_RcvResetResourceReq
	BSSAP_RESET_RESOURCE_RES	SLAVE_RcvResetResourceRes
	BSSAP_AP_NEW_TMSI_ALLOC		RcvApNewTmsiAlloc
	BSSAP_NEW_TMSI_ALLOC		RcvNewTmsiAlloc
	BSSAP_CTL_MSC_TRACE_INVOKE	RcvCtlMscTracInvoke
	BSSAP_CTL_SEND_OVERLOAD		RcvCtlSendOverload
	BSSAP_TRAFFIC_DATA_IND		RcvTrafficDataInd
	BSSAP_HOV_DATA_IND			RcvHovDataInd
	BSSAP_AP_PERF_LOC_CMD   	RcvApPerfLocCmd
	BSSAP_LE_SET_USERPID		SetLeUserPid
	LE_RST						RcvLeReset
   	T_LE_RST					RcvTLeReset
	T_USR_LE_RST				RcvTUsrLeRst
	BSSAP_SET_CC_PID			SetCcPid
	default 					Unexpected
}

#EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE#
